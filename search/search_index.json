{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TiTiler","text":"<p> <p>A modern dynamic tile server built on top of FastAPI and Rasterio/GDAL.</p> </p> <p> </p> <p>Documentation: devseed.com/titiler/</p> <p>Source Code: developmentseed/titiler</p> <p><code>TiTiler</code>, pronounced tee-tiler (ti is the diminutive version of the french petit which means small), is a set of python modules that focus on creating FastAPI application for dynamic tiling.</p> <p>Note: This project is the descendant of <code>cogeo-tiler</code> and <code>cogeo-mosaic-tiler</code>.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Built on top of FastAPI</li> <li>Cloud Optimized GeoTIFF support</li> <li>SpatioTemporal Asset Catalog support</li> <li>Multiple projections support (see TileMatrixSets) via <code>morecantile</code>.</li> <li>MultiDimensional dataset support via Xarray</li> <li>JPEG / JP2 / PNG / WEBP / GTIFF / NumpyTile output format support</li> <li>OGC WMTS support</li> <li>Automatic OpenAPI documentation (FastAPI builtin)</li> <li>Virtual mosaic support (via MosaicJSON)</li> <li>Example of AWS Lambda / ECS deployment (via CDK)</li> </ul>"},{"location":"#packages","title":"Packages","text":"<p>Starting with version <code>0.3.0</code>, the <code>TiTiler</code> python module has been split into a set of python namespace packages: <code>titiler.{package}</code>.</p> Package Version Description titiler.core The <code>Core</code> package contains libraries to help create a  dynamic tiler for COG and STAC titiler.xarray The <code>xarray</code> package contains libraries to help create a  dynamic tiler for Zarr/NetCDF datasets titiler.extensions TiTiler's extensions package. Contains extensions for Tiler Factories. titiler.mosaic The <code>mosaic</code> package contains libraries to help create a dynamic tiler for MosaicJSON (adds <code>cogeo-mosaic</code> requirement) titiler.application TiTiler's <code>demo</code> package. Contains a FastAPI application with full support of COG, STAC and MosaicJSON"},{"location":"#installation","title":"Installation","text":"<p>To install from PyPI and run:</p> <pre><code># Make sure you have pip up to date\npython -m pip install -U pip\n\npython -m pip  install titiler.{package}\n# e.g.,\n# python -m pip  install titiler.core\n# python -m pip  install titiler.xarray\n# python -m pip  install titiler.extensions\n# python -m pip  install titiler.mosaic\n# python -m pip  install titiler.application (also installs core, extensions and mosaic)\n\n# Install uvicorn to run the FastAPI application locally\npython -m pip install uvicorn\n\n# Launch application locally\nuvicorn titiler.application.main:app\n</code></pre> <p>To install from sources and run for development:</p> <pre><code>git clone https://github.com/developmentseed/titiler.git\ncd titiler\n\nuv sync\nuv run pip install uvicorn\nuv run uvicorn titiler.application.main:app --reload\n</code></pre>"},{"location":"#docker","title":"Docker","text":"<p>Ready to use/deploy images can be found on Github registry.</p> <ul> <li>github.com/developmentseed/titiler/pkgs/container/titiler</li> </ul> <pre><code>docker run \\\n    --platform=linux/amd64 \\\n    -p 8000:8000 \\\n    --rm -it ghcr.io/developmentseed/titiler:latest \\\n    uvicorn titiler.application.main:app --host 0.0.0.0 --port 8000 --workers 1\n</code></pre> <ul> <li>Built the docker locally <pre><code>git clone https://github.com/developmentseed/titiler.git\ncd titiler\n\ndocker compose up --build titiler\n</code></pre></li> </ul>"},{"location":"#project-structure","title":"Project structure","text":"<pre><code>src/titiler/                     - titiler modules.\n \u251c\u2500\u2500 application/                - Titiler's `Application` package\n \u251c\u2500\u2500 extensions/                 - Titiler's `Extensions` package\n \u251c\u2500\u2500 xarray/                     - Titiler's `Xarray` package\n \u251c\u2500\u2500 core/                       - Titiler's `Core` package\n \u2514\u2500\u2500 mosaic/                     - Titiler's `Mosaic` package\n</code></pre>"},{"location":"#contribution-development","title":"Contribution &amp; Development","text":"<p>See CONTRIBUTING.md</p>"},{"location":"#license","title":"License","text":"<p>See LICENSE</p>"},{"location":"#authors","title":"Authors","text":"<p>Created by Development Seed</p> <p>See contributors for a listing of individual contributors.</p>"},{"location":"#changes","title":"Changes","text":"<p>See CHANGES.md.</p>"},{"location":"contributing/","title":"Development - Contributing","text":"<p>Issues and pull requests are more than welcome: github.com/developmentseed/titiler/issues</p> <p>We recommand using <code>uv</code> as project manager for development.</p> <p>See docs.astral.sh/uv/getting-started/installation/ for installation </p> <p>dev install</p> <pre><code>git clone https://github.com/developmentseed/titiler.git\ncd titiler\nuv sync --dev\n</code></pre> <p>pre-commit</p> <p>This repo is set to use <code>pre-commit</code> to run isort, flake8, pydocstring, black (\"uncompromising Python code formatter\") and mypy when committing new code.</p> <pre><code>uv run pre-commit install\n\n# If needed, you can run pre-commit script manually \nuv run pre-commit run --all-files \n</code></pre>"},{"location":"contributing/#run-tests","title":"Run tests","text":"<p>Each <code>titiler</code>'s modules has its own test suite which can be ran independently</p> <pre><code># titiler.core\nuv run pytest src/titiler/core --cov=titiler.core --cov-report=xml --cov-append --cov-report=term-missing\n\n# titiler.extensions\nuv run pytest src/titiler/extensions --cov=titiler.extensions --cov-report=xml --cov-append --cov-report=term-missing\n\n# titiler.mosaic\nuv run pytest src/titiler/mosaic --cov=titiler.mosaic --cov-report=xml --cov-append --cov-report=term-missing\n\n# titiler.application\nuv run pytest src/titiler/application --cov=titiler.application --cov-report=xml --cov-append --cov-report=term-missing\n</code></pre>"},{"location":"contributing/#docs","title":"Docs","text":"<pre><code>git clone https://github.com/developmentseed/titiler.git\ncd titiler\n\n# Build docs\nuv run --group docs mkdocs build -f docs/mkdocs.yml\n</code></pre> <p>Hot-reloading docs:</p> <pre><code>uv run --group docs mkdocs serve -f docs/mkdocs.yml --livereload\n</code></pre> <p>To manually deploy docs (note you should never need to do this because Github Actions deploys automatically for new commits.):</p> <pre><code>uv run --group docs mkdocs gh-deploy -f docs/mkdocs.yml\n</code></pre>"},{"location":"external_links/","title":"External links","text":"<p>Tip</p> <p>If you have an article, project, tool, or anything related to TiTiler that is not yet listed here, create a Pull Request adding it.</p>"},{"location":"external_links/#mentions","title":"Mentions","text":"<ul> <li> <p>Sparkgeo's Terradactile</p> </li> <li> <p>Chris Holmes Cloud Native Geospatial Sprint Awards &amp; Bounties</p> </li> <li> <p>Tobin Bradley awesome video about COGs Youtube</p> </li> <li> <p>David McCracken's Blog on Plotly Dash Interactive Mapping - Dash Leaflet &amp; TiTiler</p> </li> </ul>"},{"location":"external_links/#titiler-extensionsplugins","title":"TiTiler extensions/plugins","text":"<ul> <li> <p>stac-utils/titiler-pgstac: TiTiler extension which connects to a PgSTAC database to create dynamic mosaics based on search queries.</p> </li> <li> <p>developmentseed/titiler-xarray: TiTiler extension for xarray</p> </li> <li> <p>developmentseed/titiler-image: TiTiler demo application for Sentinel-2 Digital Twin dataset</p> </li> </ul>"},{"location":"external_links/#projects-demo-using-titiler","title":"Projects / Demo using TiTiler","text":"<ul> <li> <p>ESA Charter Mapper geobrowser</p> </li> <li> <p>developmentseed/titiler-digitaltwin: TiTiler demo application for Sentinel-2 Digital Twin dataset</p> </li> <li> <p>developmentseed/titiler-mvt: TiTiler demo application to create Mapbox Vector Tiles from COG</p> </li> <li> <p>developmentseed/titiler-pds: TiTiler demo application for Sentinel-2 and Landsat-8 AWS Public Datasets</p> </li> <li> <p>stac-utils/stac-fastapi: STAC API implementation with FastAPI.</p> </li> <li> <p>c-core-labs/stac-api: STAC compliant API implementation (built from stac-fastapi)</p> </li> <li> <p>developmentseed/titiler-lambda-layer: TiTiler Lambda layers for easy deployment on AWS</p> </li> <li> <p>Terradue/Stars: Spatio Temporal Asset Runtime Services</p> </li> <li> <p>developmentseed/rio-viz: Visualize Cloud Optimized GeoTIFF in browser</p> </li> <li> <p>developmentseed/pearl-backend: PEARL (Planetary Computer Land Cover Mapping) Platform API and Infrastructure</p> </li> <li> <p>microsoft/planetary-computer-apis: Microsoft Planetary Computer APIs</p> </li> </ul>"},{"location":"external_links/#conferences-presentations-videos","title":"Conferences / presentations / videos","text":"<ul> <li>FOSS4G 2022 TiTiler_not_just_a_tile_server.pdf</li> <li>Cloud Native Outreach 2022 Youtube + TiTiler.pdf</li> <li>Jeff Albrecht and Vincent Sarago talk about COG's and STAC with Titiler &amp; Arturo-STAC-API Youtube</li> </ul>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#unreleased","title":"Unreleased","text":""},{"location":"release-notes/#titilerxarray","title":"titiler.xarray","text":"<ul> <li>add <code>opener_options</code> arg to <code>titiler.xarray.io.Reader</code> to allow users to pass args through to a custom opener function ([#1248(developmentseed/titiler!1248)])</li> </ul>"},{"location":"release-notes/#misc","title":"Misc","text":"<ul> <li>update docker image to python:3.13</li> <li>switch to <code>uv</code> for development</li> <li>switch to <code>hatch</code> for python package build-system</li> <li>remove <code>titiler</code> metapackage breaking change</li> </ul>"},{"location":"release-notes/#0242-2025-10-16","title":"0.24.2 (2025-10-16)","text":""},{"location":"release-notes/#titilercore","title":"titiler.core","text":"<ul> <li>update <code>TileJSON</code> spec from 2.2.0 to 3.0.0</li> <li>fix OpenAPI spec for <code>histogram_range</code> examples (@guillemc23, developmentseed/titiler!1239)</li> </ul>"},{"location":"release-notes/#0241-2025-10-10","title":"0.24.1 (2025-10-10)","text":"<ul> <li>add <code>grayscale</code> and <code>bitonal</code> algorithms</li> <li>add <code>transform</code> and <code>crs</code> for <code>tiff</code> outputs</li> </ul>"},{"location":"release-notes/#0240-2025-09-23","title":"0.24.0 (2025-09-23)","text":""},{"location":"release-notes/#misc_1","title":"Misc","text":"<ul> <li>add attribution in <code>/tilejson.json</code> response. Controled with <code>TITILER_DEFAULT_ATTRIBUTION</code> environment variable.</li> <li>enable <code>jinja2.autoescape</code> for HTML/XML templates (ref: jinja.palletsprojects.com/en/stable/api/#autoescaping)</li> <li>remove python 3.9 support</li> </ul>"},{"location":"release-notes/#titilerextension","title":"titiler.extension","text":"<ul> <li>update rio-stac requirement</li> </ul>"},{"location":"release-notes/#titilerapplication","title":"titiler.application","text":"<ul> <li>add <code>description</code> in <code>ApiSettings</code></li> </ul>"},{"location":"release-notes/#titilercore_1","title":"titiler.core","text":"<ul> <li>delete <code>titiler.core.templating</code> submodule breaking change</li> <li>move <code>create_html_response</code> function to <code>titiler.core.utils</code> submodule</li> <li>move all HTML templates in <code>titiler/core/templates</code> directory  breaking change</li> <li>add HTML responses for tilesets, tilematrixsets, algorithms and colormaps endpoints</li> <li>rename response model <code>ColorMapsList</code> -&gt; <code>ColorMapList</code> and change it's attibutes to <code>colormaps</code> breaking change</li> <li>add <code>templates</code> in the <code>BaseFactory</code> class definition</li> </ul>"},{"location":"release-notes/#0231-2025-08-27","title":"0.23.1 (2025-08-27)","text":""},{"location":"release-notes/#titilercore_2","title":"titiler.core","text":"<ul> <li>add <code>sum</code> algorithm</li> </ul>"},{"location":"release-notes/#0230-2025-08-26","title":"0.23.0 (2025-08-26)","text":""},{"location":"release-notes/#titilercore_3","title":"titiler.core","text":"<ul> <li>add OpenTelemetry instrumentation to the tiler factory classes</li> <li>add <code>OGC Maps API</code> support (<code>/map</code> endpoint)</li> </ul>"},{"location":"release-notes/#titilerapplication_1","title":"titiler.application","text":"<ul> <li>add OpenTelemetry tracing to the FastAPI application</li> <li>update <code>starlette-cramjam</code> requirement to <code>&gt;=0.4,&lt;0.6</code></li> </ul>"},{"location":"release-notes/#titilerxarray_1","title":"titiler.xarray","text":"<ul> <li>add <code>add_preview</code> in factory attribute (default to <code>False</code>)</li> </ul>"},{"location":"release-notes/#misc_2","title":"Misc","text":"<ul> <li>Add otel-collector and jaeger to the docker network</li> <li>fix layer's bounds for non-wgs84 CRS in WMTS document</li> <li>switch from bitnami to official python:3.12 docker image</li> </ul>"},{"location":"release-notes/#0224-2025-07-02","title":"0.22.4 (2025-07-02)","text":"<ul> <li>fix <code>rel</code> values for tiling scheme link (OGC Tiles specification)</li> </ul>"},{"location":"release-notes/#0223-2025-06-17","title":"0.22.3 (2025-06-17)","text":""},{"location":"release-notes/#titilerxarray_2","title":"titiler.xarray","text":"<ul> <li>use dimension's <code>dtype</code> to cast user selection</li> </ul>"},{"location":"release-notes/#0222-2025-06-02","title":"0.22.2 (2025-06-02)","text":""},{"location":"release-notes/#titilerapplication_2","title":"titiler.application","text":"<ul> <li>remove unused templates</li> </ul>"},{"location":"release-notes/#titilerxarray_3","title":"titiler.xarray","text":"<ul> <li>fix <code>xarray_open_dataset</code> for cloud hosted files</li> </ul>"},{"location":"release-notes/#0221-2025-05-13","title":"0.22.1 (2025-05-13)","text":""},{"location":"release-notes/#titilerxarray_4","title":"titiler.xarray","text":"<ul> <li>update <code>reader</code> and <code>path_dependency</code> type informations</li> </ul>"},{"location":"release-notes/#0220-2025-05-06","title":"0.22.0 (2025-05-06)","text":""},{"location":"release-notes/#misc_3","title":"Misc","text":"<ul> <li>rename <code>/map</code> endpoint to <code>/map.html</code> breaking change</li> <li>add <code>name</code> attribute to <code>BaseFactory</code> to define endpoint's <code>operationId</code></li> <li>add <code>operationId</code> on all endpoints</li> <li>add <code>/preview/{width}x{height}.{format}</code> endpoints</li> <li>update rio-tiler requirement to <code>&gt;=7.7,&lt;8.0</code></li> <li>allow users to pass only one of <code>width</code> or <code>heigh</code> size parameters for <code>preview</code>, <code>part</code> and <code>feature</code> requests</li> <li>use <code>minZoom</code> instead of <code>minNativeZoom</code> in the <code>/map.html</code> html template</li> <li>update geojson-pydantic requirement to <code>&gt;=1.1.2,&lt;3.0</code> and change featureCollection iteration</li> </ul>"},{"location":"release-notes/#titilerapplication_3","title":"titiler.application","text":"<ul> <li>fix Landing page links when app is behind proxy</li> <li>use <code>titiler.core</code> templates for Landing page</li> <li>enable JSON and HTML rendering of the <code>/</code> landing page</li> <li>add OGC Common <code>/conformance</code> endpoint</li> </ul>"},{"location":"release-notes/#titilercore_4","title":"titiler.core","text":"<ul> <li> <p>add <code>conforms_to</code> attribute to <code>BaseFactory</code> to indicate which conformance the TileFactory implement</p> </li> <li> <p>remove deprecated <code>ColorFormulaParams</code> and <code>RescalingParams</code> dependencies breaking change</p> </li> <li> <p>remove deprecated <code>DefaultDependency</code> dict-unpacking feature breaking change</p> </li> <li> <p>add <code>min</code>, <code>max</code>, <code>mean</code>, <code>median</code>, <code>std</code> and <code>var</code> algorithms</p> </li> <li> <p>Fix TerrainRGB algorithm and param user-controlled nodata-height (@jo-chemla, developmentseed/titiler!1116)</p> </li> <li> <p>add <code>output_min</code> and <code>output_max</code> metadata attributes to <code>slope</code> algorithm (@tayden, developmentseed/titiler!1089)</p> </li> <li> <p>add point value query on right-click to map viewer (@hrodmn, developmentseed/titiler!1100)</p> </li> <li> <p>refactor middlewares to use python's dataclasses</p> </li> <li> <p>update <code>LoggerMiddleware</code> output format and options breaking change</p> <pre><code>from fastapi import FastAPI\n\nfrom titiler.core.middlewares import LoggerMiddleware\n\n# before\napp = FastAPI()\napp.add_middlewares(LoggerMiddleware, querystrings=True, headers=True)\n\n# now\napp = FastAPI()\napp.add_middlewares(\n    LoggerMiddleware,\n    # custom Logger\n    logger=logging.getLogger(\"mytiler.requests\"),  # default to logging.getLogger(\"titiler.requests\")\n)\n</code></pre> <p>Note: logger needs then to be <code>configured</code> at runtime. e.g :</p> <pre><code>from logging import config\nconfig.dictConfig(\n    {\n        \"version\": 1,\n        \"disable_existing_loggers\": False,\n        \"formatters\": {\n            \"detailed\": {\n                \"format\": \"%(asctime)s - %(levelname)s - %(name)s - %(message)s\"\n            },\n            \"request\": {\n                \"format\": (\n                    \"%(asctime)s - %(levelname)s - %(name)s - %(message)s \"\n                    + json.dumps(\n                        {\n                            k: f\"%({k})s\"\n                            for k in [\n                                \"method\",\n                                \"referer\",\n                                \"origin\",\n                                \"route\",\n                                \"path\",\n                                \"path_params\",\n                                \"query_params\",\n                                \"headers\",\n                            ]\n                        }\n                    )\n                ),\n            },\n        },\n        \"handlers\": {\n            \"console_request\": {\n                \"class\": \"logging.StreamHandler\",\n                \"level\": \"DEBUG\",\n                \"formatter\": \"request\",\n                \"stream\": \"ext://sys.stdout\",\n            },\n        },\n        \"loggers\": {\n            \"mytiler.requests\": {\n                \"level\": \"INFO\",\n                \"handlers\": [\"console_request\"],\n                \"propagate\": False,\n            },\n        },\n    }\n)\n</code></pre> </li> </ul>"},{"location":"release-notes/#titilerextensions","title":"titiler.extensions","text":"<ul> <li>update <code>wms</code> extension to remove usage of <code>ColorFormulaParams</code> and <code>RescalingParams</code> dependencies</li> <li>update <code>render</code> extension to better validate query-parameters from render expression</li> </ul>"},{"location":"release-notes/#titilerxarray_5","title":"titiler.xarray","text":"<ul> <li>update <code>rio-tiler</code> requirement to <code>&gt;=7.6.1</code></li> <li> <p>add <code>sel</code> and <code>sel_method</code> options to select dimension</p> <p><pre><code># before\nhttps://.../0/0/0.png?url=dataset.zarr&amp;drop_dim=time=2023-01-01\n\n# now\nhttps://.../0/0/0.png?url=dataset.zarr&amp;sel=time=2023-01-01\n\n# method\nhttps://.../0/0/0.png?url=dataset.zarr&amp;sel=time=2023-01-02&amp;sel_method=nearest\n\n# Can use `slice` when providing 2 values\nhttps://.../0/0/0.png?url=dataset.zarr&amp;sel=time=2023-01-01&amp;time=2023-01-31\n</code></pre> * add support for <code>bidx</code> parameter * remove <code>first</code> time dim selection breaking change * add support for 3D dataset * remove <code>drop_dim</code> option breaking change * remove <code>datetime</code> option breaking change * deprecate <code>VariablesExtension</code> extension * add <code>DatasetMetadataExtension</code> extension (<code>/dataset/keys</code>, <code>/dataset/</code> and <code>/dataset/dict</code> endpoints)</p> </li> </ul>"},{"location":"release-notes/#titilermosaic","title":"titiler.mosaic","text":"<ul> <li>add <code>/bbox</code> prefix to <code>/{minx},{miny},{maxx},{maxy}/assets</code> endpoint -&gt; <code>/bbox/{minx},{miny},{maxx},{maxy}/assets</code> breaking change</li> <li>add <code>/point</code> prefix to <code>{lon},{lat}/assets</code> endpoint -&gt; <code>/point/{lon},{lat}/assets</code> breaking change</li> <li>add <code>/tiles</code> prefix to <code>/{tileMatrixSetId}/{z}/{x}/{y}/assets</code> endpoint -&gt; <code>/tiles/{tileMatrixSetId}/{z}/{x}/{y}/assets</code> breaking change</li> <li>add <code>assets_accessor_dependency</code> dependency to the MosaicTileFactory to pass options to the backend's <code>get_assets</code> method.</li> </ul>"},{"location":"release-notes/#0211-2025-01-29","title":"0.21.1 (2025-01-29)","text":""},{"location":"release-notes/#titilercore_5","title":"titiler.core","text":"<ul> <li>add <code>slope</code> algorithm (@tayden, developmentseed/titiler!1088)</li> </ul>"},{"location":"release-notes/#titilerxarray_6","title":"titiler.xarray","text":"<ul> <li>Support Zarr-Python &gt;=3 (author @maxrjones, developmentseed/titiler!1082)</li> </ul>"},{"location":"release-notes/#0210-2025-01-24","title":"0.21.0 (2025-01-24)","text":""},{"location":"release-notes/#misc_4","title":"Misc","text":"<ul> <li> <p>use <code>URN</code> style CRS notation in WMTS document</p> </li> <li> <p>Unify Docker images (deprecate <code>titiler-uvicorn</code>)</p> <pre><code># Uvicorn\n# before\ndocker run \\\n    --platform=linux/amd64 \\\n    -p 8000:8000 \\\n    --env PORT=8000 \\\n    --rm -it ghcr.io/developmentseed/titiler-uvicorn:latest\n\n# now\ndocker run \\\n    --platform=linux/amd64 \\\n    -p 8000:8000 \\\n    --rm -it ghcr.io/developmentseed/titiler:latest \\\n    uvicorn titiler.application.main:app --host 0.0.0.0 --port 8000 --workers 1\n\n# Gunicorn\n# before\ndocker run \\\n    --platform=linux/amd64 \\\n    -p 8000:8000 \\\n    --env PORT=8000 \\\n    --rm -it ghcr.io/developmentseed/titiler:latest\n\n# now\ndocker run \\\n    --platform=linux/amd64 \\\n    -p 8000:8000 \\\n    --rm -it ghcr.io/developmentseed/titiler:latest \\\n    gunicorn -k uvicorn.workers.UvicornWorker titiler.application.main:app --bind 0.0.0.0:8000 --workers 1\n</code></pre> </li> </ul>"},{"location":"release-notes/#0201-2025-01-09","title":"0.20.1 (2025-01-09)","text":""},{"location":"release-notes/#titilerxarray_7","title":"titiler.xarray","text":"<ul> <li>pin python <code>zarr</code> to <code>&gt;2,&lt;3.0</code> to avoid zarr 3.0 breaking changes</li> </ul>"},{"location":"release-notes/#0200-2025-01-07","title":"0.20.0 (2025-01-07)","text":""},{"location":"release-notes/#titilercore_6","title":"titiler.core","text":"<ul> <li>add layer control to map viewer template (author @hrodmn, developmentseed/titiler!1051)</li> <li>improve query string handling in LowerCaseQueryStringMiddleware using urlencode (author @pratapvardhan, developmentseed/titiler!1050)</li> <li>add <code>titiler.core.utils.bounds_to_geometry</code> and reduce code duplication in factories (author @PratapVardhan, developmentseed/titiler!1047)</li> <li>simplify image format dtype validation in <code>render_image</code> (author @PratapVardhan, developmentseed/titiler!1046)</li> <li>remove <code>rescale_dependency</code> and <code>color_formula_dependency</code> attributes in <code>TilerFactory</code> class  breaking change</li> <li>move <code>rescale</code> and <code>color_formula</code> QueryParameters dependencies in <code>ImageRenderingParams</code> class  breaking change</li> <li>handle image rescaling and color_formula within <code>titiler.core.utils.render_image</code> function  breaking change</li> <li>add <code>render_func: Callable[..., Tuple[bytes, str]] = render_image</code> attribute in <code>TilerFactory</code> class</li> <li>add <code>castToInt</code>, <code>Floor</code>, <code>Ceil</code> algorithms</li> </ul>"},{"location":"release-notes/#titilerapplication_4","title":"titiler.application","text":"<ul> <li>update <code>/healthz</code> endpoint to return dependencies versions (titiler, rasterio, gdal, ...) (author @scottyhq, developmentseed/titiler!1056)</li> <li>migrate <code>templates/index.html</code> to bootstrap5, remove unused css, reuse bs classes (author @PratapVardhan, developmentseed/titiler!1048)</li> </ul>"},{"location":"release-notes/#titilermosaic_1","title":"titiler.mosaic","text":"<ul> <li>remove <code>rescale_dependency</code> and <code>color_formula_dependency</code> attributes in <code>MosaicTilerFactory</code> class  breaking change</li> <li>add <code>render_func: Callable[..., Tuple[bytes, str]] = render_image</code> attribute in <code>MosaicTilerFactory</code> class  breaking change</li> </ul>"},{"location":"release-notes/#titilerextensions_1","title":"titiler.extensions","text":"<ul> <li>use <code>factory.render_func</code> as render function in <code>wmsExtension</code> endpoints</li> <li>add <code>stacRenderExtension</code> which adds two endpoints: <code>/renders</code> (lists all renders) and <code>/renders/&lt;render_id&gt;</code> (render metadata and links) (author @alekzvik, developmentseed/titiler!1038)</li> </ul>"},{"location":"release-notes/#misc_5","title":"Misc","text":"<ul> <li>Updated WMTS Capabilities template to avoid inserting extra new lines (author @AndrewAnnex, developmentseed/titiler!1052).</li> <li>Updated WMTS endpoint in titiler.mosaic and titiler.core to return layer bounds in coordinate ordering matching CRS order if WGS84 is not used (author @AndrewAnnex, developmentseed/titiler!1052).</li> <li>Remove <code>python3.8</code> support (author @pratapvardhan, developmentseed/titiler!1058)</li> <li>Add <code>python3.13</code> support (author @pratapvardhan, developmentseed/titiler!1058)</li> </ul>"},{"location":"release-notes/#0193-2025-01-09","title":"0.19.3 (2025-01-09)","text":""},{"location":"release-notes/#titilerxarray_8","title":"titiler.xarray","text":"<ul> <li>pin python zarr to &gt;2,&lt;3.0 to avoid zarr 3.0 breaking changes [Backported from 0.20.1]</li> </ul>"},{"location":"release-notes/#0192-2024-11-28","title":"0.19.2 (2024-11-28)","text":""},{"location":"release-notes/#misc_6","title":"Misc","text":"<ul> <li> <p>drop python 3.8 and add python 3.13 support (author @pratapvardhan, developmentseed/titiler!1058)</p> </li> <li> <p>Update package build backend from <code>pdm-pep517</code> to <code>pdm-backend</code> (backend.pdm-project.org/#migrate-from-pdm-pep517)</p> </li> <li> <p>Update namespace package from using <code>.</code> to <code>-</code> as separator to comply with PEP-625 (peps.python.org/pep-0625/)</p> </li> </ul>"},{"location":"release-notes/#titilermosaic_2","title":"titiler.mosaic","text":"<ul> <li>Define variable (<code>MOSAIC_CONCURRENCY</code> and <code>MOSAIC_STRICT_ZOOM</code>) from env-variable outside endpoint code</li> </ul>"},{"location":"release-notes/#0191-2024-11-14","title":"0.19.1 (2024-11-14)","text":"<ul> <li>Add <code>titiler</code> links in Map attributions</li> </ul>"},{"location":"release-notes/#0190-2024-11-07","title":"0.19.0 (2024-11-07)","text":""},{"location":"release-notes/#misc_7","title":"Misc","text":"<ul> <li> <p>Remove default <code>WebMercatorQuad</code> tile matrix set in <code>/tiles</code>, <code>/tilesjson.json</code>, <code>/map</code> and <code>/WMTSCapabilities.xml</code> endpoints breaking change</p> <pre><code># Before\n/tiles/{z}/{x}/{y}\n/tilejson.json\n/map\n/WMTSCapabilities.xml\n\n# Now\n/tiles/WebMercatorQuad/{z}/{x}/{y}\n/WebMercatorQuad/tilejson.json\n/WebMercatorQuad/map\n/WebMercatorQuad/WMTSCapabilities.xml\n</code></pre> </li> <li> <p>Use <code>@attrs.define</code> instead of dataclass for factories breaking change</p> </li> <li>Use <code>@attrs.define</code> instead of dataclass for factory extensions breaking change</li> <li>Handle <code>numpy</code> types in JSON/GeoJSON response</li> <li>In the <code>map.html</code> template, use the tilejson's <code>minzoom</code> and <code>maxzoom</code> to populate <code>minNativeZoom</code> and <code>maxNativeZoom</code> parameters in leaflet <code>tileLayer</code> instead of <code>minZoom</code> and <code>maxZoom</code></li> </ul>"},{"location":"release-notes/#titilercore_7","title":"titiler.core","text":"<ul> <li> <p>Update <code>rio-tiler</code> dependency to <code>&gt;=7.0,&lt;8.0</code></p> </li> <li> <p>Update <code>geojson-pydantic</code> dependency to <code>&gt;=1.1.2,&lt;2.0</code> which better handle antimeridian crossing dataset</p> </li> <li> <p>handle <code>antimeridian</code> crossing bounds in <code>/info.geojson</code> endpoints (returning MultiPolygon instead of Polygon)</p> </li> <li> <p>Improve XSS security for HTML templates (author @jcary741, developmentseed/titiler!953)</p> </li> <li> <p>Remove all default values to the dependencies breaking change</p> <ul> <li><code>DatasetParams.unscale</code>: <code>False</code> -&gt; <code>None</code> (default to <code>False</code> in rio-tiler)</li> <li><code>DatasetParams.resampling_method</code>: <code>nearest</code> -&gt; <code>None</code> (default to <code>nearest</code> in rio-tiler)</li> <li><code>DatasetParams.reproject_method</code>: <code>nearest</code> -&gt; <code>None</code> (default to <code>nearest</code> in rio-tiler)</li> <li><code>ImageRenderingParams.add_mask</code>: <code>True</code> -&gt; <code>None</code> (default to <code>True</code> in rio-tiler)</li> <li><code>StatisticsParams.categorical</code>: <code>False</code> -&gt; <code>None</code> (default to <code>False</code> in rio-tiler)</li> </ul> </li> <li> <p>Add <code>as_dict(exclude_none=True/False)</code> method to the <code>DefaultDependency</code> class.</p> <pre><code>from typing import Optional\nfrom titiler.core.dependencies import DefaultDependency\nfrom dataclasses import dataclass\n\n@dataclass\nclass Deps(DefaultDependency):\n    value: Optional[int] = None\n\nprint({**Deps().__dict__.items()})\n&gt;&gt; {'value': None}\n\nDeps().as_dict()  # `exclude_none` defaults to True\n&gt;&gt; {}\n\nDeps(value=1).as_dict()\n&gt;&gt; {'value': 1}\n</code></pre> </li> <li> <p>Fix Hillshade algorithm (bad <code>azimuth</code> angle)</p> </li> <li> <p>Set default <code>azimuth</code> and <code>altitude</code> angles to 45\u00ba for the Hillshade algorithm breaking change</p> </li> <li> <p>Use <code>.as_dict()</code> method when passing option to rio-tiler Reader's methods to avoid parameter conflicts when using custom Readers.</p> </li> <li> <p>Rename <code>BaseTilerFactory</code> to <code>BaseFactory</code> breaking change</p> </li> <li> <p>Remove useless attribute in <code>BaseFactory</code> (and moved them to <code>TilerFactory</code>) breaking change</p> </li> <li> <p>Add <code>crs</code> option to <code>/bounds</code> endpoints to enable geographic_crs selection by the user</p> </li> <li> <p><code>/bounds</code> endpoints now return a <code>crs: str</code> attribute in the response</p> </li> <li> <p>update <code>wmts.xml</code> template to support multiple layers</p> </li> <li> <p>re-order endpoints parameters</p> </li> <li> <p>avoid <code>lat/lon</code> overflow in <code>map</code> viewer</p> </li> <li> <p>add OGC Tiles <code>/tiles</code> and <code>/tiles/{tileMatrixSet}</code> endpoints</p> </li> <li> <p>add <code>gif</code> media type</p> </li> <li> <p><code>/point</code> endpoint returned masked values (<code>None</code> is nodata)</p> </li> </ul>"},{"location":"release-notes/#titilermosaic_3","title":"titiler.mosaic","text":"<ul> <li> <p>Rename <code>reader</code> attribute to <code>backend</code> in <code>MosaicTilerFactory</code> breaking change</p> </li> <li> <p>Add <code>crs</code> option to <code>/bounds</code> endpoints to enable geographic_crs selection by the user</p> </li> <li> <p><code>/bounds</code> endpoints now return a <code>crs: str</code> attribute in the response</p> </li> <li> <p>Update <code>cogeo-mosaic</code> dependency to <code>&gt;=8.0,&lt;9.0</code></p> </li> <li> <p>re-order endpoints parameters</p> </li> <li> <p>add OGC Tiles <code>/tiles</code> and <code>/tiles/{tileMatrixSet}</code> endpoints</p> </li> <li> <p><code>/point</code> endpoint returned masked values (<code>None</code> is nodata)</p> </li> </ul>"},{"location":"release-notes/#titilerextensions_2","title":"titiler.extensions","text":"<ul> <li> <p>Encode URL for cog_viewer and stac_viewer (author @guillemc23, developmentseed/titiler!961)</p> </li> <li> <p>Add links for render parameters and <code>/map</code> link to viewer dashboard (author @hrodmn, developmentseed/titiler!987)</p> </li> <li> <p>Update viewers to use <code>/info.geojson</code> endpoint instead of <code>/info</code></p> </li> </ul>"},{"location":"release-notes/#01810-2024-10-17","title":"0.18.10 (2024-10-17)","text":""},{"location":"release-notes/#titilerapplication_5","title":"titiler.application","text":"<ul> <li>update <code>starlette-cramjam</code> dependency and set compression-level default to <code>6</code></li> </ul>"},{"location":"release-notes/#0189-2024-09-23","title":"0.18.9 (2024-09-23)","text":"<ul> <li>fix release 0.18.8</li> </ul>"},{"location":"release-notes/#0188-2024-09-23","title":"0.18.8 (2024-09-23)","text":""},{"location":"release-notes/#titilerextensions_3","title":"titiler.extensions","text":"<ul> <li>Add links for render parameters and /map link to viewer dashboard (author @hrodmn, developmentseed/titiler!987)</li> </ul>"},{"location":"release-notes/#0187-2024-09-19","title":"0.18.7 (2024-09-19)","text":"<ul> <li>fix Hillshade algorithm (bad <code>azimuth</code> angle) (developmentseed/titiler!985) [Backported]</li> <li>Encode URL for cog_viewer and stac_viewer (author @guillemc23, developmentseed/titiler!961) [Backported]</li> <li>Improve XSS security for HTML templates (author @jcary741, developmentseed/titiler!953) [Backported]</li> </ul>"},{"location":"release-notes/#0186-2024-08-27","title":"0.18.6 (2024-08-27)","text":"<ul> <li>Switch back to <code>fastapi</code> instead of <code>fastapi-slim</code> and use <code>&gt;=0.109.0</code> version</li> </ul>"},{"location":"release-notes/#0185-2024-07-03","title":"0.18.5 (2024-07-03)","text":"<ul> <li>Set version requirement for FastAPI to <code>&gt;=0.111.0</code></li> </ul>"},{"location":"release-notes/#0184-2024-06-26","title":"0.18.4 (2024-06-26)","text":"<ul> <li>fix Tiles URL encoding for WMTSCapabilities XML document</li> </ul>"},{"location":"release-notes/#0183-2024-05-20","title":"0.18.3 (2024-05-20)","text":"<ul> <li>fix <code>WMTSCapabilities.xml</code> response for ArcMap compatibility<ul> <li>replace <code>Cloud Optimized GeoTIFF</code> with dataset URL or <code>TiTiler</code> for the ows:ServiceIdentification title</li> <li>replace <code>cogeo</code> with <code>Dataset</code> for the <code>layer</code> ows:Identifier</li> </ul> </li> </ul>"},{"location":"release-notes/#0182-2024-05-07","title":"0.18.2 (2024-05-07)","text":"<ul> <li>move to <code>fastapi-slim</code> to avoid unwanted dependencies (author @n8sty, developmentseed/titiler!815)</li> </ul>"},{"location":"release-notes/#0181-2024-04-12","title":"0.18.1 (2024-04-12)","text":""},{"location":"release-notes/#titilercore_8","title":"titiler.core","text":"<ul> <li>fix <code>TerrainRGB</code> algorithm name (author @JinIgarashi, developmentseed/titiler!804)</li> <li>add more tests for <code>RescalingParams</code> and <code>HistogramParams</code> dependencies</li> <li>make sure to return empty content for <code>204</code> Error code</li> </ul>"},{"location":"release-notes/#0180-2024-03-22","title":"0.18.0 (2024-03-22)","text":""},{"location":"release-notes/#titilercore_9","title":"titiler.core","text":"<ul> <li>Add <code>ColorMapFactory</code> to create colorMap metadata endpoints (developmentseed/titiler!796)</li> <li> <p>Deprecation remove default <code>WebMercatorQuad</code> tile matrix set in <code>/tiles</code>, <code>/tilesjson.json</code>, <code>/map</code> and <code>/WMTSCapabilities.xml</code> endpoints (developmentseed/titiler!802)</p> <pre><code># Before\n/tiles/{z}/{x}/{y}\n/tilejson.json\n/map\n/WMTSCapabilities.xml\n\n# Now\n/tiles/WebMercatorQuad/{z}/{x}/{y}\n/WebMercatorQuad/tilejson.json\n/WebMercatorQuad/map\n/WebMercatorQuad/WMTSCapabilities.xml\n</code></pre> </li> <li> <p>Deprecation <code>default_tms</code> attribute in <code>BaseTilerFactory</code> (because <code>tileMatrixSetId</code> is now required in endpoints).</p> </li> </ul>"},{"location":"release-notes/#titilermosaic_4","title":"titiler.mosaic","text":"<ul> <li> <p>Deprecation remove default <code>WebMercatorQuad</code> tile matrix set in <code>/tiles</code>, <code>/tilesjson.json</code>, <code>/map</code> and <code>/WMTSCapabilities.xml</code> endpoints (developmentseed/titiler!802)</p> <pre><code># Before\n/tiles/{z}/{x}/{y}\n/tilejson.json\n/map\n/WMTSCapabilities.xml\n\n# Now\n/tiles/WebMercatorQuad/{z}/{x}/{y}\n/WebMercatorQuad/tilejson.json\n/WebMercatorQuad/map\n/WebMercatorQuad/WMTSCapabilities.xml\n</code></pre> </li> <li> <p>Deprecation <code>default_tms</code> attribute in <code>MosaicTilerFactory</code> (because <code>tileMatrixSetId</code> is now required in endpoints).</p> </li> </ul>"},{"location":"release-notes/#misc_8","title":"Misc","text":"<ul> <li>add <code>request</code> as first argument in <code>TemplateResponse</code> to adapt with latest starlette version</li> </ul>"},{"location":"release-notes/#0173-2024-03-21","title":"0.17.3 (2024-03-21)","text":""},{"location":"release-notes/#titilerapplication_6","title":"titiler.application","text":"<ul> <li>Add <code>extra=\"ignore\"</code> option <code>ApiSettings</code> to fix pydantic issue when using <code>.env</code> file (author @imanshafiei540, developmentseed/titiler!800)</li> </ul>"},{"location":"release-notes/#0172-2024-03-15","title":"0.17.2 (2024-03-15)","text":""},{"location":"release-notes/#titilercore_10","title":"titiler.core","text":"<ul> <li>fix OpenAPI metadata for algorithm (author @JinIgarashi, developmentseed/titiler!797)</li> </ul>"},{"location":"release-notes/#0171-2024-03-13","title":"0.17.1 (2024-03-13)","text":"<ul> <li>add python 3.12 support</li> </ul>"},{"location":"release-notes/#titilercore_11","title":"titiler.core","text":"<ul> <li>Add <code>use_epsg</code> parameter to WMTS endpoint to resolve ArcMAP issues and fix XML formating (author @gadomski, developmentseed/titiler!782)</li> <li>Add more OpenAPI metadata for algorithm (author @JinIgarashi, developmentseed/titiler!783)</li> </ul>"},{"location":"release-notes/#titilerapplication_7","title":"titiler.application","text":"<ul> <li>fix invalid url parsing in HTML responses</li> </ul>"},{"location":"release-notes/#0170-2024-01-17","title":"0.17.0 (2024-01-17)","text":""},{"location":"release-notes/#titilercore_12","title":"titiler.core","text":"<ul> <li>update <code>rio-tiler</code> version to <code>&gt;6.3.0</code></li> <li>use new <code>align_bounds_with_dataset=True</code> rio-tiler option in GeoJSON statistics methods for more precise calculation</li> </ul>"},{"location":"release-notes/#0162-2024-01-17","title":"0.16.2 (2024-01-17)","text":""},{"location":"release-notes/#titilercore_13","title":"titiler.core","text":"<ul> <li>fix leafletjs template maxZoom to great than 18 for <code>/map</code> endpoint (author @Firefishy, developmentseed/titiler!749)</li> </ul>"},{"location":"release-notes/#0161-2024-01-08","title":"0.16.1 (2024-01-08)","text":""},{"location":"release-notes/#titilercore_14","title":"titiler.core","text":"<ul> <li>use morecantile <code>TileMatrixSet.cellSize</code> property instead of deprecated/private <code>TileMatrixSet._resolution</code> method</li> </ul>"},{"location":"release-notes/#titilermosaic_5","title":"titiler.mosaic","text":"<ul> <li>use morecantile <code>TileMatrixSet.cellSize</code> property instead of deprecated/private <code>TileMatrixSet._resolution</code> method</li> </ul>"},{"location":"release-notes/#0160-2024-01-08","title":"0.16.0 (2024-01-08)","text":""},{"location":"release-notes/#titilercore_15","title":"titiler.core","text":"<ul> <li>update FastAPI version lower limit to <code>&gt;=0.107.0</code></li> <li>fix template loading for starlette &gt;= 0.28 by using <code>jinja2.Environment</code> argument (author @jasongi, developmentseed/titiler!744)</li> </ul>"},{"location":"release-notes/#titilerextensions_4","title":"titiler.extensions","text":"<ul> <li>fix template loading for starlette &gt;= 0.28 by using <code>jinja2.Environment</code> argument (author @jasongi, developmentseed/titiler!744)</li> </ul>"},{"location":"release-notes/#titilerapplication_8","title":"titiler.application","text":"<ul> <li>fix template loading for starlette &gt;= 0.28 by using <code>jinja2.Environment</code> argument (author @jasongi, developmentseed/titiler!744)</li> </ul>"},{"location":"release-notes/#0158-2024-01-08","title":"0.15.8 (2024-01-08)","text":""},{"location":"release-notes/#titilercore_16","title":"titiler.core","text":"<ul> <li>use morecantile <code>TileMatrixSet.cellSize</code> property instead of deprecated/private <code>TileMatrixSet._resolution</code> method [backported from 0.16.1]</li> </ul>"},{"location":"release-notes/#titilermosaic_6","title":"titiler.mosaic","text":"<ul> <li>use morecantile <code>TileMatrixSet.cellSize</code> property instead of deprecated/private <code>TileMatrixSet._resolution</code> method [backported from 0.16.1]</li> </ul>"},{"location":"release-notes/#0157-2024-01-08","title":"0.15.7 (2024-01-08)","text":""},{"location":"release-notes/#titilercore_17","title":"titiler.core","text":"<ul> <li>update FastAPI version upper limit to <code>&lt;0.107.0</code> to avoid starlette breaking change (<code>0.28</code>)</li> </ul>"},{"location":"release-notes/#titilerapplication_9","title":"titiler.application","text":"<ul> <li>add simple auth (optional) based on <code>global_access_token</code> string, set with <code>TITILER_API_GLOBAL_ACCESS_TOKEN</code> environment variable (author @DeflateAwning, developmentseed/titiler!735)</li> </ul>"},{"location":"release-notes/#0156-2023-11-16","title":"0.15.6 (2023-11-16)","text":""},{"location":"release-notes/#titilercore_18","title":"titiler.core","text":"<ul> <li>in <code>/map</code> HTML response, add Lat/Lon buffer to AOI to avoid creating wrong AOI (when data covers the whole world).</li> </ul>"},{"location":"release-notes/#0155-2023-11-09","title":"0.15.5 (2023-11-09)","text":""},{"location":"release-notes/#titilercore_19","title":"titiler.core","text":"<ul> <li> <p>add <code>algorithm</code> options for <code>/statistics</code> endpoints</p> </li> <li> <p>switch from <code>BaseReader.statistics()</code> method to a combination of <code>BaseReader.preview()</code> and <code>ImageData.statistics()</code> methods to get the statistics</p> </li> </ul>"},{"location":"release-notes/#0154-2023-11-06","title":"0.15.4 (2023-11-06)","text":""},{"location":"release-notes/#titilercore_20","title":"titiler.core","text":"<ul> <li> <p>update <code>rio-tiler</code> requirement to <code>&gt;=6.2.5,&lt;7.0</code></p> </li> <li> <p>allow <code>bidx</code> option in <code>titiler.core.dependencies.AssetsBidxExprParams</code> and <code>titiler.core.dependencies.AssetsBidxParams</code></p> <pre><code># merge band 1 form asset1 and asset2\n# before\nhttpx.get(\n    \"/stac/preview\",\n    params=(\n        (\"url\", \"stac.json\"),\n        (\"assets\", \"asset1\"),\n        (\"assets\", \"asset2\"),\n        (\"asset_bidx\", \"asset1|1\"),\n        (\"asset_bidx\", \"asset2|1\"),\n    )\n)\n\n# now\nhttpx.get(\n    \"/stac/preview\",\n    params=(\n        (\"url\", \"stac.json\"),\n        (\"assets\", \"asset1\"),\n        (\"assets\", \"asset2\"),\n        (\"bidx\", 1),\n    )\n)\n</code></pre> </li> <li> <p>fix openapi examples</p> </li> </ul>"},{"location":"release-notes/#0153-2023-11-02","title":"0.15.3 (2023-11-02)","text":"<ul> <li>add <code>dst_crs</code> options in <code>/statistics [POST]</code> and <code>/feature [POST]</code> endpoints</li> </ul>"},{"location":"release-notes/#0152-2023-10-23","title":"0.15.2 (2023-10-23)","text":""},{"location":"release-notes/#titilercore_21","title":"titiler.core","text":"<ul> <li>add <code>dependencies.TileParams</code> dependency with <code>buffer</code> and <code>padding</code> options</li> <li>add <code>tile_dependency</code> attribute in <code>TilerFactory</code> class (defaults to <code>TileParams</code>)</li> <li>add <code>reproject</code> (alias to <code>reproject_method</code>) option in <code>DatasetParams</code> dependency</li> </ul>"},{"location":"release-notes/#titilermosaic_7","title":"titiler.mosaic","text":"<ul> <li>Change <code>HTTP_404_NOT_FOUND</code> to <code>HTTP_204_NO_CONTENT</code> when no asset is found or tile is empty (author @simouel, developmentseed/titiler!713)</li> <li>add <code>tile_dependency</code> attribute in <code>MosaicTilerFactory</code> class (defaults to <code>TileParams</code>)</li> </ul>"},{"location":"release-notes/#cdk-application","title":"cdk application","text":"<ul> <li>Support non-root paths in AWS API Gateway Lambda handler (author @DanSchoppe, developmentseed/titiler!716)</li> </ul>"},{"location":"release-notes/#0151-2023-10-17","title":"0.15.1 (2023-10-17)","text":"<ul> <li>Allow a default <code>color_formula</code> parameter to be set via a dependency (author @samn, developmentseed/titiler!707)</li> <li>add <code>titiler.core.dependencies.create_colormap_dependency</code> to create ColorMapParams dependency from <code>rio_tiler.colormap.ColorMaps</code> object</li> <li>add <code>py.typed</code> files in titiler submodules (peps.python.org/pep-0561)</li> </ul>"},{"location":"release-notes/#0150-2023-09-28","title":"0.15.0 (2023-09-28)","text":""},{"location":"release-notes/#titilercore_22","title":"titiler.core","text":"<ul> <li>added <code>PartFeatureParams</code> dependency</li> </ul> <p>breaking changes</p> <ul> <li> <p><code>max_size</code> is now set to <code>None</code> for <code>/statistics [POST]</code>, <code>/bbox</code> and <code>/feature</code> endpoints, meaning the tiler will create image from the highest resolution.</p> </li> <li> <p>renamed <code>titiler.core.dependencies.ImageParams</code> to <code>PreviewParams</code></p> </li> <li> <p>split TileFactory <code>img_dependency</code> attribute in two:</p> </li> <li> <p><code>img_preview_dependency</code>: used in <code>/preview</code> and <code>/statistics [GET]</code>, default to <code>PreviewParams</code> (with <code>max_size=1024</code>)</p> </li> <li> <p><code>img_part_dependency</code>: used in <code>/bbox</code>, <code>/feature</code> and <code>/statistics [POST]</code>, default to <code>PartFeatureParams</code> (with <code>max_size=None</code>)</p> </li> <li> <p>renamed <code>/crop</code> endpoints to <code>/bbox/...</code> or <code>/feature/...</code></p> </li> <li> <p><code>/crop/{minx},{miny},{maxx},{maxy}.{format}</code> -&gt; <code>/bbox/{minx},{miny},{maxx},{maxy}.{format}</code></p> </li> <li> <p><code>/crop/{minx},{miny},{maxx},{maxy}/{width}x{height}.{format}</code> -&gt; <code>/bbox/{minx},{miny},{maxx},{maxy}/{width}x{height}.{format}</code></p> </li> <li> <p><code>/crop [POST]</code> -&gt; <code>/feature [POST]</code></p> </li> <li> <p><code>/crop.{format} [POST]</code> -&gt; <code>/feature.{format} [POST]</code></p> </li> <li> <p><code>/crop/{width}x{height}.{format}  [POST]</code> -&gt; <code>/feature/{width}x{height}.{format} [POST]</code></p> </li> <li> <p>update <code>rio-tiler</code> requirement to <code>&gt;=6.2.1</code></p> </li> <li> <p>Take coverage weights in account when generating statistics from GeoJSON features</p> </li> </ul>"},{"location":"release-notes/#0141-2023-09-14","title":"0.14.1 (2023-09-14)","text":""},{"location":"release-notes/#titilerextension_1","title":"titiler.extension","text":"<ul> <li>add <code>GetFeatureInfo</code> capability in <code>wmsExtension</code> (author @benjaminleighton, developmentseed/titiler!698)</li> </ul>"},{"location":"release-notes/#0140-2023-08-30","title":"0.14.0 (2023-08-30)","text":""},{"location":"release-notes/#titilercore_23","title":"titiler.core","text":"<ul> <li>replace <code>-</code> by <code>_</code> in query parameters breaking change</li> <li><code>coord-crs</code> -&gt; <code>coord_crs</code></li> <li> <p><code>dst-crs</code> -&gt; <code>dst_crs</code></p> </li> <li> <p>replace <code>buffer</code> and <code>color_formula</code> endpoint parameters by external dependencies (<code>BufferParams</code> and <code>ColorFormulaParams</code>)</p> </li> <li> <p>add <code>titiler.core.utils.render_image</code> which allow non-binary alpha band created with custom colormap. <code>render_image</code> replace <code>ImageData.render</code> method.</p> <pre><code># before\nif cmap := colormap or dst_colormap:\n    image = image.apply_colormap(cmap)\n\nif not format:\n    format = ImageType.jpeg if image.mask.all() else ImageType.png\n\ncontent = image.render(\n    img_format=format.driver,\n    **format.profile,\n    **render_params,\n)\n\n# now\n# render_image will:\n# - apply the colormap\n# - choose the right output format if `None`\n# - create the binary data\ncontent, media_type = render_image(\n    image,\n    output_format=format,\n    colormap=colormap or dst_colormap,\n    **render_params,\n)\n</code></pre> </li> </ul>"},{"location":"release-notes/#titilerextension_2","title":"titiler.extension","text":"<ul> <li>rename <code>geom-densify-pts</code> to <code>geometry_densify</code> breaking change</li> <li>rename <code>geom-precision</code> to <code>geometry_precision</code> breaking change</li> </ul>"},{"location":"release-notes/#0133-2023-08-27","title":"0.13.3 (2023-08-27)","text":"<ul> <li>fix Factories <code>url_for</code> method and avoid changing <code>Request.path_params</code> object</li> </ul>"},{"location":"release-notes/#0132-2023-08-24","title":"0.13.2 (2023-08-24)","text":""},{"location":"release-notes/#titilerextensions_5","title":"titiler.extensions","text":"<ul> <li>replace mapbox-gl by maplibre</li> <li>replace Stamen by OpenStreetMap tiles</li> <li>simplify band selection handling (author @tayden, developmentseed/titiler!688)</li> </ul>"},{"location":"release-notes/#0131-2023-08-21","title":"0.13.1 (2023-08-21)","text":""},{"location":"release-notes/#titilercore_24","title":"titiler.core","text":"<ul> <li>fix <code>LowerCaseQueryStringMiddleware</code> unexpectedly truncating query parameters (authors @jthetzel and @jackharrhy, @developmentseed/titiler!677)</li> </ul>"},{"location":"release-notes/#titilerapplication_10","title":"titiler.application","text":"<ul> <li>add <code>cors_allow_methods</code> in <code>ApiSettings</code> to control the CORS allowed methods (author @ubi15, developmentseed/titiler!684)</li> </ul>"},{"location":"release-notes/#0130-2023-07-27","title":"0.13.0 (2023-07-27)","text":"<ul> <li>update core requirements to libraries using pydantic ~=2.0</li> </ul>"},{"location":"release-notes/#titilercore_25","title":"titiler.core","text":"<ul> <li>update requirements:</li> <li>fastapi <code>&gt;=0.95.1</code> \u2192 <code>&gt;=0.100.0</code></li> <li>pydantic <code>~=1.0</code> \u2192 <code>~=2.0</code></li> <li>rio-tiler <code>&gt;=5.0,&lt;6.0</code> \u2192 <code>&gt;=6.0,&lt;7.0</code></li> <li>morecantile<code>&gt;=4.3,&lt;5.0</code> \u2192 <code>&gt;=5.0,&lt;6.0</code></li> <li>geojson-pydantic <code>&gt;=0.4,&lt;0.7</code> \u2192 <code>&gt;=1.0,&lt;2.0</code></li> <li>typing_extensions <code>&gt;=4.6.1</code></li> </ul>"},{"location":"release-notes/#titilerextension_3","title":"titiler.extension","text":"<ul> <li>update requirements:</li> <li>rio-cogeo <code>&gt;=4.0,&lt;5.0\"</code> \u2192 <code>&gt;=5.0,&lt;6.0\"</code></li> </ul>"},{"location":"release-notes/#titilermosaic_8","title":"titiler.mosaic","text":"<ul> <li>update requirements:</li> <li>cogeo-mosaic <code>&gt;=6.0,&lt;7.0</code> \u2192 <code>&gt;=7.0,&lt;8.0</code></li> </ul>"},{"location":"release-notes/#titilerapplication_11","title":"titiler.application","text":"<ul> <li>use <code>/api</code> and <code>/api.html</code> for documentation (instead of <code>/openapi.json</code> and <code>/docs</code>)</li> <li>update landing page</li> </ul>"},{"location":"release-notes/#0120-2023-07-17","title":"0.12.0 (2023-07-17)","text":"<ul> <li>use <code>Annotated</code> Type for Query/Path parameters</li> <li>replace variable <code>TileMatrixSetId</code> by <code>tileMatrixSetId</code></li> </ul>"},{"location":"release-notes/#titilercore_26","title":"titiler.core","text":"<ul> <li>update FastAPI dependency to <code>&gt;=0.95.1</code></li> <li>set <code>pydantic</code> dependency to <code>~=1.0</code></li> <li>update <code>rio-tiler</code> dependency to <code>&gt;=5.0,&lt;6.0</code></li> <li>update TMS endpoints to match OGC Tiles specification</li> </ul>"},{"location":"release-notes/#titilerextensions_6","title":"titiler.extensions","text":"<ul> <li>use TiTiler's custom JSONResponse for the <code>/validate</code> endpoint to avoid issue when COG has <code>NaN</code> nodata value</li> <li>update <code>rio-cogeo</code> dependency to <code>&gt;=4.0,&lt;5.0</code></li> <li>update <code>rio-stac</code> requirement to <code>&gt;=0.8,&lt;0.9</code> and add <code>geom-densify-pts</code> and <code>geom-precision</code> options</li> </ul>"},{"location":"release-notes/#titilermosaic_9","title":"titiler.mosaic","text":"<ul> <li>update <code>cogeo-mosaic</code> dependency to <code>&gt;=6.0,&lt;7.0</code></li> <li>remove <code>titiler.mosaic.resources.enum.PixelSelectionMethod</code> and use <code>rio_tiler.mosaic.methods.PixelSelectionMethod</code></li> <li>allow more TileMatrixSet (than only <code>WebMercatorQuad</code>)</li> </ul>"},{"location":"release-notes/#0117-2023-05-18","title":"0.11.7 (2023-05-18)","text":""},{"location":"release-notes/#titilercore_27","title":"titiler.core","text":"<ul> <li>make HTML <code>templates</code> configurable in the factories</li> <li>rename <code>index.html</code> to <code>map.html</code></li> <li>rename <code>dependencies.CRSParams</code> to <code>dependencies.CoordCRSParams</code></li> <li>add <code>dst-crs</code> option for <code>/preview</code> and <code>/crop</code> endpoints to specify the output Coordinate Reference System.</li> </ul>"},{"location":"release-notes/#titilermosaic_10","title":"titiler.mosaic","text":"<ul> <li>make HTML <code>templates</code> configurable in the factories</li> </ul>"},{"location":"release-notes/#titilerextensions_7","title":"titiler.extensions","text":"<ul> <li>make HTML <code>templates</code> configurable in the factories</li> <li>rename <code>cog_index.html</code> to <code>cog_viewer.html</code></li> <li>rename <code>stac_index.html</code> to <code>stac_viewer.html</code></li> <li>add <code>zoom to point</code> in <code>stac</code> and <code>cog</code> viewers (author @dchirst, developmentseed/titiler!614)</li> </ul>"},{"location":"release-notes/#0116-2023-04-14","title":"0.11.6 (2023-04-14)","text":"<ul> <li>Allow a default <code>rescale</code> parameter to be set via a dependency (author @samn, developmentseed/titiler!619)</li> <li>add <code>coord-crs</code> parameter for <code>/point</code>, <code>/part</code> and <code>/feature</code> endpoints</li> </ul>"},{"location":"release-notes/#0115-2023-03-22","title":"0.11.5 (2023-03-22)","text":"<ul> <li>fix <code>TerrainRGB</code> (change interval from <code>1.0</code> to <code>0.1</code>)</li> </ul>"},{"location":"release-notes/#0114-2023-03-20","title":"0.11.4 (2023-03-20)","text":"<ul> <li>set FastAPI version lower than 0.95 (tiangolo/fastapi?9278)</li> </ul>"},{"location":"release-notes/#0113-2023-03-14","title":"0.11.3 (2023-03-14)","text":"<ul> <li>handle dateline crossing dataset in COG/STAC Viewer</li> <li>update Factories <code>url_for</code> method to make sure we return a string (developmentseed/titiler!607)</li> </ul>"},{"location":"release-notes/#0112-2023-03-08","title":"0.11.2 (2023-03-08)","text":"<ul> <li>Add OSM background in <code>/map</code> viewer when using WebMercator TMS</li> </ul>"},{"location":"release-notes/#0111-2023-03-01","title":"0.11.1 (2023-03-01)","text":"<ul> <li>no change since 0.11.1a0</li> </ul>"},{"location":"release-notes/#0111a0-2023-03-01","title":"0.11.1a0 (2023-03-01)","text":"<ul> <li>switch to <code>hatch</code> and <code>pdm-pep517</code> as build system and use <code>pyproject.toml</code> for python module metadata</li> <li>switch to <code>ruff</code> for python linting</li> <li>update pre-commit configuration</li> <li>documentation fixes \ud83d\ude4f (authors @jthetzel, @neilsh)</li> <li>fix documentation about <code>asset_bidx</code></li> </ul>"},{"location":"release-notes/#titilercore_28","title":"titiler.core","text":"<ul> <li>Algorithm change, make terrainrgb interval and baseval floats to support more quantizers (author @AndrewAnnex, developmentseed/titiler!587)</li> <li>update <code>rio-tiler</code> minimum version to <code>4.1.6</code></li> <li>Apply colormap before defining image output format (when not provided)</li> </ul>"},{"location":"release-notes/#titilermosaic_11","title":"titiler.mosaic","text":"<ul> <li>Apply colormap before defining image output format (when not provided)</li> </ul>"},{"location":"release-notes/#0110-2023-01-27","title":"0.11.0 (2023-01-27)","text":"<ul> <li>add <code>titiler.extensions</code> package (<code>cogValidateExtension</code>, <code>stacExtension</code>, <code>cogViewerExtension</code>,  <code>stacViewerExtension</code>, <code>wmsExtension</code>)</li> </ul>"},{"location":"release-notes/#titilermosaic_12","title":"titiler.mosaic","text":"<ul> <li>update <code>cogeo-mosaic</code> version requirement to <code>&gt;=5.0,&lt;5.2</code> (allow using <code>az://</code> prefix from uri)</li> <li>add <code>MOSAIC_STRICT_ZOOM</code> environment variable to control if the application should allow fetching tiles outside mosaic min/max zooms</li> </ul> <p>breaking change</p>"},{"location":"release-notes/#titilercore_29","title":"titiler.core","text":"<ul> <li>add <code>extensions</code> option to the <code>BaseTilerFactory</code> to specify a list of extension we want to register. Each extension will be then registered in the <code>__post_init__</code> object creation step.</li> <li>remove <code>BaseHTTPMiddleware</code> class inheritance for middleware (write pure ASGI middleware)</li> </ul>"},{"location":"release-notes/#titilerapplication_12","title":"titiler.application","text":"<ul> <li>uses Extension to add more endpoints to default <code>titiler.core</code> factories</li> <li>move all <code>viewer</code> code into <code>titiler.extensions</code></li> <li>add <code>/cog/stac</code> endpoint from <code>titiler.extension.stacExtension</code> to create STAC Items from raster dataset</li> </ul>"},{"location":"release-notes/#titilermosaic_13","title":"titiler.mosaic","text":"<ul> <li>removed deprecated empty path (<code>/</code> is the correct route path, which enable prefixed and non-prefixed mosaic application)</li> </ul>"},{"location":"release-notes/#0102-2022-12-17","title":"0.10.2 (2022-12-17)","text":"<ul> <li>fix issue with new morecantile version</li> <li>replace path parameter in <code>router_prefix</code> in <code>BaseTilerFactory.url_for</code></li> </ul>"},{"location":"release-notes/#0101-2022-12-15","title":"0.10.1 (2022-12-15)","text":"<ul> <li>update <code>/map</code> endpoint and template to support multiple TMS (developmentseed/titiler!560)</li> </ul>"},{"location":"release-notes/#0100-2022-12-09","title":"0.10.0 (2022-12-09)","text":"<p>breaking change</p> <ul> <li>Simplify dependency requirements for titiler.mosaic and titiler.application and using <code>=={currentVersion}</code></li> </ul>"},{"location":"release-notes/#titilercore_30","title":"titiler.core","text":"<ul> <li>fix the <code>wmts.xml</code> template to work with non-epsg based CRS</li> </ul>"},{"location":"release-notes/#titilerapplication_13","title":"titiler.application","text":"<ul> <li>fix titiler.application viewer when using dataset with band name in metadata</li> </ul>"},{"location":"release-notes/#090-2022-12-05","title":"0.9.0 (2022-12-05)","text":""},{"location":"release-notes/#titilercore_31","title":"titiler.core","text":"<ul> <li>add <code>default_tms</code> in <code>BaseTilerFactory</code> to set the default TMS identifier supported by the tiler (e.g <code>WebMercatorQuad</code>)</li> </ul>"},{"location":"release-notes/#081-2022-12-01","title":"0.8.1 (2022-12-01)","text":""},{"location":"release-notes/#titilercore_32","title":"titiler.core","text":"<ul> <li>remove useless <code>titiler.core.version</code> file</li> </ul>"},{"location":"release-notes/#080-2022-12-01","title":"0.8.0 (2022-12-01)","text":"<ul> <li>remove python 3.7 support</li> <li>add python 3.10 and 3.11 in CI</li> </ul>"},{"location":"release-notes/#titilercore_33","title":"titiler.core","text":"<ul> <li>update FastAPI requirement to <code>&gt;=0.87</code></li> <li>update rio-tiler requirement to <code>&gt;=4.1,&lt;4.2</code></li> <li>remove <code>rescale</code> and <code>color_formula</code> from the <code>post_process</code> dependency</li> <li>add <code>algorithm</code> support and introduce new <code>algorithm</code> and <code>algorithm_params</code> query parameters</li> </ul> <p>breaking changes</p> <ul> <li>remove <code>timing headers</code> and <code>titiler.core.utils</code> submodule</li> <li>remove <code>asset_expression</code> (except in <code>/asset_statistics</code> endpoint) (see cogeotiff.github.io/rio-tiler/v4_migration/#multibasereader-expressions)</li> <li>update Point output model to include <code>band_names</code></li> <li>histogram and info band names are prefixed with <code>b</code> (e.g <code>b1</code>) (ref: cogeotiff.github.io/rio-tiler/v4_migration/#band-names)</li> <li>add <code>/map</code> endpoint in TilerFactory to display tiles given query-parameters</li> <li>remove <code>TMSParams</code> and <code>WebMercatorTMSParams</code> dependencies.</li> <li>replace <code>TilerFactory.tms_dependency</code> attribute by <code>TilerFactory.supported_tms</code>. This attribute gets a <code>morecantile.defaults.TileMatrixSets</code> store and will create the tms dependencies dynamically</li> <li>replace <code>TMSFactory.tms_dependency</code> attribute by <code>TMSFactory.supported_tms</code>. This attribute gets a <code>morecantile.defaults.TileMatrixSets</code> store and will create the tms dependencies dynamically</li> <li>move <code>stats_dependency</code> and <code>histogram_dependency</code> from <code>BaseTilerFactory</code> to <code>TilerFactory</code></li> <li>per rio-tiler changes, <code>;</code> has be to used in expression to indicate multiple bands. <code>b1*2,b2+b3,b1/b3</code> -&gt; <code>b1*2;b2+b3;b1/b3</code></li> </ul>"},{"location":"release-notes/#titilermosaic_14","title":"titiler.mosaic","text":"<ul> <li>update cogeo-mosaic requirement to <code>&gt;=4.2,&lt;4.3</code></li> </ul> <p>breaking changes</p> <ul> <li>remove <code>timing headers</code></li> <li>replace <code>MosaicTilerFactory.tms_dependency</code> attribute by <code>MosaicTilerFactory.supported_tms</code>. This attribute gets a <code>morecantile.defaults.TileMatrixSets</code> store and will create the tms dependencies dynamically</li> </ul>"},{"location":"release-notes/#titilerapplication_14","title":"titiler.application","text":"<ul> <li>code simplification by removing custom code and submodules from endpoints</li> </ul> <p>breaking changes</p> <ul> <li>remove custom TMS and custom Colormap dependencies</li> <li>remove middleware submodule</li> </ul>"},{"location":"release-notes/#071-2022-09-21","title":"0.7.1 (2022-09-21)","text":""},{"location":"release-notes/#titilermosaic_15","title":"titiler.mosaic","text":"<ul> <li>add <code>pixel_selection_dependency</code> options in <code>MosaicTilerFactory</code> to allow default method override (author @samn, developmentseed/titiler!495)</li> </ul>"},{"location":"release-notes/#titilerapplication_15","title":"titiler.application","text":"<ul> <li>allow <code>interval</code> colormaps in titiler.application</li> </ul>"},{"location":"release-notes/#helm-charts","title":"Helm charts","text":"<ul> <li>Check Charts workflow added for the Helm charts testing (author @emmanuelmathot, developmentseed/titiler!495)</li> </ul>"},{"location":"release-notes/#070-2022-06-08","title":"0.7.0 (2022-06-08)","text":"<ul> <li>add <code>environment_dependency</code> option in <code>BaseTilerFactory</code> to define GDAL environment at runtime.</li> <li>remove <code>gdal_config</code> option in <code>BaseTilerFactory</code> breaking</li> </ul> <pre><code># before\nrouter = TilerFactory(gdal_config={\"GDAL_DISABLE_READDIR_ON_OPEN\": \"FALSE\"}).router\n\n# now\nrouter = TilerFactory(environment_dependency=lambda: {\"GDAL_DISABLE_READDIR_ON_OPEN\": \"FALSE\"}).router\n\n\nclass ReaddirType(str, Enum):\n\n    false = \"false\"\n    true = \"true\"\n    empty_dir = \"empty_dir\"\n\n\n# or at endpoint call. The user could choose between false/true/empty_dir\ndef gdal_env(disable_read: ReaddirType = Query(ReaddirType.false)):\n    return {\"GDAL_DISABLE_READDIR_ON_OPEN\": disable_read.value.upper()}\n\nrouter = TilerFactory(environment_dependency=gdal_env).router\n</code></pre>"},{"location":"release-notes/#titilerapplication_16","title":"titiler.application","text":"<ul> <li>update <code>starlette-cramjam</code> requirement</li> </ul>"},{"location":"release-notes/#060-2022-05-13","title":"0.6.0 (2022-05-13)","text":"<ul> <li>no change since <code>0.6.0a2</code></li> </ul>"},{"location":"release-notes/#060a2-2022-05-11","title":"0.6.0a2 (2022-05-11)","text":"<ul> <li>revert to <code>setup.py</code> + <code>setuptools</code> instead of <code>pyproject.toml</code> + <code>flit</code> because it broke namespace packages (developmentseed/titiler!472)</li> </ul>"},{"location":"release-notes/#060a1-2022-05-11","title":"0.6.0a1 (2022-05-11)","text":""},{"location":"release-notes/#titilercore_34","title":"titiler.core","text":"<ul> <li>remove logging in error <code>exception_handler_factory</code></li> <li>add optional <code>reader_dependency</code> to enable passing <code>Reader</code>'s option defined by Query/Header/Path parameters.</li> <li>switch to <code>pyproject.toml</code></li> <li>move version definition in <code>titiler.core.__version__</code> breaking</li> <li>Include all values for a query param in <code>LowerCaseQueryStringMiddleware</code> (author @samn, developmentseed/titiler!464)</li> </ul>"},{"location":"release-notes/#titilermosaic_16","title":"titiler.mosaic","text":"<ul> <li>add optional <code>backend_dependency</code> to enable passing <code>Backend</code>'s option defined by Query/Header/Path parameters.</li> <li>remove <code>backend_options</code> MosaicTilerFactory argument in favor of the use of <code>backend_dependency</code> breaking</li> <li>switch to <code>pyproject.toml</code></li> <li>move version definition in <code>titiler.mosaic.__version__</code> breaking</li> </ul>"},{"location":"release-notes/#titilerapplication_17","title":"titiler.application","text":"<ul> <li>Fix frontend to handle anti-meridian crossing data</li> <li>switch to <code>pyproject.toml</code></li> <li>move version definition in <code>titiler.application.__version__</code> breaking</li> </ul>"},{"location":"release-notes/#051-2022-03-07","title":"0.5.1 (2022-03-07)","text":"<ul> <li>add <code>cachecontrol_max_http_code</code> option to <code>CacheControlMiddleware</code> to avoid adding cache-control headers for API errors (Author @sharkinsspatial, developmentseed/titiler!444)</li> </ul>"},{"location":"release-notes/#050-2022-02-22","title":"0.5.0 (2022-02-22)","text":"<ul> <li>update rio-tiler/morecantile/rio-cogeo/cogeo-mosaic versions</li> <li>add MultiBaseTilerFactory <code>/asset_statistics</code> which will return per asset statistics. Returns response in form of <code>Dict[{asset name}, Dict[{band name}, BandStatistics]]</code></li> </ul> <p>breaking change</p> <ul> <li>Multi-band expression now uses semicolon <code>;</code> instead of colon (<code>,</code>) as separator. Note: proper urlencoding might be needed.</li> </ul> <pre><code># before\nexpression = \"b1+b2,b2\"\n\n# new\nexpression = \"b1+b2;b2\"\n</code></pre> <ul> <li>MultiBaseTilerFactory <code>/statistics</code> now returns merged statistics in form of <code>Dict[{asset_band or expression}, BandStatistics]</code> (instead of <code>Dict[{asset name}, Dict[{band name}, BandStatistics]]</code>)</li> </ul> <pre><code># before\nresponse = httpx.get(f\"/stac/statistics?url=item.json\").json()\nprint(response)\n&gt;&gt;&gt; {\n    \"asset1\": {\n        \"1\": {\n            \"min\": ...,\n            \"max\": ...,\n            ...\n        },\n        \"2\": {\n            \"min\": ...,\n            \"max\": ...,\n            ...\n        }\n    }\n}\n\n# now\nresponse = httpx.get(f\"/stac/statistics?url=item.json\").json()\nprint(response)\n&gt;&gt;&gt; {\n    \"asset1_1\": {\n        \"min\": ...,\n        \"max\": ...,\n        ...\n    },\n    \"asset1_2\": {\n        \"min\": ...,\n        \"max\": ...,\n        ...\n    },\n}\n</code></pre>"},{"location":"release-notes/#043-2022-02-08","title":"0.4.3 (2022-02-08)","text":"<ul> <li>add tile <code>buffer</code> option to match rio-tiler tile options (developmentseed/titiler!427)</li> </ul>"},{"location":"release-notes/#042-2022-01-25","title":"0.4.2 (2022-01-25)","text":""},{"location":"release-notes/#titilercore_35","title":"titiler.core","text":"<ul> <li>update minimum FastAPI version to <code>&gt;=0.73</code> (developmentseed/titiler!425)</li> </ul>"},{"location":"release-notes/#041-2022-01-25","title":"0.4.1 (2022-01-25)","text":""},{"location":"release-notes/#titilercore_36","title":"titiler.core","text":"<ul> <li>update type information for the factory <code>colormap_dependency</code></li> </ul>"},{"location":"release-notes/#k8s","title":"k8s","text":"<ul> <li>Update ingress k8s templates to be compatible with latest resource types versions (developmentseed/titiler!425</li> </ul>"},{"location":"release-notes/#040-2021-11-30","title":"0.4.0 (2021-11-30)","text":"<ul> <li>rename <code>Dockerfile</code> to <code>Dockerfile.gunicorn</code></li> <li>switch default docker image to python3.9</li> <li>add <code>Dockerfile.uvicorn</code></li> </ul>"},{"location":"release-notes/#titilercore_37","title":"titiler.core","text":"<ul> <li>update <code>rio-tiler</code> version requirement to <code>&gt;=3.0</code></li> </ul>"},{"location":"release-notes/#titilermosaic_17","title":"titiler.mosaic","text":"<ul> <li>update <code>cogeo-mosaic</code> version to <code>&gt;=4.0</code></li> </ul>"},{"location":"release-notes/#040a2-2021-11-24","title":"0.4.0a2 (2021-11-24)","text":""},{"location":"release-notes/#titilercore_38","title":"titiler.core","text":"<ul> <li>update <code>rio-tiler</code> version (&gt;=3.0.0a6) with new colormap types information and base classes</li> <li>remove <code>additional_dependency</code> attribute in <code>BaseTileFactory</code>. This also remove <code>**kwargs</code> in endpoints breaking</li> <li>remove <code>reader_options</code> attribute in <code>BaseTileFactory</code> breaking</li> <li><code>tms_dependency</code> default to <code>titiler.core.dependencies.TMSParams</code> which should supports all morecantile's TMS.</li> <li>add <code>route_dependencies</code> attribute to <code>BaseTilerFactory</code> to allow customizing route dependencies (author @alukach, developmentseed/titiler!406)</li> </ul>"},{"location":"release-notes/#titilermosaic_18","title":"titiler.mosaic","text":"<ul> <li>update <code>cogeo-mosaic</code> version (&gt;=4.0.0a2) with updated Backend type hints information</li> </ul>"},{"location":"release-notes/#040a1-2021-11-12","title":"0.4.0a1 (2021-11-12)","text":"<ul> <li>fix titiler packages cross dependencies</li> </ul>"},{"location":"release-notes/#040a0-2021-11-12","title":"0.4.0a0 (2021-11-12)","text":"<ul> <li>remove python 3.6 supports (related to morecantile/pyproj update)</li> </ul>"},{"location":"release-notes/#titilercore_39","title":"titiler.core","text":"<ul> <li>update <code>rio-tiler/morecantile</code> requirement (&gt;=3.0)</li> <li>remove <code>utils.bbox_to_feature</code> (replaced by geojson_pydantic native function <code>Feature(geometry=Polygon.from_bounds(*bounds), properties=info)</code>)</li> <li>remove <code>utils.data_stats</code> (replaced by rio-tiler new statistics method)</li> <li>remove <code>metadata</code> endpoints  breaking API</li> <li>update <code>statistics</code> endpoints with histogram options</li> <li>update <code>statistics</code> endpoint responses breaking API</li> <li>remove <code>band_expression</code> in <code>BandsExprParams</code> dependency breaking API</li> <li>remove <code>morecantile</code> requirement definition in setup.py and defers to rio-tiler supported version</li> <li>update <code>titiler.core.dependencies.DefaultDependency</code> (allows dict unpacking and remove <code>.kwargs</code>) breaking API</li> <li>use standard for List in QueryParameter (e.g <code>bidx=1&amp;bidx=2&amp;bidx</code> instead of <code>bidx=1,2,3</code>) breaking API</li> <li>add <code>asset_bidx</code> query parameter in replacement of <code>bidx</code> in MultiBaseFactory dependencies and switch to new format: <code>{asset name}|{bidx,bidx,bidx}</code> breaking API</li> <li>update <code>asset_expression</code> to the new format: <code>{asset name}|{expression}</code> (e.g <code>data|b1+b2</code>) breaking API</li> <li>update <code>assets</code> QueryParameter to List (e.g <code>assets=COG&amp;assets=Data</code>) breaking API</li> <li>update <code>bands</code> QueryParameter to List (e.g <code>bands=B01&amp;bands=B02</code>) breaking API</li> <li>split <code>RenderParams</code> dependency into:<ul> <li><code>PostProcessParams</code>: <code>rescale</code> and <code>color_formula</code> parameters</li> <li><code>ImageRenderingParams</code>: <code>return_mask</code></li> </ul> </li> <li>add <code>process_dependency</code> attribute in <code>BaseTilerFactory</code> (defaults to <code>PostProcessParams</code>)</li> <li>use <code>resampling</code> alias instead of <code>resampling_method</code> for QueryParameter breaking API</li> <li>defaults to available assets if <code>assets</code> option is not provided for <code>MultiBaseTilerFactory</code> info and statistics endpoints.</li> <li>defaults to available bands if <code>bands</code> option is not provided for <code>MultiBandsTilerFactory</code> info and statistics endpoints.</li> <li>better output models definition</li> <li>keep <code>bounds</code>, <code>minzoom</code> and <code>maxzoom</code> in <code>/info</code> response</li> <li>remove <code>dataset</code> in <code>/info</code> response to better follow the Info model</li> <li>add <code>/statistics</code> endpoint by default</li> </ul>"},{"location":"release-notes/#titilermosaic_19","title":"titiler.mosaic","text":"<ul> <li>update <code>cogeo-mosaic</code> requirement (&gt;=4.0)</li> <li>update response from <code>/info</code> endpoint to match the model.</li> </ul>"},{"location":"release-notes/#titilerapplication_18","title":"titiler.application","text":"<ul> <li>update viewers to match changes in titiler.core endpoints</li> </ul>"},{"location":"release-notes/#0312-2021-10-20","title":"0.3.12 (2021-10-20)","text":""},{"location":"release-notes/#titilercore_40","title":"titiler.core","text":"<ul> <li>Update morecantile requirement to stay under <code>3.0</code> (author @robintw, developmentseed/titiler!389)</li> </ul>"},{"location":"release-notes/#0311-2021-10-07","title":"0.3.11 (2021-10-07)","text":""},{"location":"release-notes/#titilerapplication_19","title":"titiler.application","text":"<ul> <li>Update rio-cogeo requirement to stay under <code>3.0</code></li> </ul>"},{"location":"release-notes/#0310-2021-09-23","title":"0.3.10 (2021-09-23)","text":""},{"location":"release-notes/#titilercore_41","title":"titiler.core","text":"<ul> <li>add custom JSONResponse using simplejson to allow NaN/inf/-inf values (ref: developmentseed/titiler!374)</li> <li>use <code>titiler.core.resources.responses.JSONResponse</code> as default response for <code>info</code>, <code>metadata</code>, <code>statistics</code> and <code>point</code> endpoints (ref: developmentseed/titiler!374)</li> </ul>"},{"location":"release-notes/#titilerapplication_20","title":"titiler.application","text":"<ul> <li>switch to <code>starlette_cramjam</code> compression middleware (ref: developmentseed/titiler#369)</li> </ul>"},{"location":"release-notes/#039-2021-09-07","title":"0.3.9 (2021-09-07)","text":""},{"location":"release-notes/#titilercore_42","title":"titiler.core","text":"<ul> <li>update FastAPI requirements to <code>&gt;=0.65,&lt;0.68</code> (ref: developmentseed/titiler#366)</li> <li>surface <code>asset_expression</code> and <code>band_expression</code> in Multi*TilerFactory (ref: developmentseed/titiler#367)</li> </ul>"},{"location":"release-notes/#038-2021-09-02","title":"0.3.8 (2021-09-02)","text":""},{"location":"release-notes/#titilercore_43","title":"titiler.core","text":"<ul> <li>move <code>titiler.application.middleware</code> to <code>titiler.core.middleware</code> (developmentseed/titiler!365)</li> </ul>"},{"location":"release-notes/#037-2021-09-01","title":"0.3.7 (2021-09-01)","text":""},{"location":"release-notes/#titilercore_44","title":"titiler.core","text":"<ul> <li>Update the TileJSON model for better validation and to match with the specification (center is optional) (developmentseed/titiler!363)</li> </ul>"},{"location":"release-notes/#036-2021-08-23","title":"0.3.6 (2021-08-23)","text":""},{"location":"release-notes/#titilercore_45","title":"titiler.core","text":"<ul> <li>fix morecantile related tests (developmentseed/titiler#358)</li> <li>fix float parsing when datatype is float32 (developmentseed/rio-viz#39)</li> </ul>"},{"location":"release-notes/#titilerapplication_21","title":"titiler.application","text":"<ul> <li>fix morecantile related tests (developmentseed/titiler#358)</li> </ul>"},{"location":"release-notes/#035-2021-08-17","title":"0.3.5 (2021-08-17)","text":""},{"location":"release-notes/#titilermosaic_20","title":"titiler.mosaic","text":"<ul> <li>add <code>/{z}/{x}/{y}/assets</code>, <code>/{lon},{lat}/assets</code>, <code>/{minx},{miny},{maxx},{maxy}/assets</code> GET endpoints to return a list of assets that intersect a given geometry (author @mackdelany, developmentseed/titiler!351)</li> </ul>"},{"location":"release-notes/#034-2021-08-02-not-published-on-pypi-355","title":"0.3.4 (2021-08-02) - Not published on PyPi #355","text":""},{"location":"release-notes/#titilercore_46","title":"titiler.core","text":"<ul> <li>add <code>/crop</code> POST endpoint to return an image from a GeoJSON feature (developmentseed/titiler!339)</li> <li>add <code>/statistics</code> (GET and POST) endpoints to return advanced images statistics (developmentseed/titiler!347)</li> </ul>"},{"location":"release-notes/#titilerapplication_22","title":"titiler.application","text":"<ul> <li>add optional <code>root_path</code> setting to specify a url path prefix to use when running the app behind a reverse proxy (developmentseed/titiler!343)</li> </ul>"},{"location":"release-notes/#033-2021-06-29-not-published-on-pypi-355","title":"0.3.3 (2021-06-29) - Not published on PyPi #355","text":""},{"location":"release-notes/#titilercore_47","title":"titiler.core","text":"<ul> <li>fix possible bug when querystring parameter are case insensitive (developmentseed/titiler!323)</li> </ul>"},{"location":"release-notes/#titilermosaic_21","title":"titiler.mosaic","text":"<ul> <li>update <code>tilejson</code> and <code>WMTSCapabilities.xml</code> endpoints to allow list querystrings (as done previously in developmentseed/titiler#319)</li> </ul>"},{"location":"release-notes/#titilerapplication_23","title":"titiler.application","text":"<ul> <li>add <code>titiler.application.middleware.LowerCaseQueryStringMiddleware</code> to cast all query string parameter to lowercase (author @lorenzori, developmentseed/titiler!321)</li> </ul>"},{"location":"release-notes/#code-and-repo","title":"code and repo","text":"<ul> <li>move <code>titiler</code> code to <code>src/titiler</code></li> </ul>"},{"location":"release-notes/#032-2021-05-26","title":"0.3.2 (2021-05-26)","text":""},{"location":"release-notes/#titilercore_48","title":"titiler.core","text":"<ul> <li>update rio-tiler dependency to <code>&gt;=2.1</code> version and update <code>rescale</code> query-parameter (developmentseed/titiler#319)</li> </ul> <pre><code># before\n# previously, rio-tiler was splitting a list of input range in tuple of 2\nrescale=0,1000,0,1000,0,1000\n\n# now\n# rio-tiler 2.1 now expect sequence of tuple in form of Sequence[Tuple[Num, Num]]\nrescale=0,1000&amp;rescale=0,1000&amp;rescale=0,1000\n</code></pre>"},{"location":"release-notes/#titilermosaic_22","title":"titiler.mosaic","text":"<ul> <li>update <code>cogeo-mosaic</code> version to <code>&gt;=3.0,&lt;3.1</code>.</li> </ul>"},{"location":"release-notes/#titilerapplication_24","title":"titiler.application","text":"<ul> <li>re-order middlewares (developmentseed/titiler#311)</li> <li>update rio-cogeo version to <code>&gt;=2.2</code> and use <code>rio_cogeo.models</code> instead of custom ones.</li> </ul>"},{"location":"release-notes/#031-2021-04-27","title":"0.3.1 (2021-04-27)","text":"<ul> <li>add <code>exclude_path</code> options in <code>titiler.application.middleware.CacheControlMiddleware</code> to avoid adding cache-control headers to specific paths.</li> <li>allow <code>histogram_bins</code> to be a single value or a <code>,</code> delimited scalar (developmentseed/titiler!307)</li> <li> <p>change error status from <code>404</code> to <code>500</code> for <code>RasterioIOError</code> exception (author @kylebarron, developmentseed/titiler!300)</p> <p>Sometimes GDAL/Rasterio can lose track of the file handler (might be related to cache issue + threading) and raise <code>RasterioIOError: file not found</code>, while the file exists for real. To avoid caching this, we changed the error code to 500 (errors &gt;= 500 do not get <code>cache-control</code> header on titiler.application).</p> </li> </ul>"},{"location":"release-notes/#030-2021-04-19","title":"0.3.0 (2021-04-19)","text":"<ul> <li>add support for <code>.jpg</code> and <code>.jpeg</code> extensions (developmentseed/titiler!271)</li> <li>better error message when parsing the colormap value fails (developmentseed/titiler!279)</li> </ul> <p>breaking change</p> <ul> <li> <p>split <code>titiler</code> into a set of namespaces packages (developmentseed/titiler!284)</p> <p>titiler.core</p> <p>The <code>core</code> package host the low level tiler factories. <pre><code># before\nfrom titiler.endpoints.factory import TilerFactory\n\n# now\nfrom titiler.core.factory import TilerFactory\n</code></pre></p> <p>titiler.mosaic</p> <p>The <code>mosaic</code> package is a plugin to <code>titiler.core</code> which adds support for MosaicJSON <pre><code># before\nfrom titiler.endpoints.factory import MosaicTilerFactory\n\n# now\nfrom titiler.mosaic.factory import MosaicTilerFactory\n</code></pre></p> <p>titiler.application</p> <p>The <code>application</code> package is a full <code>ready to use</code> FastAPI application with support of STAC, COG and MosaicJSON.</p> <pre><code># before\n$ pip install titiler\n$ uvicorn titiler.main:app --reload\n\n# now\n$ pip install titiler.application uvicorn\n$ uvicorn titiler.application.main:app --reload\n</code></pre> </li> </ul>"},{"location":"release-notes/#020-2021-03-09","title":"0.2.0 (2021-03-09)","text":"<ul> <li>adapt for cogeo-mosaic <code>3.0.0rc2</code> and add <code>backend_options</code> attribute in MosaicTilerFactory (developmentseed/titiler!247)</li> <li>update FastAPI requirements</li> <li>update minimal python version to 3.6</li> <li>add <code>**render_params.kwargs</code> to pass custom render params in <code>image.render</code> method (developmentseed/titiler!259)</li> <li>Changed probe url from <code>/ping</code> to <code>/healthz</code> in k8s deployment</li> </ul> <p>breaking change</p> <ul> <li>renamed <code>OptionalHeaders</code>, <code>MimeTypes</code> and <code>ImageDrivers</code> enums to the singular form (developmentseed/titiler!258)</li> <li>renamed titiler.dependencies's Enums (<code>ColorMapName</code>, <code>ResamplingName</code> and <code>TileMatrixSetName</code>) to the singular form (developmentseed/titiler!260)</li> <li>renamed <code>MimeType</code> to <code>MediaType</code> (developmentseed/titiler!258)</li> <li>add <code>ColorMapParams</code> dependency to ease the creation of custom colormap dependency (developmentseed/titiler!252)</li> <li>renamed <code>PathParams</code> to <code>DatasetPathParams</code> and also made it a simple callable (developmentseed/titiler!260)</li> <li> <p>renamed <code>colormap</code> query-parameter to <code>colormap_name</code> (developmentseed/titiler!262)     <pre><code># before\n/cog/preview.png?colormap=viridis\n\n# now\n/cog/preview.png?colormap_name=viridis\n</code></pre></p> </li> <li> <p>use <code>colormap</code> query-parameter to pass custom colormap (developmentseed/titiler!262)     <pre><code>/cog/preview.png?colormap={\"0\": \"#FFFF00FF\", ...}\n</code></pre></p> </li> </ul>"},{"location":"release-notes/#010-2021-02-17","title":"0.1.0 (2021-02-17)","text":"<ul> <li>update FastAPI requirements</li> <li>add <code>validate</code> in <code>MosaicTilerFactory</code> (developmentseed/titiler!206, author @drnextgis)</li> <li>rename <code>ressources</code> package to <code>resources</code> (developmentseed/titiler!210, author @drnextgis)</li> <li>renamed environment variables prefixes for API and STACK configurations: <code>TITILER_STACK</code> as prefix to CDK and <code>TITILER_API</code> as prefix to API (developmentseed/titiler!211, author @fredliporace)</li> <li>remove MosaicTilerFactory <code>create</code> and <code>update</code> endpoints (developmentseed/titiler!218)</li> <li>deleted <code>titiler.models.mosaics</code> because the models are not used anymore (developmentseed/titiler!221)</li> <li>update rio-tiler and cogeo-mosaic minimal versions (developmentseed/titiler!220, developmentseed/titiler!213)</li> <li>move STAC related dependencies to `titiler.dependencies (developmentseed/titiler!225)</li> <li>add <code>rio_tiler.io.MultiBandReader</code> bands dependencies (developmentseed/titiler!226)</li> <li>add <code>MultiBaseTilerFactory</code> and <code>MultiBandTilerFactory</code> custom tiler factories (developmentseed/titiler!230)</li> <li>Update STAC tiler to use the new <code>MultiBaseTilerFactory</code> factory</li> <li>depreciate empty GET endpoint for MosaicTilerFactory read (developmentseed/titiler!232)</li> <li>better <code>debug</code> configuration and make reponse headers metadata optional (developmentseed/titiler!232)</li> </ul> <p>breaking change</p> <ul> <li>update <code>titiler.dependencies.AssetsBidxParams</code> to make <code>asset</code> a required parameter (developmentseed/titiler!230</li> <li>the STAC <code>/info</code> endpoint now expect the <code>assets</code> parameter to be passed. To ge the list of available assets we added a new <code>/assets</code> endpoint within the tiler factory</li> <li>remove <code>COGReader</code> as default <code>reader</code> in <code>titiler.endpoints.factory.BaseTilerFactory</code></li> </ul>"},{"location":"release-notes/#010a14-2021-01-05","title":"0.1.0a14 (2021-01-05)","text":"<ul> <li>add <code>rio_tiler.errors.MissingBands</code> in known errors.</li> <li>add <code>titiler.endpoints.factory.TMSFactory</code> to enable custom TMS endpoints.</li> <li>breaking rename <code>BaseFactory</code> to <code>BaseTilerFactory</code> in <code>titiler.endpoints.factory</code></li> </ul>"},{"location":"release-notes/#010a13-2020-12-20","title":"0.1.0a13 (2020-12-20)","text":"<ul> <li>allow <code>API_DISABLE_{COG/STAC/MOSAIC}</code> environment variables to control default endpoints in titiler main app (developmentseed/titiler#156)</li> <li>add <code>overwriting=False/True</code> on MosaicJSON creation (developmentseed/titiler#164)</li> <li>add <code>gdal_config</code> option to Tiler factories to replace custom <code>APIRoute</code> class (developmentseed/titiler#168)</li> <li>add <code>info.geojson</code> endpoint to return dataset info as a GeoJSON feature (developmentseed/titiler#166)</li> <li>update <code>rio-tiler</code>, <code>cogeo-mosaic</code> and optional dependencies</li> </ul>"},{"location":"release-notes/#010a12-2020-11-18","title":"0.1.0a12 (2020-11-18)","text":"<ul> <li>require <code>rio-tiler&gt;=2.0.0rc2</code></li> <li>update Enums for Image types. (breaking)</li> <li>Add more output datatype (jpeg2000, pngraw)</li> <li>add <code>width/height</code> in <code>/crop</code> endpoint path</li> </ul> <pre><code>/crop/{minx},{miny},{maxx},{maxy}.{format}\n/crop/{minx},{miny},{maxx},{maxy}/{width}x{height}.{format}\n</code></pre>"},{"location":"release-notes/#010a11post1-2020-11-12","title":"0.1.0a11.post1 (2020-11-12)","text":"<ul> <li>relax version for rio-tiler and cogeo-mosaic</li> </ul> <pre><code>\"rio-cogeo~=2.0\"\n\"rio-tiler&gt;=2.0.0rc1,&lt;2.1\"\n\"cogeo-mosaic&gt;=3.0.0a17,&lt;3.1\"\n</code></pre>"},{"location":"release-notes/#010a11-2020-11-12","title":"0.1.0a11 (2020-11-12)","text":"<ul> <li>split <code>tile()</code> for <code>MosaicTilerFactory</code> method (developmentseed/titiler#147)</li> </ul>"},{"location":"release-notes/#010a10-2020-11-09","title":"0.1.0a10 (2020-11-09)","text":"<ul> <li>update for rio-tiler==2.0.0rc1, cogeo-mosaic==3.0.0a17 and morecantile==2.0</li> <li>split <code>tile()</code> factory method (developmentseed/titiler#141, author @fredliporace)</li> </ul>"},{"location":"release-notes/#010a9-2020-10-26","title":"0.1.0a9 (2020-10-26)","text":"<ul> <li>avoid changing mutable TMS and Colormap list by using deepcopy.</li> <li>quiet/turn off logs</li> <li>add logger middleware (developmentseed/titiler!139)</li> </ul>"},{"location":"release-notes/#010a8-2020-10-13","title":"0.1.0a8 (2020-10-13)","text":"<ul> <li>update for rio-tiler 2.0.0b17, which now support TMS (morecantile) by default.</li> <li>update fastapi minimum version to 0.61</li> </ul> <p>breaking changes</p> <ul> <li>removed TMSTilerFactory (because default reader built with rio_tiler BaseReader should support TMS).</li> </ul> <p>Note: We changed the versioning scheme to <code>{major}.{minor}.{path}{pre}{prenum}</code></p>"},{"location":"release-notes/#010-alpha7-2020-10-13","title":"0.1.0-alpha.7 (2020-10-13)","text":"<ul> <li>remove <code>pkg_resources</code> (pypa/setuptools#510)</li> </ul>"},{"location":"release-notes/#010-alpha6-2020-10-05","title":"0.1.0-alpha.6 (2020-10-05)","text":"<ul> <li>refactor CacheControl Middleware</li> <li>rename headers value <code>X-Server-Timings</code> to <code>Server-Timing</code>.</li> <li>add <code>total;dur={}</code> in response header <code>Server-Timing</code>, using new <code>titiler.middleware.TotalTimeMiddleware</code> middleware (113)</li> </ul> <pre><code>from titiler.middleware import CacheControlMiddleware, TotalTimeMiddleware\nfrom fastapi import FastAPI\n\napp.add_middleware(CacheControlMiddleware, cachecontrol=\"public, max-age=3600\")\napp.add_middleware(TotalTimeMiddleware)\n</code></pre> <ul> <li>Add Brotli compression support (#126, author @kylebarron)</li> <li>Numerous fix to CDK app.py (co-author @kylebarron)</li> </ul>"},{"location":"release-notes/#010-alpha5-2020-09-22","title":"0.1.0-alpha.5 (2020-09-22)","text":"<ul> <li>exclude <code>tests/</code> an <code>stack/</code> in titiler python package.</li> <li>add <code>EPSG6933</code> in TMS</li> </ul> <p>breaking changes * [FACTORY] the <code>additional_dependency</code> should be a Callable which return a dict.</p> <pre><code>```python\n@dataclass  # type: ignore\nclass BaseFactory(metaclass=abc.ABCMeta):\n    \"\"\"BaseTiler Factory.\"\"\"\n    ...\n    # provide custom dependency\n    additional_dependency: Callable[..., Dict] = field(default=lambda: dict())\n```\n\n```python\ndef AssetsParams(\n    assets: Optional[str] = Query(\n        None,\n        title=\"Asset indexes\",\n        description=\"comma (',') delimited asset names (might not be an available options of some readers)\",\n    )\n) -&gt; Dict:\n    \"\"\"Assets Dependency.\"\"\"\n    kwargs = {}\n    if assets:\n        kwargs[\"assets\"] = assets.split(\",\")\n    return kwargs\n```\n</code></pre> <ul> <li>[FACTORY] remove <code>_</code> prefix in factory methods (e.g <code>_tile</code> -&gt; <code>tile</code>)</li> <li> <p>[FACTORY] refactor dependencies to better align with rio_tiler.io.BaseReader method definition.</p> <p>Example:</p> <p>In the <code>metadata</code>, the <code>MetadataParams</code> will be used to pass <code>pmin</code> and <code>pmax</code> because they are the only required parameters for the metadata method. All other params will be passed to a <code>kwargs</code> dict.</p> <p><pre><code>@dataclass\nclass MetadataParams(DefaultDependency):\n    \"\"\"Common Metadada parameters.\"\"\"\n    # Required params\n    pmin: float = Query(2.0, description=\"Minimum percentile\")\n    pmax: float = Query(98.0, description=\"Maximum percentile\")\n    # Optional parameters\n    bidx: Optional[str] = Query(\n        None, title=\"Band indexes\", description=\"comma (',') delimited band indexes\",\n    )\n    ...\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n\n        if self.bidx is not None:\n            self.kwargs[\"indexes\"] = tuple(\n                int(s) for s in re.findall(r\"\\d+\", self.bidx)\n            )\n    ...\n\n# metadata method in factory\ndef metadata(\n    src_path=Depends(self.path_dependency),\n    metadata_params=Depends(self.metadata_dependency),\n    kwargs: Dict = Depends(self.additional_dependency),\n):\n    \"\"\"Return metadata.\"\"\"\n    reader = src_path.reader or self.reader\n    with reader(src_path.url, **self.reader_options) as src_dst:\n        info = src_dst.metadata(\n            metadata_params.pmin,\n            metadata_params.pmax,\n            **metadata_params.kwargs,\n            **kwargs,\n        )\n    return info\n</code></pre> * [FACTORY] refactor dependencies definition <pre><code>@dataclass  # type: ignore\nclass BaseFactory(metaclass=abc.ABCMeta):\n    \"\"\"BaseTiler Factory.\"\"\"\n\n    reader: default_readers_type = field(default=COGReader)\n    reader_options: Dict = field(default_factory=dict)\n\n    # FastAPI router\n    router: APIRouter = field(default_factory=APIRouter)\n\n    # Path Dependency\n    path_dependency: Type[PathParams] = field(default=PathParams)\n\n    # Rasterio Dataset Options (nodata, unscale, resampling)\n    dataset_dependency: default_deps_type = field(default=DatasetParams)\n\n    # Indexes/Expression Dependencies\n    layer_dependency: default_deps_type = field(default=BidxExprParams)\n\n    # Image rendering Dependencies\n    render_dependency: default_deps_type = field(default=RenderParams)\n\n    # TileMatrixSet dependency\n    tms_dependency: Callable[..., TileMatrixSet] = WebMercatorTMSParams\n\n    # provide custom dependency\n    additional_dependency: Callable[..., Dict] = field(default=lambda: dict())\n</code></pre></p> </li> <li> <p>remove <code>PathParams.reader</code> attribute. This option was not used and would have been technically difficult to use.     <pre><code>@dataclass\nclass PathParams:\n    \"\"\"Create dataset path from args\"\"\"\n\n    url: str = Query(..., description=\"Dataset URL\")\n</code></pre></p> </li> </ul>"},{"location":"release-notes/#010-alpha4-2020-09-14","title":"0.1.0-alpha.4 (2020-09-14)","text":"<ul> <li> <p>Update <code>.npy</code> output format to follow the numpyTile format (#103)</p> <pre><code>import numpy\nimport requests\nfrom io import BytesIO\n\nendpoint = ...\nurl = \"https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\"\n\nr = requests.get(f\"{endpoint}/cog/tiles/14/10818/9146.npy\",\n    params = {\n        \"url\": url,\n    }\n)\ndata = numpy.load(BytesIO(r.content))\nprint(data.shape)\n&gt; (4, 256, 256)\n</code></pre> </li> <li> <p>Add <code>titiler.custom.routing.apiroute_factory</code>. This function enable the creation of custom fastapi.routing.APIRoute class with <code>rasterio.Env()</code> block.</p> <pre><code>from fastapi import FastAPI, APIRouter\nfrom rasterio._env import get_gdal_config\nfrom titiler.custom.routing import apiroute_factory\n\napp = FastAPI()\nroute_class = apiroute_factory({\"GDAL_DISABLE_READDIR_ON_OPEN\": \"FALSE\"})\nrouter = APIRouter(route_class=route_class)\n\n@router.get(\"/simple\")\ndef simple():\n    \"\"\"should return FALSE.\"\"\"\n    res = get_gdal_config(\"GDAL_DISABLE_READDIR_ON_OPEN\")\n    return {\"env\": res}\n\napp.include_router(router)\n</code></pre> <p>Note: This has only be tested for python 3.6 and 3.7.</p> </li> </ul>"},{"location":"release-notes/#010-alpha3-2020-09-03","title":"0.1.0-alpha.3 (2020-09-03)","text":"<ul> <li>add custom <code>url_for</code> method in TilerFactory to retrieve <code>prefixed</code> endpoint URL (#95)</li> <li>remove magic <code>titiler.dependencies.PathParams</code> mosaicid path translation, where a user could pass <code>url=mosaicid://</code> to the endpoint.</li> <li> <p>switch to <code>pydantic.BaseSettings</code> for FastAPI application setting management.</p> <p>List of Settings:</p> <pre><code>name: str = \"titiler\"\ncors_origins: str = \"*\"\ncachecontrol: str = \"public, max-age=3600\"\n</code></pre> </li> </ul> <p>API Settings can now be set by adding a <code>.env</code> file in your local project or by setting environment variables (e.g <code>API_CORS_ORIGIN=\"https://mywebsite.com/*\"</code>)</p>"},{"location":"release-notes/#010-alpha2-2020-09-01","title":"0.1.0-alpha.2 (2020-09-01)","text":"<ul> <li>add Transform and CRS information in <code>/part</code> GeoTIFF output</li> <li>pin rio-tiler-crs to <code>&gt;=3.0b4,&lt;3.1</code> and cogeo-mosaic to <code>&gt;=3.0a10,&lt;3.1</code></li> </ul>"},{"location":"release-notes/#010-alpha1-2020-09-01","title":"0.1.0-alpha.1 (2020-09-01)","text":"<ul> <li>rename titiler.models.cog.py to titiler.models.dataset.py</li> <li>remove cog* prefix to Bounds, Info and Metadata models</li> <li>allow Union[str, int] for key in Metadata.statistics (as defined in rio-tiler-pds)</li> </ul> <p>e.g Create a Landsat 8 Tiler <pre><code>from titiler.endpoints.factory import TilerFactory, MosaicTilerFactory\nfrom titiler.dependencies import BandsParams\n\nfrom rio_tiler_pds.landsat.aws.landsat8 import L8Reader  # Not in TiTiler dependencies\n\nfrom fastapi import FastAPI\n\napp = FastAPI(title=\"Landsat Tiler\", openapi_url=\"/api/v1/openapi.json\")\nscene = TilerFactory(\n    reader=L8Reader, additional_dependency=BandsParams, router_prefix=\"scenes\"\n)\nmosaic = MosaicTilerFactory(\n    dataset_reader=L8Reader,\n    additional_dependency=BandsParams,\n    add_update=False,\n    add_create=False,\n    router_prefix=\"mosaic\",\n)\napp.include_router(scene.router, prefix=\"/scenes\", tags=[\"Scenes\"])\napp.include_router(mosaic.router, prefix=\"/mosaic\", tags=[\"Mosaic\"])\n</code></pre></p>"},{"location":"release-notes/#01a0-2020-08-31","title":"0.1a0 (2020-08-31)","text":"<p>First release on pypi</p>"},{"location":"release-notes/#tiler-factory","title":"Tiler Factory","text":"<p>For this release we created new Tiler Factories class which handle creation of FastAPI routers for a given rio_tiler Readers.</p> <pre><code>from titiler.endpoints.factory import TilerFactory\nfrom rio_tiler.io import COGReader, STACReader\n\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\ncog = TilerFactory()\napp.include_router(cog.router, tags=[\"Cloud Optimized GeoTIFF\"])\n</code></pre>"},{"location":"release-notes/#readers-tilematrixsets","title":"Readers / TileMatrixSets","text":"<p>The <code>titiler.endpoints.factory.TilerFactory</code> class will create a tiler with <code>Web Mercator</code> as uniq supported Tile Matrix Set.</p> <p>For other TMS support, tiler needs to be created with <code>titiler.endpoints.factory.TMSTilerFactory</code> and with a TMS friendly reader (e.g <code>rio_tiler_crs.COGReader</code>).</p> <p>Simple tiler with only Web Mercator support <pre><code>from rio_tiler.io import COGReader\n\nfrom titiler.endpoints import factory\nfrom titiler.dependencies import WebMercatorTMSParams\n\napp = factory.TilerFactory(reader=COGReader)\nassert app.tms_dependency == WebMercatorTMSParams\n</code></pre></p> <p>Tiler with more TMS support (from morecantile) <pre><code>from rio_tiler_crs import COGReader\n\nfrom titiler.endpoints import factory\nfrom titiler.dependencies import TMSParams\n\napp = factory.TMSTilerFactory(reader=COGReader)\nassert app.tms_dependency == TMSParams\n</code></pre></p>"},{"location":"release-notes/#other-changes","title":"Other changes","text":"<ul> <li>add mosaic support  (#17 author @geospatial-jeff)</li> <li>update to rio-tiler-crs&gt;=3.0b* and rio-tiler&gt;=2.0b*</li> <li>Pin fastapi version to 0.60.1</li> <li>Remove titiler.core in favor of starlette settings (#55, author @geospatial-jeff)</li> <li>Add fastapi exception handlers (#56, author @geospatial-jeff)</li> <li>Remove intermediary routers (#57, author @geospatial-jeff)</li> <li>Remove /titiler/api submodule (e.g titiler.api.utils -&gt; titiler.utils)</li> <li>Add Cache-Control middleware. Endpoints do not define any cache-control headers. (part of #43, co-author with @geospatial-jeff)</li> <li>Add 'X-Assets' in response headers for mosaic tiles (#51)</li> <li>add cog validation via rio-cogeo (co-author with @geospatial-jeff, #37)</li> </ul>"},{"location":"release-notes/#breaking-changes","title":"Breaking changes","text":"<ul> <li>default tiler to Web Mercator only</li> <li>removed cache layer for tiles</li> <li>updated html templates</li> </ul> <pre><code>template_dir = pkg_resources.resource_filename(\"titiler\", \"templates\")\ntemplates = Jinja2Templates(directory=template_dir)\n\ncog_template = templates.TemplateResponse(\n    name=\"cog_index.html\",\n    context={\n        \"request\": request,\n        \"tilejson\": request.url_for(\"cog_tilejson\"),\n        \"metadata\": request.url_for(\"cog_metadata\"),\n    },\n    media_type=\"text/html\",\n)\n\nstac_template = templates.TemplateResponse(\n    name=\"stac_index.html\",\n    context={\n        \"request\": request,\n        \"tilejson\": request.url_for(\"stac_tilejson\"),\n        \"metadata\": request.url_for(\"stac_info\"),\n    },\n    media_type=\"text/html\",\n)\n</code></pre>"},{"location":"release-notes/#pre-pypi-releases","title":"Pre Pypi releases","text":""},{"location":"release-notes/#212-2020-06-24","title":"2.1.2 (2020-06-24)","text":"<ul> <li>add <code>width</code> &amp; <code>height</code> parameters in API docs to force output size for part/preview endpoints.</li> <li>add <code>resampling_method</code> in API docs.</li> </ul> <p>link: developmentseed/titiler@725da5f</p>"},{"location":"release-notes/#211-2020-06-22","title":"2.1.1 (2020-06-22)","text":"<ul> <li>add minimum fastapi version (0.54.0) and update docker config</li> </ul> <p>link: developmentseed/titiler@95b98a3</p>"},{"location":"release-notes/#210-2020-06-11","title":"2.1.0 (2020-06-11)","text":"<ul> <li>add <code>/preview</code>, <code>/crop</code>, <code>/point</code> endpoints</li> </ul> <p>link: developmentseed/titiler@8b63fc6</p>"},{"location":"release-notes/#200-2020-06-09","title":"2.0.0 (2020-06-09)","text":"<ul> <li>support STAC items (#16)</li> <li>better API documentation via response models</li> <li>update UI (<code>/stac/viewer</code>, <code>/cog/viewer</code>)</li> <li>re-order OpenAPI route tags</li> <li>update documentation</li> </ul> <p>link: developmentseed/titiler@fa2cb78</p>"},{"location":"release-notes/#100-2020-06-04","title":"1.0.0 (2020-06-04)","text":"<p>Initial release</p> <p>link: developmentseed/titiler@f4fdc02</p>"},{"location":"security/","title":"Security Policy","text":""},{"location":"security/#reporting-a-vulnerability","title":"Reporting a Vulnerability","text":"<p>If you find any vulnerabilities in <code>titiler</code>, don't hesitate to report them.</p> <ol> <li>Use GitHub's security reporting tools.</li> </ol> <p>see docs.github.com/en/code-security/security-advisories/guidance-on-reporting-and-writing-information-about-vulnerabilities/privately-reporting-a-security-vulnerability#privately-reporting-a-security-vulnerability</p> <ol> <li>Describe the vulnerability.</li> </ol> <p>If you have a fix, that is most welcome -- please attach or summarize it in your message!</p> <ol> <li>We will evaluate the vulnerability and, if necessary, release a fix or mitigating steps to address it. We will contact you to let you know the outcome, and will credit you in the report.</li> </ol> <p>Please do not disclose the vulnerability publicly until a fix is released!</p> <ol> <li>Once we have either a) published a fix, or b) declined to address the vulnerability for whatever reason, you are free to publicly disclose it.</li> </ol>"},{"location":"security/#gdal","title":"GDAL","text":"<p><code>TiTiler</code> is built on top of Rasterio which is a python wrapper for the GDAL C++ library. At the time of writing, GDAL is responsible for most of the I/O and thus is where vulnerabilities could be harmful. For any <code>I/O</code> issues please first check GDAL documentation.</p>"},{"location":"security/#gdal-vrt-driver","title":"GDAL VRT Driver","text":"<p>There is a known security vulnerability with the VRT Driver:</p> <p>It can be used to access any valid GDAL dataset. If a hostile party, with knowledge of the location on the filesystem of a valid GDAL dataset, convinces a user to run gdal_translate a VRT file and give it back the result, it might be able to steal data. That could potentially be able for a web service accepting data from the user, converting it, and sending back the result.</p> <p>see gdal.org/en/stable/user/security.html#gdal-vrt-driver</p> <p>Thus we recommend deploying titiler in infrastructure with limited access to the filesystem. Users can also <code>disable</code> the VRT driver completely by using <code>GDAL_SKIP=VRT</code> environment variable.</p> <p>In GDAL 3.12, new environment variables might be introduced to enable more control over the VRT driver: OSGeo/gdal!12669</p>"},{"location":"security/#limit-sources-host","title":"Limit source's host","text":"<p>If users want to limit the sources that the application can access, they can also create custom <code>path_dependency</code> such as this one which limits valid sources to a list of known hosts:</p> <pre><code>from urllib.parse import urlparse\n\nfrom typing import Annotated\nfrom titiler.core.factory import TilerFactory\nfrom titiler.core.errors import DEFAULT_STATUS_CODES, add_exception_handlers\n\nfrom fastapi import FastAPI, Query, HTTPException\n\n# List of known host where dataset can be read from\nknown_host = [\n   \"devseed.org\",\n]\n\ndef DatasetPathParams(url: Annotated[str, Query(description=\"Dataset URL\")]) -&gt; str:\n   \"\"\"Create dataset path from args\"\"\"\n   # validate Dataset host\n   parsed = urlparse(url)\n   if parsed.netloc not in known_host:\n      raise HTTPException(\n         status_code=400,\n         detail=\"Nope, this is not a valid File - Please Try Again\",\n      )\n\n   return url\n\n\napp = FastAPI(title=\"My simple app\")\napp.include_router(TilerFactory(path_dependency=DatasetPathParams).router)\n\nadd_exception_handlers(app, DEFAULT_STATUS_CODES)\n</code></pre>"},{"location":"advanced/APIRoute_and_environment_variables/","title":"APIRoute and environment variables","text":"<p>Important</p> <p>This has been deprecated. You can now pass <code>environment_dependency=lambda: {\"GDAL_DISABLE_READDIR_ON_OPEN\":\"FALSE\"}</code> to the Tiler Factory. This will be passed to a <code>rasterio.Env()</code> context manager on top of all gdal related blocks.</p> <pre><code>from titiler.core.factory import TilerFactory\ncog = TilerFactory(\n    reader=COGReader,\n    router_prefix=\"cog\",\n    environment_dependency=lambda: {\"GDAL_DISABLE_READDIR_ON_OPEN\":\"FALSE\"},\n)\n</code></pre> <p>Sometimes, specifically when using GDAL, it can be useful to have environment variables set for certain endpoints (e.g. when using Landsat data on AWS you need <code>GDAL_DISABLE_READDIR_ON_OPEN=FALSE</code> but you don't want this environment variable set for other endpoints). To be able to do this we created a custom APIRoute class which wraps classic fastapi APIRoute with a <code>rasterio.Env()</code> block: github.com/developmentseed/titiler/blob/8a7127ca56631c2c327713d99e80285048c3aa6c/titiler/custom/routing.py#L13-L41</p> <p>Example:     <pre><code>from fastapi import FastAPI, APIRouter\nfrom rasterio._env import get_gdal_config\nfrom titiler.core.routing import apiroute_factory\nfrom titiler.core.factory import TilerFactory\n\napp = FastAPI()\nroute_class = apiroute_factory({\"GDAL_DISABLE_READDIR_ON_OPEN\": \"FALSE\"})\nrouter = APIRouter(route_class=route_class)\n\ntiler = TilerFactory(router=router)\n\n@router.get(\"/simple\")\ndef simple():\n    \"\"\"should return FALSE.\"\"\"\n    res = get_gdal_config(\"GDAL_DISABLE_READDIR_ON_OPEN\")\n    return {\"env\": res}\n\napp.include_router(router)\n</code></pre></p> <p>Important</p> <p>This has only be tested for python 3.6 and 3.7.</p>"},{"location":"advanced/Extensions/","title":"Extensions","text":"<p>Starting with <code>titiler&gt;=0.11</code>, we added a new titiler package <code>titiler.extensions</code> which aim to ease the addition of <code>optional</code> endpoints to factories.</p> <p>In <code>titiler.core.factory.BaseTilerFactory</code> class, we've added a new attribute: <code>extensions: List[FactoryExtension] = field(default_factory=list)</code>. The <code>list</code> of extension will then be used in the <code>post-init</code> step such as:</p> <pre><code>def __post_init__(self):\n    \"\"\"Post Init: register route and configure specific options.\"\"\"\n    # Register endpoints\n    self.register_routes()\n\n    # Register Extensions\n    for ext in self.extensions:\n        ext.register(self)\n\n    # Update endpoints dependencies\n    for scopes, dependencies in self.route_dependencies:\n        self.add_route_dependencies(scopes=scopes, dependencies=dependencies)\n</code></pre> <p>We defined extension using an Abstract Base Class to make sure they implement a <code>register</code> method:</p> <pre><code>@dataclass\nclass FactoryExtension(metaclass=abc.ABCMeta):\n    \"\"\"Factory Extension.\"\"\"\n\n    @abc.abstractmethod\n    def register(self, factory: \"BaseTilerFactory\"):\n        \"\"\"Register extension to the factory.\"\"\"\n        ...\n</code></pre>"},{"location":"advanced/Extensions/#available-extensions","title":"Available extensions","text":""},{"location":"advanced/Extensions/#titilerextensionscogvalidateextension","title":"titiler.extensions.cogValidateExtension","text":"<ul> <li>Goal: adds a <code>/validate</code> endpoint which return the content of rio-cogeo <code>info</code> method</li> <li>Additional requirements: <code>titiler.extensions[\"cogeo\"]</code> (installs <code>rio-cogeo</code>)</li> </ul>"},{"location":"advanced/Extensions/#titilerextensionscogviewerextension","title":"titiler.extensions.cogViewerExtension","text":"<ul> <li>Goal: adds a <code>/viewer</code> endpoint which return an HTML viewer for simple COGs</li> </ul>"},{"location":"advanced/Extensions/#titilerextensionsstacviewerextension","title":"titiler.extensions.stacViewerExtension","text":"<ul> <li>Goal: adds a <code>/viewer</code> endpoint which return an HTML viewer for STAC item</li> </ul>"},{"location":"advanced/Extensions/#titilerextensionsstacextension","title":"titiler.extensions.stacExtension","text":"<ul> <li>Goal: adds a <code>/stac</code> endpoint which return an HTML viewer for STAC item</li> <li>Additional requirements: <code>titiler.extensions[\"stac\"]</code> (installs <code>rio-stac</code>)</li> </ul>"},{"location":"advanced/Extensions/#titilerextensionswmsextension","title":"titiler.extensions.wmsExtension","text":"<ul> <li>Goal: adds a <code>/wms</code> endpoint to support OGC WMS specification (<code>GetCapabilities</code> and <code>GetMap</code>)</li> </ul>"},{"location":"advanced/Extensions/#titilerextensionsstacrenderextenstion","title":"titiler.extensions.stacRenderExtenstion","text":"<ul> <li>Goal: adds <code>/render</code> and <code>/render/{render_id}</code> endpoints which return the contents of STAC render extension and links to tileset.json and WMTS service</li> </ul>"},{"location":"advanced/Extensions/#titilerxarraydatasetmetadataextension","title":"titiler.xarray.DatasetMetadataExtension","text":"<ul> <li>Goal: adds <code>/dataset/</code>, <code>/dataset/keys</code> and <code>/datasets/dict</code> endpoints which return metadata about a multidimensional Dataset (not a DataArray)</li> </ul>"},{"location":"advanced/Extensions/#how-to","title":"How To","text":""},{"location":"advanced/Extensions/#use-extensions","title":"Use extensions","text":"<p>Extensions must be set at TilerFactory's creation using the <code>extensions=</code> options.</p> <pre><code>from fastapi import FastAPI\nfrom titiler.core.factory import TilerFactory\nfrom titiler.extensions import cogValidateExtension\n\n# Create a FastAPI application\napp = FastAPI(description=\"A lightweight Cloud Optimized GeoTIFF tile server\")\n\n# Create a set of endpoints using TiTiler TilerFactory\ntiler = TilerFactory(\n    router_prefix=\"/cog\",\n    extensions=[\n        cogValidateExtension()  # the cogeoExtension will add a rio-cogeo /validate endpoint\n    ]\n)\n\n# Register endpoints to the application\napp.include_router(tiler.router, prefix=\"/cog\")\n</code></pre>"},{"location":"advanced/Extensions/#create-your-own","title":"Create your own","text":"<pre><code>from dataclasses import dataclass, field\nfrom typing import Tuple, List, Optional\nimport rasterio\nfrom starlette.responses import Response\nfrom fastapi import Depends, FastAPI, Query\nfrom titiler.core.factory import TilerFactory, FactoryExtension\nfrom titiler.core.dependencies import ImageRenderingParams\nfrom titiler.core.factory import TilerFactory\nfrom titiler.core.resources.enums import ImageType\n\n\n@dataclass\nclass thumbnailExtension(FactoryExtension):\n    \"\"\"Add endpoint to a TilerFactory.\"\"\"\n\n    # Set some options\n    max_size: int = field(default=128)\n\n    # Register method is mandatory and must take a TilerFactory object as input\n    def register(self, factory: TilerFactory):\n        \"\"\"Register endpoint to the tiler factory.\"\"\"\n\n        # register an endpoint to the factory's router\n        @factory.router.get(\n            \"/thumbnail\",\n            responses={\n                200: {\n                    \"content\": {\n                        \"image/png\": {},\n                        \"image/jpeg\": {},\n                    },\n                    \"description\": \"Return an image.\",\n                }\n            },\n            response_class=Response,\n        )\n        def thumbnail(\n            # we can reuse the factory dependency\n            src_path: str = Depends(factory.path_dependency),\n            reader_params=Depends(factory.reader_dependency),\n            layer_params=Depends(factory.layer_dependency),\n            dataset_params=Depends(factory.dataset_dependency),\n            post_process=Depends(factory.process_dependency),\n            colormap=Depends(factory.colormap_dependency),\n            render_params=Depends(factory.render_dependency),\n            env=Depends(factory.environment_dependency),\n        ):\n            with rasterio.Env(**env):\n                with factory.reader(src_path, **reader_params.as_dict()) as src:\n                    image = src.preview(\n                        max_size=self.max_size,\n                        **layer_params.as_dict(),\n                        **dataset_params.as_dict(),\n                    )\n\n            if post_process:\n                image = post_process(image)\n\n            format = ImageType.jpeg if image.mask.all() else ImageType.png\n\n            if post_process:\n                image = post_process(image)\n\n            content, media_type = factory.render_func(\n                image,\n                colormap=colormap,\n                **render_params.as_dict(),\n            )\n\n            return Response(content, media_type=media_type)\n\n# Use it\napp = FastAPI()\ntiler = TilerFactory(\n    extensions=[\n        thumbnailExtension(max_size=64)\n    ]\n)\napp.include_router(tiler.router)\n</code></pre>"},{"location":"advanced/customization/","title":"Customization","text":"<p><code>TiTiler</code> is designed to help users customize input/output for each endpoint. This section goes over some simple customization examples.</p>"},{"location":"advanced/customization/#custom-colormap","title":"Custom Colormap","text":"<p>Add user defined colormap to the default colormaps provided by rio-tiler</p> <pre><code>from fastapi import FastAPI\n\nfrom rio_tiler.colormap import cmap as default_cmap\n\nfrom titiler.core.dependencies import create_colormap_dependency\nfrom titiler.core.factory import TilerFactory\n\n\napp = FastAPI(title=\"My simple app with custom TMS\")\n\ncmap_values = {\n    \"cmap1\": {6: (4, 5, 6, 255)},\n}\n# add custom colormap `cmap1` to the default colormaps\ncmap = default_cmap.register(cmap_values)\nColorMapParams = create_colormap_dependency(cmap)\n\n\ncog = TilerFactory(colormap_dependency=ColorMapParams)\napp.include_router(cog.router)\n</code></pre>"},{"location":"advanced/customization/#custom-datasetpathparams-for-reader_dependency","title":"Custom DatasetPathParams for <code>reader_dependency</code>","text":"<p>One common customization could be to create your own <code>path_dependency</code>. This dependency is used on all endpoint and pass inputs to the Readers (MosaicBackend, COGReader, STACReader...).</p> <p>Here an example which allow a mosaic to be passed by a <code>mosaic name</code> instead of a full S3 url.</p> <pre><code>import os\nimport re\n\nfrom fastapi import FastAPI, HTTPException, Query\n\nfrom titiler.mosaic.factory import MosaicTilerFactory\n\n\nMOSAIC_BACKEND = os.getenv(\"TITILER_MOSAIC_BACKEND\")\nMOSAIC_HOST = os.getenv(\"TITILER_MOSAIC_HOST\")\n\n\ndef MosaicPathParams(\n    mosaic: str = Query(..., description=\"mosaic name\")\n) -&gt; str:\n    \"\"\"Create dataset path from args\"\"\"\n    # mosaic name should be in form of `{user}.{layername}`\n    if not re.match(self.mosaic, r\"^[a-zA-Z0-9-_]{1,32}\\.[a-zA-Z0-9-_]{1,32}$\"):\n        raise HTTPException(\n            status_code=400,\n                detail=f\"Invalid mosaic name {self.input}.\",\n            )\n\n        return f\"{MOSAIC_BACKEND}{MOSAIC_HOST}/{self.input}.json.gz\"\n\n\napp = FastAPI()\nmosaic = MosaicTilerFactory(path_dependency=MosaicPathParams)\napp.include_router(mosaic.router)\n</code></pre> <p>The endpoint url will now look like: <code>{endpoint}/mosaic/tilejson.json?mosaic=vincent.mosaic</code></p>"},{"location":"advanced/customization/#custom-tms","title":"Custom TMS","text":"<pre><code>from morecantile import tms, TileMatrixSet\nfrom pyproj import CRS\n\nfrom titiler.core.factory import TilerFactory\n\n# 1. Create Custom TMS\nEPSG6933 = TileMatrixSet.custom(\n    (-17357881.81713629, -7324184.56362408, 17357881.81713629, 7324184.56362408),\n    CRS.from_epsg(6933),\n    identifier=\"EPSG6933\",\n    matrix_scale=[1, 1],\n)\n\n# 2. Register TMS\ntms = tms.register([EPSG6933])\n\n# 3. Create Tiler\nCOGTilerWithCustomTMS = TilerFactory(supported_tms=tms)\n</code></pre>"},{"location":"advanced/customization/#add-a-mosaicjson-creation-endpoint","title":"Add a MosaicJSON creation endpoint","text":"<pre><code>from dataclasses import dataclass\nfrom typing import List, Optional\n\nfrom titiler.mosaic.factory import MosaicTilerFactory\nfrom titiler.core.errors import BadRequestError\nfrom cogeo_mosaic.mosaic import MosaicJSON\nfrom cogeo_mosaic.utils import get_footprints\nimport rasterio\n\nfrom pydantic import BaseModel\n\n\n# Models from POST/PUT Body\nclass CreateMosaicJSON(BaseModel):\n    \"\"\"Request body for MosaicJSON creation\"\"\"\n\n    files: List[str]              # Files to add to the mosaic\n    url: str                      # path where to save the mosaicJSON\n    minzoom: Optional[int] = None\n    maxzoom: Optional[int] = None\n    max_threads: int = 20\n    overwrite: bool = False\n\n\nclass UpdateMosaicJSON(BaseModel):\n    \"\"\"Request body for updating an existing MosaicJSON\"\"\"\n\n    files: List[str]              # Files to add to the mosaic\n    url: str                      # path where to save the mosaicJSON\n    max_threads: int = 20\n    add_first: bool = True\n\n\n@dataclass\nclass CustomMosaicFactory(MosaicTilerFactory):\n\n    def register_routes(self):\n        \"\"\"Update the class method to add create/update\"\"\"\n        super().register_routes()\n        # new methods/endpoint\n        self.create()\n        self.update()\n\n    def create(self):\n        \"\"\"Register / (POST) Create endpoint.\"\"\"\n\n        @self.router.post(\n            \"\", response_model=MosaicJSON, response_model_exclude_none=True\n        )\n        def create(\n            body: CreateMosaicJSON,\n            env=Depends(self.environment_dependency),\n        ):\n            \"\"\"Create a MosaicJSON\"\"\"\n            # Write can write to either a local path, a S3 path...\n            # See https://developmentseed.org/cogeo-mosaic/advanced/backends/ for the list of supported backends\n\n            # Create a MosaicJSON file from a list of URL\n            mosaic = MosaicJSON.from_urls(\n                body.files,\n                minzoom=body.minzoom,\n                maxzoom=body.maxzoom,\n                max_threads=body.max_threads,\n            )\n\n            # Write the MosaicJSON using a cogeo-mosaic backend\n            with rasterio.Env(**env):\n                with self.reader(\n                    body.url, mosaic_def=mosaic, reader=self.dataset_reader\n                ) as mosaic:\n                    try:\n                        mosaic.write(overwrite=body.overwrite)\n                    except NotImplementedError:\n                        raise BadRequestError(\n                            f\"{mosaic.__class__.__name__} does not support write operations\"\n                        )\n                    return mosaic.mosaic_def\n\n    def update(self):\n        \"\"\"Register / (PUST) Update endpoint.\"\"\"\n\n        @self.router.put(\n            \"\", response_model=MosaicJSON, response_model_exclude_none=True\n        )\n        def update_mosaicjson(\n            body: UpdateMosaicJSON,\n            env=Depends(self.environment_dependency),\n        ):\n            \"\"\"Update an existing MosaicJSON\"\"\"\n            with rasterio.Env(**env):\n                with self.reader(body.url, reader=self.dataset_reader) as mosaic:\n                    features = get_footprints(body.files, max_threads=body.max_threads)\n                    try:\n                        mosaic.update(features, add_first=body.add_first, quiet=True)\n                    except NotImplementedError:\n                        raise BadRequestError(\n                            f\"{mosaic.__class__.__name__} does not support update operations\"\n                        )\n                    return mosaic.mosaic_def\n</code></pre>"},{"location":"advanced/dependencies/","title":"Dependencies","text":"<p>If you are new to the concept of Dependency Injection, please read this awesome tutorial: fastapi.tiangolo.com/tutorial/dependencies/</p> <p>In titiler <code>Factories</code>, we use the dependencies to define the inputs for each endpoint (and thus the OpenAPI documentation).</p> <p>Example: <pre><code>from dataclasses import dataclass\nfrom fastapi import Depends, FastAPI, Query\nfrom titiler.core.dependencies import DefaultDependency\nfrom typing_extensions import Annotated\nfrom rio_tiler.io import Reader\n\n@dataclass\nclass ImageParams(DefaultDependency):\n    max_size: Annotated[\n        int, Query(description=\"Maximum image size to read onto.\")\n    ] = 1024\n\napp = FastAPI()\n\n# Simple preview endpoint\n@app.get(\"/preview.png\")\ndef preview(\n    url: str = Query(..., description=\"data set URL\"),\n    params: ImageParams = Depends(),\n):\n    with Reader(url) as cog:\n        img = cog.preview(**params.as_dict())  # we use `DefaultDependency().as_dict()` to pass only non-None parameters\n        # or\n        img = cog.preview(max_size=params.max_size)\n    ...\n</code></pre></p> <p>Important</p> <p>In the example above, we create a custom <code>ImageParams</code> dependency which will then be injected to the <code>preview</code> endpoint to add  max_size, height and width query string parameters.</p> <p>Using <code>titiler.core.dependencies.DefaultDependency</code>, we can use <code>.as_dict(exclude_none=True/False)</code> method to <code>unpack</code> the object parameters. This can be useful if method or reader do not take the same parameters.</p>"},{"location":"advanced/dependencies/#titilercore","title":"titiler.core","text":""},{"location":"advanced/dependencies/#assetsparams","title":"AssetsParams","text":"<p>Define <code>assets</code>.</p> Name Type Required Default assets Query (str) No None <pre><code>@dataclass\nclass AssetsParams(DefaultDependency):\n    \"\"\"Assets parameters.\"\"\"\n\n    assets: List[str] = Query(\n        None,\n        title=\"Asset names\",\n        description=\"Asset's names.\",\n        openapi_examples={\n            \"user-provided\": {\"value\": None},\n            \"one-asset\": {\n                \"description\": \"Return results for asset `data`.\",\n                \"value\": [\"data\"],\n            },\n            \"multi-assets\": {\n                \"description\": \"Return results for assets `data` and `cog`.\",\n                \"value\": [\"data\", \"cog\"],\n            },\n        },\n    )\n</code></pre>"},{"location":"advanced/dependencies/#assetsbidxparams","title":"AssetsBidxParams","text":"<p>Define <code>assets</code> with option of <code>per-asset</code> expression with <code>asset_expression</code> option.</p> Name Type Required Default assets Query (str) No None asset_indexes Query (str) No None asset_expression Query (str) No False <pre><code>@dataclass\nclass AssetsBidxParams(AssetsParams):\n    \"\"\"Assets, Asset's band Indexes and Asset's band Expression parameters.\"\"\"\n\n    asset_indexes: Annotated[\n        Optional[Sequence[str]],\n        Query(\n            title=\"Per asset band indexes\",\n            description=\"Per asset band indexes\",\n            alias=\"asset_bidx\",\n            openapi_examples={\n                \"user-provided\": {\"value\": None},\n                \"one-asset\": {\n                    \"description\": \"Return indexes 1,2,3 of asset `data`.\",\n                    \"value\": [\"data|1;2;3\"],\n                },\n                \"multi-assets\": {\n                    \"description\": \"Return indexes 1,2,3 of asset `data` and indexes 1 of asset `cog`\",\n                    \"value\": [\"data|1;2;3\", \"cog|1\"],\n                },\n            },\n        ),\n    ] = None\n\n    asset_expression: Annotated[\n        Optional[Sequence[str]],\n        Query(\n            title=\"Per asset band expression\",\n            description=\"Per asset band expression\",\n            openapi_examples={\n                \"user-provided\": {\"value\": None},\n                \"one-asset\": {\n                    \"description\": \"Return results for expression `b1*b2+b3` of asset `data`.\",\n                    \"value\": [\"data|b1*b2+b3\"],\n                },\n                \"multi-assets\": {\n                    \"description\": \"Return results for expressions `b1*b2+b3` for asset `data` and `b1+b3` for asset `cog`.\",\n                    \"value\": [\"data|b1*b2+b3\", \"cog|b1+b3\"],\n                },\n            },\n        ),\n    ] = None\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if self.asset_indexes:\n            self.asset_indexes: Dict[str, Sequence[int]] = {  # type: ignore\n                idx.split(\"|\")[0]: list(map(int, idx.split(\"|\")[1].split(\",\")))\n                for idx in self.asset_indexes\n            }\n\n        if self.asset_expression:\n            self.asset_expression: Dict[str, str] = {  # type: ignore\n                idx.split(\"|\")[0]: idx.split(\"|\")[1] for idx in self.asset_expression\n            }\n</code></pre>"},{"location":"advanced/dependencies/#assetsbidxexprparams","title":"AssetsBidxExprParams","text":"<p>Define <code>assets</code>.</p> Name Type Required Default assets Query (str) No* None expression Query (str) No* None asset_indexes Query (str) No None asset_as_band Query (bool) No False <p>* <code>assets</code> or <code>expression</code> is required.</p> <pre><code>@dataclass\nclass AssetsBidxExprParams(AssetsParams):\n    \"\"\"Assets, Expression and Asset's band Indexes parameters.\"\"\"\n\n    expression: Annotated[\n        Optional[str],\n        Query(\n            title=\"Band Math expression\",\n            description=\"Band math expression between assets\",\n            openapi_examples={\n                \"user-provided\": {\"value\": None},\n                \"simple\": {\n                    \"description\": \"Return results of expression between assets.\",\n                    \"value\": \"asset1_b1 + asset2_b1 / asset3_b1\",\n                },\n            },\n        ),\n    ] = None\n\n    asset_indexes: Annotated[\n        Optional[Sequence[str]],\n        Query(\n            title=\"Per asset band indexes\",\n            description=\"Per asset band indexes (coma separated indexes)\",\n            alias=\"asset_bidx\",\n            openapi_examples={\n                \"user-provided\": {\"value\": None},\n                \"one-asset\": {\n                    \"description\": \"Return indexes 1,2,3 of asset `data`.\",\n                    \"value\": [\"data|1,2,3\"],\n                },\n                \"multi-assets\": {\n                    \"description\": \"Return indexes 1,2,3 of asset `data` and indexes 1 of asset `cog`\",\n                    \"value\": [\"data|1,2,3\", \"cog|1\"],\n                },\n            },\n        ),\n    ] = None\n\n    asset_as_band: Annotated[\n        Optional[bool],\n        Query(\n            title=\"Consider asset as a 1 band dataset\",\n            description=\"Asset as Band\",\n        ),\n    ] = None\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if not self.assets and not self.expression:\n            raise MissingAssets(\n                \"assets must be defined either via expression or assets options.\"\n            )\n\n        if self.asset_indexes:\n            self.asset_indexes: Dict[str, Sequence[int]] = {  # type: ignore\n                idx.split(\"|\")[0]: list(map(int, idx.split(\"|\")[1].split(\",\")))\n                for idx in self.asset_indexes\n            }\n</code></pre>"},{"location":"advanced/dependencies/#assetsbidxexprparamsoptional","title":"AssetsBidxExprParamsOptional","text":"<p>Define <code>assets</code>. Without requirement on assets nor expression.</p> Name Type Required Default assets Query (str) No None expression Query (str) No None asset_indexes Query (str) No None asset_as_band Query (bool) No False <pre><code>@dataclass\nclass AssetsBidxExprParamsOptional(AssetsBidxExprParams):\n    \"\"\"Assets, Expression and Asset's band Indexes parameters but with no requirement.\"\"\"\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if self.asset_indexes:\n            self.asset_indexes: Dict[str, Sequence[int]] = {  # type: ignore\n                idx.split(\"|\")[0]: list(map(int, idx.split(\"|\")[1].split(\",\")))\n                for idx in self.asset_indexes\n            }\n</code></pre>"},{"location":"advanced/dependencies/#bandsparams","title":"BandsParams","text":"<p>Define <code>bands</code>.</p> Name Type Required Default bands Query (str) No None <pre><code>@dataclass\nclass BandsParams(DefaultDependency):\n    \"\"\"Band names parameters.\"\"\"\n\n    bands: List[str] = Query(\n        None,\n        title=\"Band names\",\n        description=\"Band's names.\",\n        openapi_examples={\n            \"user-provided\": {\"value\": None},\n            \"one-band\": {\n                \"description\": \"Return results for band `B01`.\",\n                \"value\": [\"B01\"],\n            },\n            \"multi-bands\": {\n                \"description\": \"Return results for bands `B01` and `B02`.\",\n                \"value\": [\"B01\", \"B02\"],\n            },\n        },\n    )\n</code></pre>"},{"location":"advanced/dependencies/#bandsexprparams","title":"BandsExprParams","text":"<p>Define <code>bands</code>.</p> Name Type Required Default bands Query (str) No* None expression Query (str) No* None <p>* <code>bands</code> or <code>expression</code> is required.</p> <pre><code>@dataclass\nclass BandsExprParamsOptional(ExpressionParams, BandsParams):\n    \"\"\"Optional Band names and Expression parameters.\"\"\"\n\n    pass\n</code></pre>"},{"location":"advanced/dependencies/#bandsexprparamsoptional","title":"BandsExprParamsOptional","text":"<p>Define <code>bands</code>.</p> Name Type Required Default bands Query (str) No None expression Query (str) No None <pre><code>@dataclass\nclass BandsExprParamsOptional(ExpressionParams, BandsParams):\n    \"\"\"Optional Band names and Expression parameters.\"\"\"\n\n    pass\n</code></pre>"},{"location":"advanced/dependencies/#bidxparams","title":"<code>BidxParams</code>","text":"<p>Define band indexes.</p> Name Type Required Default bidx Query (int) No None <pre><code>@dataclass\nclass BidxParams(DefaultDependency):\n    \"\"\"Band Indexes parameters.\"\"\"\n\n    indexes: Annotated[\n        Optional[List[int]],\n        Query(\n            title=\"Band indexes\",\n            alias=\"bidx\",\n            description=\"Dataset band indexes\",\n            openapi_examples={\n                \"user-provided\": {\"value\": None},\n                \"one-band\": {\"value\": [1]},\n                \"multi-bands\": {\"value\": [1, 2, 3]},\n            },\n        ),\n    ] = None\n</code></pre>"},{"location":"advanced/dependencies/#expressionparams","title":"<code>ExpressionParams</code>","text":"<p>Define band expression.</p> Name Type Required Default expression Query (str) No None <pre><code>@dataclass\nclass ExpressionParams(DefaultDependency):\n    \"\"\"Expression parameters.\"\"\"\n\n    expression: Annotated[\n        Optional[str],\n        Query(\n            title=\"Band Math expression\",\n            description=\"rio-tiler's band math expression\",\n            openapi_examples={\n                \"user-provided\": {\"value\": None},\n                \"simple\": {\"description\": \"Simple band math.\", \"value\": \"b1/b2\"},\n                \"multi-bands\": {\n                    \"description\": \"Semicolon (;) delimited expressions (band1: b1/b2, band2: b2+b3).\",\n                    \"value\": \"b1/b2;b2+b3\",\n                },\n            },\n        ),\n    ] = None\n</code></pre>"},{"location":"advanced/dependencies/#bidxexprparams","title":"<code>BidxExprParams</code>","text":"<p>Define band indexes or expression.</p> Name Type Required Default bidx Query (int) No None expression Query (str) No None <pre><code>@dataclass\nclass BidxExprParams(ExpressionParams, BidxParams):\n    \"\"\"Band Indexes and Expression parameters.\"\"\"\n\n    pass\n</code></pre>"},{"location":"advanced/dependencies/#colormapparams","title":"<code>ColorMapParams</code>","text":"<p>Colormap options. See titiler.core.dependencies.</p> Name Type Required Default colormap_name Query (str) No None colormap Query (encoded json) No None <pre><code>cmap = {}\n\ndef ColorMapParams(\n    colormap_name: Annotated[  # type: ignore\n        Literal[tuple(cmap.list())],\n        Query(description=\"Colormap name\"),\n    ] = None,\n    colormap: Annotated[\n        Optional[str], Query(description=\"JSON encoded custom Colormap\")\n    ] = None,\n):\n    if colormap_name:\n        return cmap.get(colormap_name)\n\n    if colormap:\n        try:\n            c = json.loads(\n                colormap,\n                object_hook=lambda x: {\n                    int(k): parse_color(v) for k, v in x.items()\n                },\n            )\n\n            # Make sure to match colormap type\n            if isinstance(c, Sequence):\n                c = [(tuple(inter), parse_color(v)) for (inter, v) in c]\n\n            return c\n        except json.JSONDecodeError as e:\n            raise HTTPException(\n                status_code=400, detail=\"Could not parse the colormap value.\"\n            ) from e\n\n    return None\n</code></pre>"},{"location":"advanced/dependencies/#coordcrsparams","title":"CoordCRSParams","text":"<p>Define input Coordinate Reference System.</p> Name Type Required Default crs Query (str) No None <pre><code>def CoordCRSParams(\n    crs: Annotated[\n        Optional[str],\n        Query(\n            alias=\"coord_crs\",\n            description=\"Coordinate Reference System of the input coords. Default to `epsg:4326`.\",\n        ),\n    ] = None,\n) -&gt; Optional[CRS]:\n    \"\"\"Coordinate Reference System Coordinates Param.\"\"\"\n    if crs:\n        return CRS.from_user_input(crs)\n\n    return None\n</code></pre>"},{"location":"advanced/dependencies/#datasetparams","title":"<code>DatasetParams</code>","text":"<p>Overwrite <code>nodata</code> value, apply <code>rescaling</code> and change the <code>I/O</code> or <code>Warp</code> resamplings.</p> Name Type Required Default nodata Query (str, int, float) No None unscale Query (bool) No False resampling Query (str) No 'nearest' reproject Query (str) No 'nearest' <pre><code>@dataclass\nclass DatasetParams(DefaultDependency):\n    \"\"\"Low level WarpedVRT Optional parameters.\"\"\"\n\n    nodata: Annotated[\n        Optional[Union[str, int, float]],\n        Query(\n            title=\"Nodata value\",\n            description=\"Overwrite internal Nodata value\",\n        ),\n    ] = None\n    unscale: Annotated[\n        bool,\n        Query(\n            title=\"Apply internal Scale/Offset\",\n            description=\"Apply internal Scale/Offset. Defaults to `False` in rio-tiler.\",\n        ),\n    ] = False\n    resampling_method: Annotated[\n        Optional[RIOResampling],\n        Query(\n            alias=\"resampling\",\n            description=\"RasterIO resampling algorithm. Defaults to `nearest` in rio-tiler.\",\n        ),\n    ] = None\n    reproject_method: Annotated[\n        Optional[WarpResampling],\n        Query(\n            alias=\"reproject\",\n            description=\"WarpKernel resampling algorithm (only used when doing re-projection). Defaults to `nearest` in rio-tiler.\",\n        ),\n    ] = None\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if self.nodata is not None:\n            self.nodata = numpy.nan if self.nodata == \"nan\" else float(self.nodata)\n\n        if self.unscale is not None:\n            self.unscale = bool(self.unscale)\n</code></pre>"},{"location":"advanced/dependencies/#datasetpathparams","title":"<code>DatasetPathParams</code>","text":"<p>Set dataset path.</p> Name Type Required Default url Query (str) Yes - <pre><code>def DatasetPathParams(\n    url: Annotated[str, Query(description=\"Dataset URL\")]\n) -&gt; str:\n    \"\"\"Create dataset path from args\"\"\"\n    return url\n</code></pre>"},{"location":"advanced/dependencies/#dstcrsparams","title":"DstCRSParams","text":"<p>Define output Coordinate Reference System.</p> Name Type Required Default crs Query (str) No None <pre><code>def DstCRSParams(\n    crs: Annotated[\n        Optional[str],\n        Query(\n            alias=\"dst_crs\",\n            description=\"Output Coordinate Reference System.\",\n        ),\n    ] = None,\n) -&gt; Optional[CRS]:\n    \"\"\"Coordinate Reference System Coordinates Param.\"\"\"\n    if crs:\n        return CRS.from_user_input(crs)\n\n    return None\n</code></pre>"},{"location":"advanced/dependencies/#histogramparams","title":"HistogramParams","text":"<p>Define numpy's histogram options.</p> Name Type Required Default histogram_bins Query (encoded list of Number) No 10 histogram_range Query (encoded list of Number) No None <pre><code>@dataclass\nclass HistogramParams(DefaultDependency):\n    \"\"\"Numpy Histogram options.\"\"\"\n\n    bins: Annotated[\n        Optional[str],\n        Query(\n            alias=\"histogram_bins\",\n            title=\"Histogram bins.\",\n            description=\"\"\"\nDefines the number of equal-width bins in the given range (10, by default).\n\nIf bins is a sequence (comma `,` delimited values), it defines a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform bin widths.\n\nlink: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html\n            \"\"\",\n            openapi_examples={\n                \"user-provided\": {\"value\": None},\n                \"simple\": {\n                    \"description\": \"Defines the number of equal-width bins\",\n                    \"value\": 8,\n                },\n                \"array\": {\n                    \"description\": \"Defines custom bin edges (comma `,` delimited values)\",\n                    \"value\": \"0,100,200,300\",\n                },\n            },\n        ),\n    ] = None\n\n    range: Annotated[\n        Optional[str],\n        Query(\n            alias=\"histogram_range\",\n            title=\"Histogram range\",\n            description=\"\"\"\nComma `,` delimited range of the bins.\n\nThe lower and upper range of the bins. If not provided, range is simply (a.min(), a.max()).\n\nValues outside the range are ignored. The first element of the range must be less than or equal to the second.\nrange affects the automatic bin computation as well.\n\nlink: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html\n            \"\"\",\n            examples=\"0,1000\",\n        ),\n    ] = None\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if self.bins:\n            bins = self.bins.split(\",\")\n            if len(bins) == 1:\n                self.bins = int(bins[0])  # type: ignore\n            else:\n                self.bins = list(map(float, bins))  # type: ignore\n        else:\n            self.bins = 10\n\n        if self.range:\n            self.range = list(map(float, self.range.split(\",\")))  # type: ignore\n</code></pre>"},{"location":"advanced/dependencies/#imagerenderingparams","title":"<code>ImageRenderingParams</code>","text":"<p>Control output image rendering options.</p> Name Type Required Default rescale Query (str, comma delimited Numer) No None color_formula Query (str) No None return_mask Query (bool) No False <pre><code>@dataclass\nclass ImageRenderingParams(DefaultDependency):\n    \"\"\"Image Rendering options.\"\"\"\n\n    rescale: Annotated[\n        Optional[List[str]],\n        Query(\n            title=\"Min/Max data Rescaling\",\n            description=\"comma (',') delimited Min,Max range. Can set multiple time for multiple bands.\",\n            examples=[\"0,2000\", \"0,1000\", \"0,10000\"],  # band 1  # band 2  # band 3\n        ),\n    ] = None\n\n    color_formula: Annotated[\n        Optional[str],\n        Query(\n            title=\"Color Formula\",\n            description=\"rio-color formula (info: https://github.com/mapbox/rio-color)\",\n        ),\n    ] = None\n\n    add_mask: Annotated[\n        Optional[bool],\n        Query(\n            alias=\"return_mask\",\n            description=\"Add mask to the output data. Defaults to `True`\",\n        ),\n    ] = None\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if self.rescale:\n            rescale_array = []\n            for r in self.rescale:\n                parsed = tuple(\n                    map(\n                        float,\n                        r.replace(\" \", \"\").replace(\"[\", \"\").replace(\"]\", \"\").split(\",\"),\n                    )\n                )\n                assert (\n                    len(parsed) == 2\n                ), f\"Invalid rescale values: {self.rescale}, should be of form ['min,max', 'min,max'] or [[min,max], [min, max]]\"\n                rescale_array.append(parsed)\n\n            self.rescale: RescaleType = rescale_array  # Noqa\n</code></pre>"},{"location":"advanced/dependencies/#partfeatureparams","title":"PartFeatureParams","text":"<p>Same as <code>PreviewParams</code> but without default <code>max_size</code>.</p> Name Type Required Default max_size Query (int) No None height Query (int) No None width Query (int) No None <pre><code>@dataclass\nclass PreviewParams(DefaultDependency):\n    \"\"\"Common Preview parameters.\"\"\"\n\n    # NOTE: sizes dependency can either be a Query or a Path Parameter\n    max_size: Annotated[int, Field(description=\"Maximum image size to read onto.\")] = (\n        1024\n    )\n    height: Annotated[\n        Optional[int], Field(description=\"Force output image height.\")\n    ] = None\n    width: Annotated[Optional[int], Field(description=\"Force output image width.\")] = (\n        None\n    )\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if self.width or self.height:\n            self.max_size = None\n</code></pre>"},{"location":"advanced/dependencies/#pixelselectionparams","title":"PixelSelectionParams","text":"<p>In <code>titiler.mosaic</code>, define pixel-selection method to apply.</p> Name Type Required Default pixel_selection Query (str) No 'first' <pre><code>def PixelSelectionParams(\n    pixel_selection: Annotated[  # type: ignore\n        Literal[tuple([e.name for e in PixelSelectionMethod])],\n        Query(description=\"Pixel selection method.\"),\n    ] = \"first\",\n) -&gt; MosaicMethodBase:\n    \"\"\"\n    Returns the mosaic method used to combine datasets together.\n    \"\"\"\n    return PixelSelectionMethod[pixel_selection].value()\n</code></pre>"},{"location":"advanced/dependencies/#previewparams","title":"PreviewParams","text":"<p>Define image output size.</p> Name Type Required Default max_size Query (int) No 1024 height Query (int) No None width Query (int) No None <pre><code>@dataclass\nclass PreviewParams(DefaultDependency):\n    \"\"\"Common Preview parameters.\"\"\"\n\n    max_size: Annotated[int, \"Maximum image size to read onto.\"] = 1024\n    height: Annotated[Optional[int], \"Force output image height.\"] = None\n    width: Annotated[Optional[int], \"Force output image width.\"] = None\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if self.width and self.height:\n            self.max_size = None\n</code></pre>"},{"location":"advanced/dependencies/#statisticsparams","title":"StatisticsParams","text":"<p>Define options for rio-tiler's statistics method.</p> Name Type Required Default categorical Query (bool) No False categories Query (list of Number) No None p Query (list of Number) No [2, 98] <pre><code>@dataclass\nclass StatisticsParams(DefaultDependency):\n    \"\"\"Statistics options.\"\"\"\n\n    categorical: Annotated[\n        Optional[bool],\n        Query(description=\"Return statistics for categorical dataset. Defaults to `False` in rio-tiler\"),\n    ] = None\n    categories: Annotated[\n        Optional[List[Union[float, int]]],\n        Query(\n            alias=\"c\",\n            title=\"Pixels values for categories.\",\n            description=\"List of values for which to report counts.\",\n            examples=[1, 2, 3],\n        ),\n    ] = None\n    percentiles: Annotated[\n        Optional[List[int]],\n        Query(\n            alias=\"p\",\n            title=\"Percentile values\",\n            description=\"List of percentile values (default to [2, 98]).\",\n            examples=[2, 5, 95, 98],\n        ),\n    ] = None\n\n    def __post_init__(self):\n        \"\"\"Set percentiles default.\"\"\"\n        if not self.percentiles:\n            self.percentiles = [2, 98]\n</code></pre>"},{"location":"advanced/dependencies/#tileparams","title":"TileParams","text":"<p>Define <code>buffer</code> and <code>padding</code> to apply at tile creation.</p> Name Type Required Default buffer Query (float) No None padding Query (int) No None <pre><code>@dataclass\nclass TileParams(DefaultDependency):\n    \"\"\"Tile options.\"\"\"\n\n    buffer: Annotated[\n        Optional[float],\n        Query(\n            gt=0,\n            title=\"Tile buffer.\",\n            description=\"Buffer on each side of the given tile. It must be a multiple of `0.5`. Output **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257, 1.0 = 258x258).\",\n        ),\n    ] = None\n\n    padding: Annotated[\n        Optional[int],\n        Query(\n            gt=0,\n            title=\"Tile padding.\",\n            description=\"Padding to apply to each tile edge. Helps reduce resampling artefacts along edges. Defaults to `0`.\",\n        ),\n    ] = None\n</code></pre>"},{"location":"advanced/dependencies/#algorithmdependency","title":"<code>algorithm.dependency</code>","text":"<p>Control which <code>algorithm</code> to apply to the data.</p> <p>See titiler.core.algorithm.</p> Name Type Required Default algorithm Query (str) No None algorithm_params Query (encoded json) No None <pre><code>algorithms = {}\n\ndef post_process(\n    algorithm: Annotated[\n        Literal[tuple(algorithms.keys())],\n        Query(description=\"Algorithm name\"),\n    ] = None,\n    algorithm_params: Annotated[\n        Optional[str],\n        Query(description=\"Algorithm parameter\"),\n    ] = None,\n) -&gt; Optional[BaseAlgorithm]:\n    \"\"\"Data Post-Processing options.\"\"\"\n    kwargs = json.loads(algorithm_params) if algorithm_params else {}\n    if algorithm:\n        try:\n            return algorithms.get(algorithm)(**kwargs)\n\n        except ValidationError as e:\n            raise HTTPException(status_code=400, detail=str(e)) from e\n\n    return None\n</code></pre>"},{"location":"advanced/dependencies/#titilerxarray","title":"titiler.xarray","text":""},{"location":"advanced/dependencies/#xarrayioparams","title":"XarrayIOParams","text":"<p>Define Xarray's <code>open_args</code> to <code>xarray.open_dataset</code>.</p> Name Type Required Default group Query (str) No None decode_times Query (bool) No None <pre><code>@dataclass\nclass XarrayIOParams(DefaultDependency):\n    \"\"\"Dataset IO Options.\"\"\"\n\n    group: Annotated[\n        Optional[str],\n        Query(\n            description=\"Select a specific zarr group from a zarr hierarchy. Could be associated with a zoom level or dataset.\"\n        ),\n    ] = None\n\n    decode_times: Annotated[\n        Optional[bool],\n        Query(\n            title=\"decode_times\",\n            description=\"Whether to decode times\",\n        ),\n    ] = None\n</code></pre>"},{"location":"advanced/dependencies/#xarraydsparams","title":"XarrayDsParams","text":"<p>Define options to select a variable within a Xarray Dataset.</p> Name Type Required Default variable Query (str) Yes None sel Query (list of str) No None method Query (str) No None <pre><code>@dataclass\nclass XarrayDsParams(DefaultDependency):\n    \"\"\"Xarray Dataset Options.\"\"\"\n\n    variable: Annotated[str, Query(description=\"Xarray Variable name.\")]\n\n    sel: Annotated[\n        Optional[List[SelDimStr]],\n        Query(\n            description=\"Xarray Indexing using dimension names `{dimension}={value}`.\",\n        ),\n    ] = None\n\n    method: Annotated[\n        Optional[Literal[\"nearest\", \"pad\", \"ffill\", \"backfill\", \"bfill\"]],\n        Query(\n            alias=\"sel_method\",\n            description=\"Xarray indexing method to use for inexact matches.\",\n        ),\n    ] = None\n</code></pre>"},{"location":"advanced/dependencies/#xarrayparams","title":"XarrayParams","text":"<p>Combination of <code>XarrayIOParams</code> and <code>XarrayDsParams</code></p> Name Type Required Default group Query (str) No None decode_times Query (bool) No None variable Query (str) Yes None sel Query (list of str) No None method Query (str) No None <pre><code>@dataclass\nclass XarrayParams(XarrayIOParams, XarrayDsParams):\n    \"\"\"Xarray Reader dependency.\"\"\"\n\n    pass\n</code></pre>"},{"location":"advanced/dependencies/#compatxarrayparams","title":"CompatXarrayParams","text":"<p>same as <code>XarrayParams</code> but with optional <code>variable</code> option.</p> Name Type Required Default group Query (str) No None decode_times Query (bool) No None variable Query (str) No None sel Query (list of str) No None method Query (str) No None <pre><code>@dataclass\nclass XarrayParams(XarrayIOParams, XarrayDsParams):\n    \"\"\"Xarray Reader dependency.\"\"\"\n\n    pass\n</code></pre>"},{"location":"advanced/dependencies/#datasetparams_1","title":"DatasetParams","text":"<p>Same as <code>titiler.core.dependencies.DatasetParams</code> but with only <code>nodata</code> and <code>reproject</code></p> Name Type Required Default nodata Query (str, int, float) No None reproject Query (str) No 'nearest' <pre><code>@dataclass\nclass DatasetParams(DefaultDependency):\n    \"\"\"Low level WarpedVRT Optional parameters.\"\"\"\n\n    nodata: Annotated[\n        Optional[Union[str, int, float]],\n        Query(\n            title=\"Nodata value\",\n            description=\"Overwrite internal Nodata value\",\n        ),\n    ] = None\n    reproject_method: Annotated[\n        Optional[WarpResampling],\n        Query(\n            alias=\"reproject\",\n            description=\"WarpKernel resampling algorithm (only used when doing re-projection). Defaults to `nearest`.\",\n        ),\n    ] = None\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if self.nodata is not None:\n            self.nodata = numpy.nan if self.nodata == \"nan\" else float(self.nodata)\n</code></pre>"},{"location":"advanced/dependencies/#partfeatureparams_1","title":"PartFeatureParams","text":"<p>Same as <code>titiler.core.dependencies.PartFeatureParams</code> but with <code>resampling</code> option</p> Name Type Required Default max_size Query (int) No None height Query (int) No None width Query (int) No None resampling Query (str) No 'nearest' <pre><code>@dataclass\nclass PartFeatureParams(DefaultDependency):\n    \"\"\"Common parameters for bbox and feature.\"\"\"\n\n    # NOTE: the part sizes dependency can either be a Query or a Path Parameter\n    max_size: Annotated[\n        Optional[int], Field(description=\"Maximum image size to read onto.\")\n    ] = None\n    height: Annotated[\n        Optional[int], Field(description=\"Force output image height.\")\n    ] = None\n    width: Annotated[Optional[int], Field(description=\"Force output image width.\")] = (\n        None\n    )\n    resampling_method: Annotated[\n        Optional[RIOResampling],\n        Query(\n            alias=\"resampling\",\n            description=\"RasterIO resampling algorithm. Defaults to `nearest`.\",\n        ),\n    ] = None\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if self.width or self.height:\n            self.max_size = None\n</code></pre>"},{"location":"advanced/endpoints_factories/","title":"Endpoints Factories","text":"<p>TiTiler's endpoints factories are helper functions that let users create a FastAPI router (<code>fastapi.APIRouter</code>) with a minimal set of endpoints.</p> <p>Important</p> <p>Most of <code>tiler</code> Factories are built around <code>rio_tiler.io.BaseReader</code>, which defines basic methods to access datasets (e.g COG or STAC). The default reader is <code>Reader</code> for <code>TilerFactory</code> and <code>MosaicBackend</code> for <code>MosaicTilerFactory</code>.</p> <p>Factories classes use dependencies injection to define most of the endpoint options.</p>"},{"location":"advanced/endpoints_factories/#titilercore","title":"titiler.core","text":""},{"location":"advanced/endpoints_factories/#basefactory","title":"BaseFactory","text":"<p>class: <code>titiler.core.factory.BaseFactory</code></p> <p>Most Factories are built from this abstract based class which is used to define commons attributes and utility functions shared between all factories.</p>"},{"location":"advanced/endpoints_factories/#attributes","title":"Attributes","text":"<ul> <li>router: FastAPI router. Defaults to <code>fastapi.APIRouter</code>.</li> <li>router_prefix: Set prefix to all factory's endpoint. Defaults to <code>\"\"</code>.</li> <li>route_dependencies: Additional routes dependencies to add after routes creations. Defaults to <code>[]</code>.</li> <li>extension: TiTiler extensions to register after endpoints creations. Defaults to <code>[]</code>.</li> <li>name: Name of the Endpoints group. Defaults to <code>None</code>.</li> <li>operation_prefix (private): Endpoint's <code>operationId</code> prefix. Defined by <code>self.name</code> or <code>self.router_prefix.replace(\"/\", \".\")</code>.</li> <li>conforms_to: Set of conformance classes the Factory implement</li> </ul>"},{"location":"advanced/endpoints_factories/#methods","title":"Methods","text":"<ul> <li>register_routes: Abstract method which needs to be define by each factories.</li> <li>url_for: Method to construct endpoint URL</li> <li>add_route_dependencies: Add dependencies to routes.</li> </ul>"},{"location":"advanced/endpoints_factories/#tilerfactory","title":"TilerFactory","text":"<p>class: <code>titiler.core.factory.TilerFactory</code></p> <p>Factory meant to create endpoints for single dataset using rio-tiler's <code>Reader</code>.</p>"},{"location":"advanced/endpoints_factories/#attributes_1","title":"Attributes","text":"<ul> <li>reader: Dataset Reader required.</li> <li>reader_dependency: Dependency to control options passed to the reader instance init. Defaults to <code>titiler.core.dependencies.DefaultDependency</code></li> <li>path_dependency: Dependency to use to define the dataset url. Defaults to <code>titiler.core.dependencies.DatasetPathParams</code>.</li> <li>layer_dependency: Dependency to define band indexes or expression. Defaults to <code>titiler.core.dependencies.BidxExprParams</code>.</li> <li>dataset_dependency: Dependency to overwrite <code>nodata</code> value, apply <code>rescaling</code> and change the <code>I/O</code> or <code>Warp</code> resamplings. Defaults to <code>titiler.core.dependencies.DatasetParams</code>.</li> <li>tile_dependency: Dependency to define <code>buffer</code> and <code>padding</code> to apply at tile creation. Defaults to <code>titiler.core.dependencies.TileParams</code>.</li> <li>stats_dependency: Dependency to define options for rio-tiler's statistics method used in <code>/statistics</code> endpoints. Defaults to <code>titiler.core.dependencies.StatisticsParams</code>.</li> <li>histogram_dependency: Dependency to define numpy's histogram options used in <code>/statistics</code> endpoints. Defaults to <code>titiler.core.dependencies.HistogramParams</code>.</li> <li>img_preview_dependency: Dependency to define image size for <code>/preview</code> and <code>/statistics</code> endpoints. Defaults to <code>titiler.core.dependencies.PreviewParams</code>.</li> <li>img_part_dependency: Dependency to define image size for <code>/bbox</code> and <code>/feature</code> endpoints. Defaults to <code>titiler.core.dependencies.PartFeatureParams</code>.</li> <li>process_dependency: Dependency to control which <code>algorithm</code> to apply to the data. Defaults to <code>titiler.core.algorithm.algorithms.dependency</code>.</li> <li>colormap_dependency: Dependency to define the Colormap options. Defaults to <code>titiler.core.dependencies.ColorMapParams</code></li> <li>render_dependency: Dependency to control output image rendering options. Defaults to <code>titiler.core.dependencies.ImageRenderingParams</code></li> <li>environment_dependency: Dependency to define GDAL environment at runtime. Default to <code>lambda: {}</code>.</li> <li>supported_tms: List of available TileMatrixSets. Defaults to <code>morecantile.tms</code>.</li> <li>templates: Jinja2 templates to use in endpoints. Defaults to <code>titiler.core.factory.DEFAULT_TEMPLATES</code>.</li> <li>render_func: Image rendering method. Defaults to <code>titiler.core.utils.render_image</code>.</li> <li>add_preview: Add <code>/preview</code> endpoint to the router. Defaults to <code>True</code>.</li> <li>add_part: Add <code>/bbox</code> and <code>/feature</code> endpoints to the router. Defaults to <code>True</code>.</li> <li>add_viewer: Add <code>/{TileMatrixSetId}/map.html</code> endpoints to the router. Defaults to <code>True</code>.</li> <li>add_ogc_maps: Add <code>/map</code> endoint (OGC Maps API) to the router. Defaults to <code>False</code>.</li> </ul>"},{"location":"advanced/endpoints_factories/#endpoints","title":"Endpoints","text":"<pre><code>from fastapi import FastAPI\n\nfrom titiler.core.factory import TilerFactory\n\n# Create FastAPI application\napp = FastAPI()\n\n# Create router and register set of endpoints\ncog = TilerFactory(\n    add_preview=True,\n    add_part=True,\n    add_viewer=True,\n    add_ogc_maps=True,\n)\n\n# add router endpoint to the main application\napp.include_router(cog.router)\n</code></pre> Method URL Output Description <code>GET</code> <code>/bounds</code> JSON (Bounds) return dataset's bounds <code>GET</code> <code>/info</code> JSON (Info) return dataset's basic info <code>GET</code> <code>/info.geojson</code> GeoJSON (InfoGeoJSON) return dataset's basic info as a GeoJSON feature <code>GET</code> <code>/statistics</code> JSON (Statistics) return dataset's statistics <code>POST</code> <code>/statistics</code> GeoJSON (Statistics) return dataset's statistics for a GeoJSON <code>GET</code> <code>/tiles</code> JSON List of OGC Tilesets available <code>GET</code> <code>/tiles/{tileMatrixSetId}</code> JSON OGC Tileset metadata <code>GET</code> <code>/tiles/{tileMatrixSetId}/{z}/{x}/{y}[@{scale}x][.{format}]</code> image/bin create a web map tile image from a dataset <code>GET</code> <code>/{tileMatrixSetId}/map.html</code> HTML return a simple map viewer Optional <code>GET</code> <code>/{tileMatrixSetId}/tilejson.json</code> JSON (TileJSON) return a Mapbox TileJSON document <code>GET</code> <code>/{tileMatrixSetId}/WMTSCapabilities.xml</code> XML return OGC WMTS Get Capabilities <code>GET</code> <code>/point/{lon},{lat}</code> JSON (Point) return pixel values from a dataset <code>GET</code> <code>/bbox/{minx},{miny},{maxx},{maxy}[/{width}x{height}].{format}</code> image/bin create an image from part of a dataset Optional <code>POST</code> <code>/feature[/{width}x{height}][.{format}]</code> image/bin create an image from a GeoJSON feature Optional <code>GET</code> <code>/preview[/{width}x{height}][.{format}]</code> image/bin create a preview image from a dataset Optional <code>GET</code> <code>/maps</code> image/bin create maps from a dataset Optional"},{"location":"advanced/endpoints_factories/#multibasetilerfactory","title":"MultiBaseTilerFactory","text":"<p>class: <code>titiler.core.factory.MultiBaseTilerFactory</code></p> <p>Custom <code>TilerFactory</code> to be used with <code>rio_tiler.io.MultiBaseReader</code> type readers (e.g <code>rio_tiler.io.STACReader</code>).</p>"},{"location":"advanced/endpoints_factories/#attributes_2","title":"Attributes","text":"<ul> <li>reader: <code>rio_tiler.io.base.MultiBaseReader</code> Dataset Reader required.</li> <li>layer_dependency: Dependency to define assets or expression. Defaults to <code>titiler.core.dependencies.AssetsBidxExprParams</code>.</li> <li>assets_dependency: Dependency to define assets to be used. Defaults to <code>titiler.core.dependencies.AssetsParams</code>.</li> </ul>"},{"location":"advanced/endpoints_factories/#endpoints_1","title":"Endpoints","text":"<pre><code>from fastapi import FastAPI\n\nfrom rio_tiler.io import STACReader  # STACReader is a MultiBaseReader\n\nfrom titiler.core.factory import MultiBaseTilerFactory\n\napp = FastAPI()\nstac = MultiBaseTilerFactory(\n    reader=STACReader,\n    add_preview=True,\n    add_part=True,\n    add_viewer=True,\n    add_ogc_maps=True,\n)\napp.include_router(stac.router)\n</code></pre> Method URL Output Description <code>GET</code> <code>/bounds</code> JSON (Bounds) return dataset's bounds <code>GET</code> <code>/assets</code> JSON return the list of available assets <code>GET</code> <code>/info</code> JSON (Info) return assets basic info <code>GET</code> <code>/info.geojson</code> GeoJSON (InfoGeoJSON) return assets basic info as a GeoJSON feature <code>GET</code> <code>/asset_statistics</code> JSON (Statistics) return per asset statistics <code>GET</code> <code>/statistics</code> JSON (Statistics) return assets statistics (merged) <code>POST</code> <code>/statistics</code> GeoJSON (Statistics) return assets statistics for a GeoJSON (merged) <code>GET</code> <code>/tiles</code> JSON List of OGC Tilesets available <code>GET</code> <code>/tiles/{tileMatrixSetId}</code> JSON OGC Tileset metadata <code>GET</code> <code>/tiles/{tileMatrixSetId}/{z}/{x}/{y}[@{scale}x][.{format}]</code> image/bin create a web map tile image from assets <code>GET</code> <code>/{tileMatrixSetId}/map.html</code> HTML return a simple map viewer Optional <code>GET</code> <code>/{tileMatrixSetId}/tilejson.json</code> JSON (TileJSON) return a Mapbox TileJSON document <code>GET</code> <code>/{tileMatrixSetId}/WMTSCapabilities.xml</code> XML return OGC WMTS Get Capabilities <code>GET</code> <code>/point/{lon},{lat}</code> JSON (Point) return pixel values from assets <code>GET</code> <code>/bbox/{minx},{miny},{maxx},{maxy}[/{width}x{height}].{format}</code> image/bin create an image from part of assets Optional <code>POST</code> <code>/feature[/{width}x{height}][.{format}]</code> image/bin create an image from a geojson feature intersecting assets Optional <code>GET</code> <code>/preview[/{width}x{height}][.{format}]</code> image/bin create a preview image from assets Optional <code>GET</code> <code>/map</code> image/bin create maps from a dataset Optional"},{"location":"advanced/endpoints_factories/#multibandtilerfactory","title":"MultiBandTilerFactory","text":"<p>class: <code>titiler.core.factory.MultiBandTilerFactory</code></p> <p>Custom <code>TilerFactory</code> to be used with <code>rio_tiler.io.MultiBandReader</code> type readers.</p>"},{"location":"advanced/endpoints_factories/#attributes_3","title":"Attributes","text":"<ul> <li>reader: <code>rio_tiler.io.base.MultiBandReader</code> Dataset Reader required.</li> <li>layer_dependency: Dependency to define assets or expression. Defaults to <code>titiler.core.dependencies.BandsExprParams</code>.</li> <li>bands_dependency: Dependency to define bands to be used. Defaults to <code>titiler.core.dependencies.BandsParams</code>.</li> </ul>"},{"location":"advanced/endpoints_factories/#endpoints_2","title":"Endpoints","text":"<pre><code>from fastapi import FastAPI, Query\n\n\nfrom rio_tiler_pds.landsat.aws import LandsatC2Reader  # LandsatC2Reader is a MultiBandReader\nfrom titiler.core.factory import MultiBandTilerFactory\n\n\ndef SceneIDParams(\n    sceneid: Annotated[\n        str,\n        Query(description=\"Landsat Scene ID\")\n    ]\n) -&gt; str:\n    \"\"\"Use `sceneid` in query instead of url.\"\"\"\n    return sceneid\n\n\napp = FastAPI()\nlandsat = MultiBandTilerFactory(reader=LandsatC2Reader, path_dependency=SceneIDParams)\napp.include_router(landsat.router)\n</code></pre> Method URL Output Description <code>GET</code> <code>/bounds</code> JSON (Bounds) return dataset's bounds <code>GET</code> <code>/bands</code> JSON return the list of available bands <code>GET</code> <code>/info</code> JSON (Info) return basic info for a dataset <code>GET</code> <code>/info.geojson</code> GeoJSON (InfoGeoJSON) return basic info for a dataset as a GeoJSON feature <code>GET</code> <code>/statistics</code> JSON (Statistics) return info and statistics for a dataset <code>POST</code> <code>/statistics</code> GeoJSON (Statistics) return info and statistics for a dataset <code>GET</code> <code>/tiles</code> JSON List of OGC Tilesets available <code>GET</code> <code>/tiles/{tileMatrixSetId}</code> JSON OGC Tileset metadata <code>GET</code> <code>/tiles/{tileMatrixSetId}/{z}/{x}/{y}[@{scale}x][.{format}]</code> image/bin create a web map tile image from a dataset <code>GET</code> <code>/{tileMatrixSetId}/map.html</code> HTML return a simple map viewer Optional <code>GET</code> <code>/{tileMatrixSetId}/tilejson.json</code> JSON (TileJSON) return a Mapbox TileJSON document <code>GET</code> <code>/{tileMatrixSetId}/WMTSCapabilities.xml</code> XML return OGC WMTS Get Capabilities <code>GET</code> <code>/point/{lon},{lat}</code> JSON (Point) return pixel value from a dataset <code>GET</code> <code>/bbox/{minx},{miny},{maxx},{maxy}[/{width}x{height}].{format}</code> image/bin create an image from part of a dataset Optional <code>POST</code> <code>/feature[/{width}x{height}][.{format}]</code> image/bin create an image from a geojson feature Optional <code>GET</code> <code>/preview[/{width}x{height}][.{format}]</code> image/bin create a preview image from a dataset Optional <code>GET</code> <code>/map</code> image/bin create maps from a dataset Optional"},{"location":"advanced/endpoints_factories/#tmsfactory","title":"TMSFactory","text":"<p>class: <code>titiler.core.factory.TMSFactory</code></p> <p>Endpoints factory for OGC <code>TileMatrixSets</code>.</p>"},{"location":"advanced/endpoints_factories/#attributes_4","title":"Attributes","text":"<ul> <li>supported_tms: List of available TileMatrixSets. Defaults to <code>morecantile.tms</code>.</li> </ul> <pre><code>from fastapi import FastAPI\n\nfrom titiler.core.factory import TMSFactory\n\napp = FastAPI()\ntms = TMSFactory()\napp.include_router(tms.router)\n</code></pre>"},{"location":"advanced/endpoints_factories/#endpoints_3","title":"Endpoints","text":"Method URL Output Description <code>GET</code> <code>/tileMatrixSets</code> JSON (TileMatrixSetList) retrieve the list of available tiling schemes (tile matrix sets) <code>GET</code> <code>/tileMatrixSets/{tileMatrixSetId}</code> JSON (TileMatrixSet) retrieve the definition of the specified tiling scheme (tile matrix set)"},{"location":"advanced/endpoints_factories/#algorithmfactory","title":"AlgorithmFactory","text":"<p>class: <code>titiler.core.factory.AlgorithmFactory</code></p> <p>Endpoints factory for custom algorithms.</p>"},{"location":"advanced/endpoints_factories/#attributes_5","title":"Attributes","text":"<ul> <li>supported_algorithm: List of available <code>Algorithm</code>. Defaults to <code>titiler.core.algorithm.algorithms</code>.</li> </ul> <pre><code>from fastapi import FastAPI\n\nfrom titiler.core.factory import AlgorithmFactory\n\napp = FastAPI()\nalgo = AlgorithmFactory()\napp.include_router(algo.router)\n</code></pre>"},{"location":"advanced/endpoints_factories/#endpoints_4","title":"Endpoints","text":"Method URL Output Description <code>GET</code> <code>/algorithms</code> JSON (Dict of Algorithm Metadata) retrieve the list of available Algorithms <code>GET</code> <code>/algorithms/{algorithmId}</code> JSON (Algorithm Metadata) retrieve the metadata of the specified algorithm."},{"location":"advanced/endpoints_factories/#colormapfactory","title":"ColorMapFactory","text":"<p>class: <code>titiler.core.factory.ColorMapFactory</code></p> <p>Endpoints factory for colorMaps metadata.</p>"},{"location":"advanced/endpoints_factories/#attributes_6","title":"Attributes","text":"<ul> <li>supported_colormaps: List of available <code>ColorMaps</code>. Defaults to <code>rio_tiler.colormap.cmap</code>.</li> </ul> <pre><code>from fastapi import FastAPI\n\nfrom titiler.core.factory import ColorMapFactory\n\napp = FastAPI()\ncolormap = ColorMapFactory()\napp.include_router(colormap.router)\n</code></pre>"},{"location":"advanced/endpoints_factories/#endpoints_5","title":"Endpoints","text":"Method URL Output Description <code>GET</code> <code>/colorMaps</code> JSON (colorMapList) retrieve the list of available colorMaps <code>GET</code> <code>/colorMaps/{colorMapId}</code> JSON (colorMap) retrieve the metadata or image of the specified colorMap."},{"location":"advanced/endpoints_factories/#titilermosaic","title":"titiler.mosaic","text":""},{"location":"advanced/endpoints_factories/#mosaictilerfactory","title":"MosaicTilerFactory","text":"<p>class: <code>titiler.mosaic.factory.MosaicTilerFactory</code></p> <p>Endpoints factory for mosaics, built on top of MosaicJSON.</p>"},{"location":"advanced/endpoints_factories/#attributes_7","title":"Attributes","text":"<ul> <li>backend: <code>cogeo_mosaic.backends.BaseBackend</code> Mosaic backend. Defaults to <code>cogeo_mosaic.backend.MosaicBackend</code>.</li> <li>backend_dependency: Dependency to control options passed to the backend instance init. Defaults to <code>titiler.core.dependencies.DefaultDependency</code></li> <li>dataset_reader: Dataset Reader. Defaults to <code>rio_tiler.io.Reader</code></li> <li>reader_dependency: Dependency to control options passed to the reader instance init. Defaults to <code>titiler.core.dependencies.DefaultDependency</code></li> <li>path_dependency: Dependency to use to define the dataset url. Defaults to <code>titiler.mosaic.factory.DatasetPathParams</code>.</li> <li>assets_accessor_dependency: Dependency to define options to be forwarded to the backend <code>get_assets</code> method. Defaults to <code>titiler.core.dependencies.DefaultDependency</code>.</li> <li>layer_dependency: Dependency to define band indexes or expression. Defaults to <code>titiler.core.dependencies.BidxExprParams</code>.</li> <li>dataset_dependency: Dependency to overwrite <code>nodata</code> value, apply <code>rescaling</code> and change the <code>I/O</code> or <code>Warp</code> resamplings. Defaults to <code>titiler.core.dependencies.DatasetParams</code>.</li> <li>tile_dependency: Dependency to define <code>buffer</code> and <code>padding</code> to apply at tile creation. Defaults to <code>titiler.core.dependencies.TileParams</code>.</li> <li>process_dependency: Dependency to control which <code>algorithm</code> to apply to the data. Defaults to <code>titiler.core.algorithm.algorithms.dependency</code>.</li> <li>colormap_dependency: Dependency to define the Colormap options. Defaults to <code>titiler.core.dependencies.ColorMapParams</code></li> <li>render_dependency: Dependency to control output image rendering options. Defaults to <code>titiler.core.dependencies.ImageRenderingParams</code></li> <li>pixel_selection_dependency: Dependency to select the <code>pixel_selection</code> method. Defaults to <code>titiler.mosaic.factory.PixelSelectionParams</code>.</li> <li>environment_dependency: Dependency to define GDAL environment at runtime. Default to <code>lambda: {}</code>.</li> <li>supported_tms: List of available TileMatrixSets. Defaults to <code>morecantile.tms</code>.</li> <li>supported_tms: List of available TileMatrixSets. Defaults to <code>morecantile.tms</code>.</li> <li>templates: Jinja2 templates to use in endpoints. Defaults to <code>titiler.core.factory.DEFAULT_TEMPLATES</code>.</li> <li>optional_headers: List of OptionalHeader which endpoints could add (if implemented). Defaults to <code>[]</code>.</li> <li>add_viewer: Add <code>/{TileMatrixSetId}/map.html</code> endpoints to the router. Defaults to <code>True</code>.</li> </ul>"},{"location":"advanced/endpoints_factories/#endpoints_6","title":"Endpoints","text":"Method URL Output Description <code>GET</code> <code>/</code> JSON MosaicJSON return a MosaicJSON document <code>GET</code> <code>/bounds</code> JSON (Bounds) return mosaic's bounds <code>GET</code> <code>/info</code> JSON (Info) return mosaic's basic info <code>GET</code> <code>/info.geojson</code> GeoJSON (InfoGeoJSON) return mosaic's basic info  as a GeoJSON feature <code>GET</code> <code>/tiles</code> JSON List of OGC Tilesets available <code>GET</code> <code>/tiles/{tileMatrixSetId}</code> JSON OGC Tileset metadata <code>GET</code> <code>/tiles/{tileMatrixSetId}/{z}/{x}/{y}[@{scale}x][.{format}]</code> image/bin create a web map tile image from a MosaicJSON <code>GET</code> <code>/tiles/{tileMatrixSetId}/{z}/{x}/{y}/assets</code> JSON return list of assets intersecting a XYZ tile <code>GET</code> <code>/{tileMatrixSetId}/map.html</code> HTML return a simple map viewer Optional <code>GET</code> <code>/{tileMatrixSetId}/tilejson.json</code> JSON (TileJSON) return a Mapbox TileJSON document <code>GET</code> <code>/{tileMatrixSetId}/WMTSCapabilities.xml</code> XML return OGC WMTS Get Capabilities <code>GET</code> <code>/point/{lon},{lat}</code> JSON (Point) return pixel value from a MosaicJSON dataset <code>GET</code> <code>/point/{lon},{lat}/assets</code> JSON return list of assets intersecting a point <code>GET</code> <code>/bbox/{minx},{miny},{maxx},{maxy}/assets</code> JSON return list of assets intersecting a bounding box"},{"location":"advanced/endpoints_factories/#titilerxarray","title":"titiler.xarray","text":""},{"location":"advanced/endpoints_factories/#tilerfactory_1","title":"TilerFactory","text":"<p>class: <code>titiler.xarray.factory.TilerFactory</code></p>"},{"location":"advanced/endpoints_factories/#attributes_8","title":"Attributes","text":"<ul> <li>reader: Dataset Reader required.</li> <li>path_dependency: Dependency to use to define the dataset url. Defaults to <code>titiler.core.dependencies.DatasetPathParams</code>.</li> <li>reader_dependency: Dependency to control options passed to the reader instance init. Defaults to <code>titiler.xarray.dependencies.XarrayParams</code></li> <li>layer_dependency: Dependency to define band indexes or expression. Defaults to <code>titiler.core.dependencies.BidxParams</code>.</li> <li>dataset_dependency: Dependency to overwrite <code>nodata</code> value and change the <code>Warp</code> resamplings. Defaults to <code>titiler.xarray.dependencies.DatasetParams</code>.</li> <li>tile_dependency: Dependency for tile creation options. Defaults to <code>titiler.core.dependencies.DefaultDependency</code>.</li> <li>stats_dependency: Dependency to define options for rio-tiler's statistics method used in <code>/statistics</code> endpoints. Defaults to <code>titiler.core.dependencies.StatisticsParams</code>.</li> <li>histogram_dependency: Dependency to define numpy's histogram options used in <code>/statistics</code> endpoints. Defaults to <code>titiler.core.dependencies.HistogramParams</code>.</li> <li>img_part_dependency: Dependency to define image size for <code>/bbox</code> and <code>/feature</code> endpoints. Defaults to <code>titiler.xarray.dependencies.PartFeatureParams</code>.</li> <li>process_dependency: Dependency to control which <code>algorithm</code> to apply to the data. Defaults to <code>titiler.core.algorithm.algorithms.dependency</code>.</li> <li>colormap_dependency: Dependency to define the Colormap options. Defaults to <code>titiler.core.dependencies.ColorMapParams</code></li> <li>render_dependency: Dependency to control output image rendering options. Defaults to <code>titiler.core.dependencies.ImageRenderingParams</code></li> <li>environment_dependency: Dependency to define GDAL environment at runtime. Default to <code>lambda: {}</code>.</li> <li>supported_tms: List of available TileMatrixSets. Defaults to <code>morecantile.tms</code>.</li> <li>templates: Jinja2 templates to use in endpoints. Defaults to <code>titiler.core.factory.DEFAULT_TEMPLATES</code>.</li> <li>add_part: Add <code>/bbox</code> and <code>/feature</code> endpoints to the router. Defaults to <code>True</code>.</li> <li>add_viewer: Add <code>/{TileMatrixSetId}/map.html</code> endpoints to the router. Defaults to <code>True</code>.</li> <li>add_ogc_maps: Add <code>/map</code> endpoints to the router. Default to <code>False</code>.</li> <li>add_preview: Add <code>/preview</code> endpoints to the router. Default to <code>False</code>.</li> </ul> <pre><code>from fastapi import FastAPI\n\nfrom titiler.xarray.factory import TilerFactory\n\n# Create FastAPI application\napp = FastAPI()\n\n# Create router and register set of endpoints\nmd = TilerFactory(\n    add_part=True,     # default to True\n    add_viewer=True,   # default to True\n    add_preview=True,  # default to False\n)\n\n# add router endpoint to the main application\napp.include_router(md.router)\n</code></pre>"},{"location":"advanced/endpoints_factories/#endpoints_7","title":"Endpoints","text":"Method URL Output Description <code>GET</code> <code>/bounds</code> JSON (Bounds) return dataset's bounds <code>GET</code> <code>/info</code> JSON (Info) return dataset's basic info <code>GET</code> <code>/info.geojson</code> GeoJSON (InfoGeoJSON) return dataset's basic info as a GeoJSON feature <code>POST</code> <code>/statistics</code> GeoJSON (Statistics) return dataset's statistics for a GeoJSON <code>GET</code> <code>/tiles</code> JSON List of OGC Tilesets available <code>GET</code> <code>/tiles/{tileMatrixSetId}</code> JSON OGC Tileset metadata <code>GET</code> <code>/tiles/{tileMatrixSetId}/{z}/{x}/{y}[@{scale}x][.{format}]</code> image/bin create a web map tile image from a dataset <code>GET</code> <code>/{tileMatrixSetId}/map.html</code> HTML return a simple map viewer Optional <code>GET</code> <code>/{tileMatrixSetId}/tilejson.json</code> JSON (TileJSON) return a Mapbox TileJSON document <code>GET</code> <code>/{tileMatrixSetId}/WMTSCapabilities.xml</code> XML return OGC WMTS Get Capabilities <code>GET</code> <code>/point/{lon},{lat}</code> JSON (Point) return pixel values from a dataset <code>GET</code> <code>/bbox/{minx},{miny},{maxx},{maxy}[/{width}x{height}].{format}</code> image/bin create an image from part of a dataset Optional <code>POST</code> <code>/feature[/{width}x{height}][.{format}]</code> image/bin create an image from a GeoJSON feature Optional <code>GET</code> <code>/preview[/{width}x{height}][.{format}]</code> image/bin create a preview image from a dataset Optional"},{"location":"advanced/performance_tuning/","title":"Performance Tuning","text":""},{"location":"advanced/performance_tuning/#overview","title":"Overview","text":"<p>TiTiler makes use of several great underlying libraries, including GDAL and Python bindings to GDAL. An effective deployment of titiler generally requires tweaking GDAL configuration settings. This document provides an overview of relevant settings. Full documentation from GDAL is available here.</p>"},{"location":"advanced/performance_tuning/#gdal-configuration","title":"GDAL Configuration","text":""},{"location":"advanced/performance_tuning/#setting-a-config-variable","title":"Setting a config variable","text":"<p>GDAL configuration is modified using environment variables. Thus in order to change a setting, you'll need to set environment variables through your deployment mechanism. For example, in order to test locally you'd set an environment variable in bash:</p> <pre><code>export GDAL_HTTP_MULTIPLEX=YES\n</code></pre>"},{"location":"advanced/performance_tuning/#available-configuration-settings","title":"Available configuration settings","text":""},{"location":"advanced/performance_tuning/#gdal_http_merge_consecutive_ranges","title":"<code>GDAL_HTTP_MERGE_CONSECUTIVE_RANGES</code>","text":"<p>When set to <code>YES</code>, this tells GDAL to merge adjacent range requests. Instead of making two requests for byte ranges <code>1-5</code> and <code>6-10</code>, it would make a single request for <code>1-10</code>. This should always be set to <code>YES</code>.</p>"},{"location":"advanced/performance_tuning/#gdal_disable_readdir_on_open","title":"<code>GDAL_DISABLE_READDIR_ON_OPEN</code>","text":"<p>This is a very important setting to control the number of requests GDAL makes.</p> <p>This setting has two options: <code>FALSE</code> and <code>EMPTY_DIR</code>. <code>FALSE</code> (the default) causes GDAL to try to establish a list of all the available files in the directory. <code>EMPTY_DIR</code> tells GDAL to imagine that the directory is empty except for the requested file.</p> <p>When reading datasets with necessary external sidecar files, it's imperative to set <code>FALSE</code>. For example, the <code>landsat-pds</code> bucket on AWS S3 contains GeoTIFF images where overviews are in external <code>.ovr</code> files. If set to <code>EMPTY_DIR</code>, GDAL won't find the <code>.ovr</code> files.</p> <p>However, in all other cases, it's much better to set <code>EMPTY_DIR</code> because this prevents GDAL from making a <code>LIST</code> request.</p> <p>This setting also has cost implications for reading data from requester-pays buckets. When set to <code>FALSE</code>, GDAL makes a <code>LIST</code> request every time it opens a file. Since <code>LIST</code> requests are much more expensive than <code>GET</code> requests, this can bring unexpected costs.</p>"},{"location":"advanced/performance_tuning/#cpl_vsil_curl_allowed_extensions","title":"<code>CPL_VSIL_CURL_ALLOWED_EXTENSIONS</code>","text":"<p>A list of file extensions that GDAL is allowed to open. For example if set to <code>.tif</code>, then GDAL would only open files with a <code>.tif</code> extension. For example, it would fail on JPEG2000 files with a <code>.jp2</code> extension, but also wouldn't open GeoTIFFs exposed through an API endpoint that don't have a <code>.tif</code> suffix.</p> <p>Note that you also need to include extensions of external overview files. For example, the <code>landsat-pds</code> bucket on AWS S3 has external overviews in <code>.ovr</code> files, so if you wished to read this data, you'd want</p>"},{"location":"advanced/performance_tuning/#gdal_ingested_bytes_at_open","title":"<code>GDAL_INGESTED_BYTES_AT_OPEN</code>","text":"<p>Defines the number of initial bytes GDAL should read when opening a file and inspecting its metadata.</p> <p>TiTiler works best with Cloud-Optimized GeoTIFFs (COGs) because they have a tiled internal structure that supports efficient random reads. These files have an initial metadata section that describes the location (byte range) within the file of each internal tile. The more internal tiles the COG has, the more data the header needs to contain.</p> <p>GDAL needs to read the entire header before it can read any other portion of the file. By default GDAL reads the first 16KB of the file, then if that doesn't contain the entire metadata, it makes one more request for the rest of the metadata.</p> <p>In environments where latency is relatively high (at least compared to bandwidth), such as AWS S3, it may be beneficial to increase this value depending on the data you expect to read.</p> <p>There isn't currently a way to get the number of header bytes using GDAL, but alternative GeoTIFF readers such as <code>aiocogeo</code> can. Using its cli you can find the image's header size:</p> <pre><code>export AWS_REQUEST_PAYER=\"requester\"\naiocogeo info s3://usgs-landsat/collection02/level-2/standard/oli-tirs/2020/072/076/LC08_L2SR_072076_20201203_20210313_02_T2/LC08_L2SR_072076_20201203_20210313_02_T2_SR_B1.TIF\n\n          PROFILE\n            ...\n            Header size:      32770\n</code></pre> <p>It's wise to inspect the header sizes of your data sources, and set <code>GDAL_INGESTED_BYTES_AT_OPEN</code> appropriately. Beware, however, that the given number of bytes will be read for every image, so you don't want to make the value too large.</p>"},{"location":"advanced/performance_tuning/#gdal_cachemax","title":"<code>GDAL_CACHEMAX</code>","text":"<p>Default GDAL block cache. The value can be either in Mb, bytes or percent of the physical RAM</p> <p>Recommended: 200 (200Mb)</p>"},{"location":"advanced/performance_tuning/#cpl_vsil_curl_cache_size","title":"<code>CPL_VSIL_CURL_CACHE_SIZE</code>","text":"<p>A global least-recently-used cache shared among all downloaded content and may be reused after a file handle has been closed and reopen</p> <p>Recommended: 200000000 (200Mb)</p>"},{"location":"advanced/performance_tuning/#vsi_cache","title":"<code>VSI_CACHE</code>","text":"<p>Setting this to <code>TRUE</code> enables GDAL to use an internal caching mechanism. It's</p> <p>Recommended (Strongly): TRUE.</p>"},{"location":"advanced/performance_tuning/#vsi_cache_size","title":"<code>VSI_CACHE_SIZE</code>","text":"<p>The size of the above VSI cache in bytes per-file handle. If you open a VRT with 10 files and your VSI_CACHE_SIZE is 10 bytes, the total cache memory usage would be 100 bytes. The cache is RAM based and the content of the cache is discarded when the file handle is closed.</p> <p>Recommended: 5000000 (5Mb per file handle)</p>"},{"location":"advanced/performance_tuning/#gdal_band_block_cache","title":"<code>GDAL_BAND_BLOCK_CACHE</code>","text":"<p>GDAL Block Cache type: <code>ARRAY</code> or <code>HASHSET</code>. See gdal.org/development/rfc/rfc26_blockcache.html</p>"},{"location":"advanced/performance_tuning/#proj_network","title":"<code>PROJ_NETWORK</code>","text":"<p>Introduced with GDAL 3 and PROJ&gt;7, the PROJ library can fetch more precise transformation grids hosted on the cloud.</p> <p>Values: ON/OFF</p> <p>Ref: proj.org/usage/network.html</p>"},{"location":"advanced/performance_tuning/#gdal_http_multiplex","title":"<code>GDAL_HTTP_MULTIPLEX</code>","text":"<p>When set to <code>YES</code>, this attempts to download multiple range requests in parallel, reusing the same TCP connection. Note this is only possible when the server supports HTTP2, which many servers don't yet support. There's no downside to setting <code>YES</code> here.</p>"},{"location":"advanced/performance_tuning/#gdal_data","title":"<code>GDAL_DATA</code>","text":"<p>The <code>GDAL_DATA</code> variable tells rasterio/GDAL where the GDAL C libraries have been installed. When using rasterio wheels, GDAL_DATA must be unset.</p>"},{"location":"advanced/performance_tuning/#proj_lib","title":"<code>PROJ_LIB</code>","text":"<p>The <code>PROJ_LIB</code> variable tells rasterio/GDAL where the PROJ C libraries have been installed. When using rasterio wheels, PROJ_LIB must be unset.</p>"},{"location":"advanced/performance_tuning/#aws-configuration","title":"AWS Configuration","text":""},{"location":"advanced/performance_tuning/#aws_request_payer","title":"<code>AWS_REQUEST_PAYER</code>","text":""},{"location":"advanced/performance_tuning/#recommended-configuration-for-dynamic-tiling","title":"Recommended Configuration for dynamic tiling","text":"<ul> <li><code>CPL_VSIL_CURL_ALLOWED_EXTENSIONS=\".tif,.TIF,.tiff\"</code></li> </ul> <p>In addition to <code>GDAL_DISABLE_READDIR_ON_OPEN</code>, we set the allowed extensions to <code>.tif</code> to only enable tif files. (OPTIONAL)</p> <ul> <li><code>GDAL_CACHEMAX=\"200\"</code></li> </ul> <p>200 Mb Cache.</p> <ul> <li><code>CPL_VSIL_CURL_CACHE_SIZE=\"200000000</code></li> </ul> <p>200 Mb VSI Cache.</p> <ul> <li> <p><code>GDAL_BAND_BLOCK_CACHE=\"HASHSET\"</code></p> </li> <li> <p><code>GDAL_DISABLE_READDIR_ON_OPEN=\"EMPTY_DIR\"</code></p> </li> </ul> <p>Maybe the most important variable. Setting it to <code>EMPTY_DIR</code> reduce the number of GET/LIST requests.</p> <ul> <li><code>GDAL_HTTP_MERGE_CONSECUTIVE_RANGES=\"YES\"</code></li> </ul> <p>Tells GDAL to merge consecutive range GET requests.</p> <ul> <li><code>GDAL_HTTP_MULTIPLEX=\"YES\"</code></li> <li><code>GDAL_HTTP_VERSION=\"2\"</code></li> </ul> <p>Both Multiplex and HTTP_VERSION will only have impact if the files are stored in an environment which support HTTP 2 (e.g cloudfront).</p> <ul> <li><code>VSI_CACHE=\"TRUE\"</code></li> <li><code>VSI_CACHE_SIZE=\"5000000\"</code></li> </ul> <p>5Mb cache per file handle.</p>"},{"location":"advanced/telemetry/","title":"Telemetry","text":""},{"location":"advanced/telemetry/#observability-with-opentelemetry","title":"Observability with OpenTelemetry","text":"<p><code>TiTiler</code> provides built-in observability through OpenTelemetry, automatically creating traces for all API endpoints. These traces include detailed spans for key internal operations like data access and image processing, enabling fine-grained performance analysis and debugging.</p> <p>This instrumentation works seamlessly with other OpenTelemetry libraries, such as FastAPIInstrumentor, to provide a complete, end-to-end view of your application's performance, from incoming request to final response.</p>"},{"location":"advanced/telemetry/#installation","title":"Installation","text":"<p>To enable telemetry, you must install titiler.core with the [telemetry] extra. This ensures all necessary OpenTelemetry packages are installed.</p> <pre><code>python -m pip install -U pip\n\n# From Pypi\npython -m pip install titiler.core[telemetry]\n\n# Or from sources\ngit clone https://github.com/developmentseed/titiler.git\ncd titiler &amp;&amp; python -m pip install -e src/titiler/core[telemetry]\n</code></pre>"},{"location":"advanced/telemetry/#configuration","title":"Configuration","text":"<p>To export traces, you need to configure your application to send them to an observability platform (like Jaeger or Datadog) using an OTLP Exporter.</p> <p>The following example demonstrates how to set up a tracer provider that exports data via the OTLP protocol over HTTP. This setup is typically done once when your application starts.</p> <pre><code># In your main application file, e.g., main.py\n\nimport os\nfrom fastapi import FastAPI\nfrom opentelemetry import trace\nfrom opentelemetry.exporter.otlp.proto.http.trace_exporter import OTLPSpanExporter\nfrom opentelemetry.instrumentation.fastapi import FastAPIInstrumentor\nfrom opentelemetry.instrumentation.logging import LoggingInstrumentor\nfrom opentelemetry.sdk.resources import SERVICE_NAME, SERVICE_VERSION, Resource\nfrom opentelemetry.sdk.trace import TracerProvider\nfrom opentelemetry.sdk.trace.export import BatchSpanProcessor\n\nfrom titiler.core.factory import TilerFactory\n\n# --- OpenTelemetry Configuration ---\n\n# Define a \"Resource\" for your application.\n# This adds metadata to your traces, like the service name and version.\nresource = Resource.create(\n    {\n        SERVICE_NAME: os.getenv(\"OTEL_SERVICE_NAME\", \"titiler\"),\n        SERVICE_VERSION: \"0.1\",\n    }\n)\n\n# Create a \"TracerProvider\" with the defined resource.\n# The provider manages the creation of tracers.\nprovider = TracerProvider(resource=resource)\n\n# Configure an \"Exporter\" to send telemetry data.\n# The OTLPSpanExporter sends data to an OTLP-compatible endpoint.\n# By default, it reads the endpoint from the OTEL_EXPORTER_OTLP_ENDPOINT\n# environment variable. The default for HTTP is http://localhost:4318.\nexporter = OTLPSpanExporter()\n\n# Use a \"BatchSpanProcessor\" to send spans in the background.\n# This is the recommended processor for production.\nprocessor = BatchSpanProcessor(exporter)\nprovider.add_span_processor(processor)\n\n# Set the configured provider as the global tracer provider.\ntrace.set_tracer_provider(provider)\n\n# --- FastAPI Application Setup ---\napp = FastAPI(title=\"My TiTiler App\")\n\n# Instrument the FastAPI application.\n# This adds middleware to trace requests, responses, and exceptions,\n# complementing TiTiler's internal endpoint tracing.\nFastAPIInstrumentor.instrument_app(app)\n\n# Add trace/span info to logging messages for trace correlation\nLoggingInstrumentor().instrument(set_logging_format=True)\n\n# Add your TiTiler endpoints with the enable_telemetry flag set to True\ncog = TilerFactory(enable_telemetry=True)\napp.include_router(cog.router)\n</code></pre>"},{"location":"api/titiler/core/dependencies/","title":"dependencies","text":""},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies","title":"titiler.core.dependencies","text":"<p>Common dependency.</p>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.AssetsBidxExprParams","title":"AssetsBidxExprParams  <code>dataclass</code>","text":"<p>               Bases: <code>AssetsParams</code>, <code>BidxParams</code></p> <p>Assets, Expression and Asset's band Indexes parameters.</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass AssetsBidxExprParams(AssetsParams, BidxParams):\n    \"\"\"Assets, Expression and Asset's band Indexes parameters.\"\"\"\n\n    expression: Annotated[\n        Optional[str],\n        Query(\n            title=\"Band Math expression\",\n            description=\"Band math expression between assets\",\n            openapi_examples={\n                \"user-provided\": {\"value\": None},\n                \"simple\": {\n                    \"description\": \"Return results of expression between assets.\",\n                    \"value\": \"asset1_b1 + asset2_b1 / asset3_b1\",\n                },\n            },\n        ),\n    ] = None\n\n    asset_indexes: Annotated[\n        Optional[Sequence[str]],\n        Query(\n            title=\"Per asset band indexes\",\n            description=\"Per asset band indexes (coma separated indexes)\",\n            alias=\"asset_bidx\",\n            openapi_examples={\n                \"user-provided\": {\"value\": None},\n                \"one-asset\": {\n                    \"description\": \"Return indexes 1,2,3 of asset `data`.\",\n                    \"value\": [\"data|1,2,3\"],\n                },\n                \"multi-assets\": {\n                    \"description\": \"Return indexes 1,2,3 of asset `data` and indexes 1 of asset `cog`\",\n                    \"value\": [\"data|1,2,3\", \"cog|1\"],\n                },\n            },\n        ),\n    ] = None\n\n    asset_as_band: Annotated[\n        Optional[bool],\n        Query(\n            title=\"Consider asset as a 1 band dataset\",\n            description=\"Asset as Band\",\n        ),\n    ] = None\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if not self.assets and not self.expression:\n            raise MissingAssets(\n                \"assets must be defined either via expression or assets options.\"\n            )\n\n        if self.asset_indexes:\n            self.asset_indexes = parse_asset_indexes(self.asset_indexes)\n\n        if self.asset_indexes and self.indexes:\n            warnings.warn(\n                \"Both `asset_bidx` and `bidx` passed; only `asset_bidx` will be considered.\",\n                UserWarning,\n                stacklevel=1,\n            )\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.AssetsBidxExprParamsOptional","title":"AssetsBidxExprParamsOptional  <code>dataclass</code>","text":"<p>               Bases: <code>AssetsBidxExprParams</code></p> <p>Assets, Expression and Asset's band Indexes parameters but with no requirement.</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass AssetsBidxExprParamsOptional(AssetsBidxExprParams):\n    \"\"\"Assets, Expression and Asset's band Indexes parameters but with no requirement.\"\"\"\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if self.asset_indexes:\n            self.asset_indexes = parse_asset_indexes(self.asset_indexes)\n\n        if self.asset_indexes and self.indexes:\n            warnings.warn(\n                \"Both `asset_bidx` and `bidx` passed; only `asset_bidx` will be considered.\",\n                UserWarning,\n                stacklevel=1,\n            )\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.AssetsBidxParams","title":"AssetsBidxParams  <code>dataclass</code>","text":"<p>               Bases: <code>AssetsParams</code>, <code>BidxParams</code></p> <p>Assets, Asset's band Indexes and Asset's band Expression parameters.</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass AssetsBidxParams(AssetsParams, BidxParams):\n    \"\"\"Assets, Asset's band Indexes and Asset's band Expression parameters.\"\"\"\n\n    asset_indexes: Annotated[\n        Optional[Sequence[str]],\n        Query(\n            title=\"Per asset band indexes\",\n            description=\"Per asset band indexes\",\n            alias=\"asset_bidx\",\n            openapi_examples={\n                \"user-provided\": {\"value\": None},\n                \"one-asset\": {\n                    \"description\": \"Return indexes 1,2,3 of asset `data`.\",\n                    \"value\": [\"data|1;2;3\"],\n                },\n                \"multi-assets\": {\n                    \"description\": \"Return indexes 1,2,3 of asset `data` and indexes 1 of asset `cog`\",\n                    \"value\": [\"data|1;2;3\", \"cog|1\"],\n                },\n            },\n        ),\n    ] = None\n\n    asset_expression: Annotated[\n        Optional[Sequence[str]],\n        Query(\n            title=\"Per asset band expression\",\n            description=\"Per asset band expression\",\n            openapi_examples={\n                \"user-provided\": {\"value\": None},\n                \"one-asset\": {\n                    \"description\": \"Return results for expression `b1*b2+b3` of asset `data`.\",\n                    \"value\": [\"data|b1*b2+b3\"],\n                },\n                \"multi-assets\": {\n                    \"description\": \"Return results for expressions `b1*b2+b3` for asset `data` and `b1+b3` for asset `cog`.\",\n                    \"value\": [\"data|b1*b2+b3\", \"cog|b1+b3\"],\n                },\n            },\n        ),\n    ] = None\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if self.asset_indexes:\n            self.asset_indexes = parse_asset_indexes(self.asset_indexes)\n\n        if self.asset_expression:\n            self.asset_expression = parse_asset_expression(self.asset_expression)\n\n        if self.asset_indexes and self.indexes:\n            warnings.warn(\n                \"Both `asset_bidx` and `bidx` passed; only `asset_bidx` will be considered.\",\n                UserWarning,\n                stacklevel=1,\n            )\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.AssetsParams","title":"AssetsParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>Assets parameters.</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass AssetsParams(DefaultDependency):\n    \"\"\"Assets parameters.\"\"\"\n\n    assets: Annotated[\n        Optional[List[str]],\n        Query(\n            title=\"Asset names\",\n            description=\"Asset's names.\",\n            openapi_examples={\n                \"user-provided\": {\"value\": None},\n                \"one-asset\": {\n                    \"description\": \"Return results for asset `data`.\",\n                    \"value\": [\"data\"],\n                },\n                \"multi-assets\": {\n                    \"description\": \"Return results for assets `data` and `cog`.\",\n                    \"value\": [\"data\", \"cog\"],\n                },\n            },\n        ),\n    ] = None\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.BandsExprParams","title":"BandsExprParams  <code>dataclass</code>","text":"<p>               Bases: <code>ExpressionParams</code>, <code>BandsParams</code></p> <p>Band names and Expression parameters (Band or Expression required).</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass BandsExprParams(ExpressionParams, BandsParams):\n    \"\"\"Band names and Expression parameters (Band or Expression required).\"\"\"\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if not self.bands and not self.expression:\n            raise MissingBands(\n                \"bands must be defined either via expression or bands options.\"\n            )\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.BandsExprParamsOptional","title":"BandsExprParamsOptional  <code>dataclass</code>","text":"<p>               Bases: <code>ExpressionParams</code>, <code>BandsParams</code></p> <p>Optional Band names and Expression parameters.</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass BandsExprParamsOptional(ExpressionParams, BandsParams):\n    \"\"\"Optional Band names and Expression parameters.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.BandsParams","title":"BandsParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>Band names parameters.</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass BandsParams(DefaultDependency):\n    \"\"\"Band names parameters.\"\"\"\n\n    bands: Annotated[\n        Optional[List[str]],\n        Query(\n            title=\"Band names\",\n            description=\"Band's names.\",\n            openapi_examples={\n                \"user-provided\": {\"value\": None},\n                \"one-band\": {\n                    \"description\": \"Return results for band `B01`.\",\n                    \"value\": [\"B01\"],\n                },\n                \"multi-bands\": {\n                    \"description\": \"Return results for bands `B01` and `B02`.\",\n                    \"value\": [\"B01\", \"B02\"],\n                },\n            },\n        ),\n    ] = None\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.BidxExprParams","title":"BidxExprParams  <code>dataclass</code>","text":"<p>               Bases: <code>ExpressionParams</code>, <code>BidxParams</code></p> <p>Band Indexes and Expression parameters.</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass BidxExprParams(ExpressionParams, BidxParams):\n    \"\"\"Band Indexes and Expression parameters.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.BidxParams","title":"BidxParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>Band Indexes parameters.</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass BidxParams(DefaultDependency):\n    \"\"\"Band Indexes parameters.\"\"\"\n\n    indexes: Annotated[\n        Optional[List[int]],\n        Query(\n            title=\"Band indexes\",\n            alias=\"bidx\",\n            description=\"Dataset band indexes\",\n            openapi_examples={\n                \"user-provided\": {\"value\": None},\n                \"one-band\": {\"value\": [1]},\n                \"multi-bands\": {\"value\": [1, 2, 3]},\n            },\n        ),\n    ] = None\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.DatasetParams","title":"DatasetParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>Low level WarpedVRT Optional parameters.</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass DatasetParams(DefaultDependency):\n    \"\"\"Low level WarpedVRT Optional parameters.\"\"\"\n\n    nodata: Annotated[\n        Optional[Union[str, int, float]],\n        Query(\n            title=\"Nodata value\",\n            description=\"Overwrite internal Nodata value\",\n        ),\n    ] = None\n    unscale: Annotated[\n        Optional[bool],\n        Query(\n            title=\"Apply internal Scale/Offset\",\n            description=\"Apply internal Scale/Offset. Defaults to `False`.\",\n        ),\n    ] = None\n    resampling_method: Annotated[\n        Optional[RIOResampling],\n        Query(\n            alias=\"resampling\",\n            description=\"RasterIO resampling algorithm. Defaults to `nearest`.\",\n        ),\n    ] = None\n    reproject_method: Annotated[\n        Optional[WarpResampling],\n        Query(\n            alias=\"reproject\",\n            description=\"WarpKernel resampling algorithm (only used when doing re-projection). Defaults to `nearest`.\",\n        ),\n    ] = None\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if self.nodata is not None:\n            self.nodata = numpy.nan if self.nodata == \"nan\" else float(self.nodata)\n\n        if self.unscale is not None:\n            self.unscale = bool(self.unscale)\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.DefaultDependency","title":"DefaultDependency  <code>dataclass</code>","text":"<p>Dataclass with dict unpacking</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass DefaultDependency:\n    \"\"\"Dataclass with dict unpacking\"\"\"\n\n    def as_dict(self, exclude_none: bool = True) -&gt; Dict:\n        \"\"\"Transform dataclass to dict.\"\"\"\n        if exclude_none:\n            return {k: v for k, v in self.__dict__.items() if v is not None}\n\n        return dict(self.__dict__.items())\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.DefaultDependency.as_dict","title":"as_dict","text":"<pre><code>as_dict(exclude_none: bool = True) -&gt; Dict\n</code></pre> <p>Transform dataclass to dict.</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>def as_dict(self, exclude_none: bool = True) -&gt; Dict:\n    \"\"\"Transform dataclass to dict.\"\"\"\n    if exclude_none:\n        return {k: v for k, v in self.__dict__.items() if v is not None}\n\n    return dict(self.__dict__.items())\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.ExpressionParams","title":"ExpressionParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>Expression parameters.</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass ExpressionParams(DefaultDependency):\n    \"\"\"Expression parameters.\"\"\"\n\n    expression: Annotated[\n        Optional[str],\n        Query(\n            title=\"Band Math expression\",\n            description=\"rio-tiler's band math expression\",\n            openapi_examples={\n                \"user-provided\": {\"value\": None},\n                \"simple\": {\"description\": \"Simple band math.\", \"value\": \"b1/b2\"},\n                \"multi-bands\": {\n                    \"description\": \"Semicolon (;) delimited expressions (band1: b1/b2, band2: b2+b3).\",\n                    \"value\": \"b1/b2;b2+b3\",\n                },\n            },\n        ),\n    ] = None\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.HistogramParams","title":"HistogramParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>Numpy Histogram options.</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass HistogramParams(DefaultDependency):\n    \"\"\"Numpy Histogram options.\"\"\"\n\n    bins: Annotated[\n        Optional[str],\n        Query(\n            alias=\"histogram_bins\",\n            title=\"Histogram bins.\",\n            description=\"\"\"\nDefines the number of equal-width bins in the given range (10, by default).\n\nIf bins is a sequence (comma `,` delimited values), it defines a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform bin widths.\n\nlink: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html\n            \"\"\",\n            openapi_examples={\n                \"user-provided\": {\"value\": None},\n                \"simple\": {\n                    \"description\": \"Defines the number of equal-width bins\",\n                    \"value\": 8,\n                },\n                \"array\": {\n                    \"description\": \"Defines custom bin edges (comma `,` delimited values)\",\n                    \"value\": \"0,100,200,300\",\n                },\n            },\n        ),\n    ] = None\n\n    range: Annotated[\n        Optional[str],\n        Query(\n            alias=\"histogram_range\",\n            title=\"Histogram range\",\n            description=\"\"\"\nComma `,` delimited range of the bins.\n\nThe lower and upper range of the bins. If not provided, range is simply (a.min(), a.max()).\n\nValues outside the range are ignored. The first element of the range must be less than or equal to the second.\nrange affects the automatic bin computation as well.\n\nlink: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html\n            \"\"\",\n            openapi_examples={\n                \"user-provided\": {\"value\": None},\n                \"array\": {\n                    \"description\": \"Defines custom histogram range (comma `,` delimited values)\",\n                    \"value\": \"0,1000\",\n                },\n            },\n        ),\n    ] = None\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if self.bins:\n            bins = self.bins.split(\",\")\n            if len(bins) == 1:\n                self.bins = int(bins[0])  # type: ignore\n            else:\n                self.bins = list(map(float, bins))  # type: ignore\n        else:\n            self.bins = 10\n\n        if self.range:\n            parsed = list(map(float, self.range.split(\",\")))\n            assert (\n                len(parsed) == 2\n            ), f\"Invalid histogram_range values: {self.range}, should be of form 'min,max'\"\n\n            self.range = parsed  # type: ignore\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.ImageRenderingParams","title":"ImageRenderingParams  <code>dataclass</code>","text":"<p>               Bases: <code>RenderingParams</code></p> <p>Image Rendering options.</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass ImageRenderingParams(RenderingParams):\n    \"\"\"Image Rendering options.\"\"\"\n\n    add_mask: Annotated[\n        Optional[bool],\n        Query(\n            alias=\"return_mask\",\n            description=\"Add mask to the output data. Defaults to `True`\",\n        ),\n    ] = None\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.OGCMapsParams","title":"OGCMapsParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>OGC Maps options.</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass OGCMapsParams(DefaultDependency):\n    \"\"\"OGC Maps options.\"\"\"\n\n    request: Request\n\n    bbox: Annotated[\n        Optional[str],\n        Query(\n            description=\"Bounding box of the rendered map. The bounding box is provided as four or six coordinates.\",\n        ),\n    ] = None\n\n    crs: Annotated[\n        Optional[str],\n        Query(\n            description=\"Reproject the output to the given crs.\",\n        ),\n    ] = None\n\n    bbox_crs: Annotated[\n        Optional[str],\n        Query(\n            description=\"crs for the specified bbox.\",\n            alias=\"bbox-crs\",\n        ),\n    ] = None\n\n    height: Annotated[\n        Optional[int],\n        Query(\n            description=\"Height of the map in pixels. If omitted and `width` is specified, defaults to the `height` maintaining a 1:1 aspect ratio. If both `width` and `height` are omitted, the server will select default dimensions.\",\n            gt=0,\n        ),\n    ] = None\n\n    width: Annotated[\n        Optional[int],\n        Query(\n            description=\"Width of the map in pixels. If omitted and `height` is specified, defaults to the `width` maintaining a 1:1 aspect ratio. If both `width` and `height` are omitted, the server will select default dimensions.\",\n            gt=0,\n        ),\n    ] = None\n\n    f: Annotated[\n        Optional[ImageType],\n        Query(description=\"The format of the map response (e.g. png).\"),\n    ] = None\n\n    max_size: Optional[int] = field(init=False, default=None)\n\n    format: Optional[ImageType] = field(init=False, default=ImageType.png)\n\n    def __post_init__(self):  # noqa: C901\n        \"\"\"Parse and validate.\"\"\"\n        if self.crs:\n            if self.crs.startswith(\"[\") and self.crs.endswith(\"]\"):\n                self.crs = self.crs[1:-1]\n            self.crs = CRS.from_user_input(self.crs)  # type: ignore\n\n        if self.bbox_crs:\n            if self.bbox_crs.startswith(\"[\") and self.bbox_crs.endswith(\"]\"):\n                self.bbox_crs = self.bbox_crs[1:-1]\n            self.bbox_crs = CRS.from_user_input(self.bbox_crs)  # type: ignore\n\n        if not self.height and not self.width:\n            self.max_size = 1024\n\n        if self.bbox:\n            bounds = list(map(float, self.bbox.split(\",\")))\n            if len(bounds) == 6:\n                bounds = [bounds[0], bounds[1], bounds[3], bounds[4]]\n\n            self.bbox = bounds  # type: ignore\n\n        if self.f:\n            self.format = ImageType[self.f]\n\n        else:\n            if media := accept_media_type(\n                self.request.headers.get(\"accept\", \"\"),\n                [MediaType[e] for e in ImageType],\n            ):\n                self.format = ImageType[media.name]\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.PartFeatureParams","title":"PartFeatureParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>Common parameters for bbox and feature.</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass PartFeatureParams(DefaultDependency):\n    \"\"\"Common parameters for bbox and feature.\"\"\"\n\n    # NOTE: the part sizes dependency can either be a Query or a Path Parameter\n    max_size: Annotated[\n        Optional[int], Field(description=\"Maximum image size to read onto.\")\n    ] = None\n    height: Annotated[\n        Optional[int], Field(description=\"Force output image height.\")\n    ] = None\n    width: Annotated[Optional[int], Field(description=\"Force output image width.\")] = (\n        None\n    )\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if self.width or self.height:\n            self.max_size = None\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.PreviewParams","title":"PreviewParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>Common Preview parameters.</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass PreviewParams(DefaultDependency):\n    \"\"\"Common Preview parameters.\"\"\"\n\n    # NOTE: sizes dependency can either be a Query or a Path Parameter\n    max_size: Annotated[int, Field(description=\"Maximum image size to read onto.\")] = (\n        1024\n    )\n    height: Annotated[\n        Optional[int], Field(description=\"Force output image height.\")\n    ] = None\n    width: Annotated[Optional[int], Field(description=\"Force output image width.\")] = (\n        None\n    )\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if self.width or self.height:\n            self.max_size = None\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.RenderingParams","title":"RenderingParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>Image Rendering options.</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass RenderingParams(DefaultDependency):\n    \"\"\"Image Rendering options.\"\"\"\n\n    rescale: Annotated[\n        Optional[List[str]],\n        Query(\n            title=\"Min/Max data Rescaling\",\n            description=\"comma (',') delimited Min,Max range. Can set multiple time for multiple bands.\",\n            examples=[\"0,2000\", \"0,1000\", \"0,10000\"],  # band 1  # band 2  # band 3\n        ),\n    ] = None\n\n    color_formula: Annotated[\n        Optional[str],\n        Query(\n            title=\"Color Formula\",\n            description=\"rio-color formula (info: https://github.com/mapbox/rio-color)\",\n        ),\n    ] = None\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Post Init.\"\"\"\n        if self.rescale:\n            rescale_array = []\n            for r in self.rescale:\n                parsed = tuple(\n                    map(\n                        float,\n                        r.replace(\" \", \"\").replace(\"[\", \"\").replace(\"]\", \"\").split(\",\"),\n                    )\n                )\n                assert (\n                    len(parsed) == 2\n                ), f\"Invalid rescale values: {self.rescale}, should be of form ['min,max', 'min,max'] or [[min,max], [min, max]]\"\n                rescale_array.append(parsed)\n\n            self.rescale: RescaleType = rescale_array  # type: ignore\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.StatisticsParams","title":"StatisticsParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>Statistics options.</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass StatisticsParams(DefaultDependency):\n    \"\"\"Statistics options.\"\"\"\n\n    categorical: Annotated[\n        Optional[bool],\n        Query(\n            description=\"Return statistics for categorical dataset. Defaults to `False`\"\n        ),\n    ] = None\n    categories: Annotated[\n        Optional[List[Union[float, int]]],\n        Query(\n            alias=\"c\",\n            title=\"Pixels values for categories.\",\n            description=\"List of values for which to report counts.\",\n            examples=[1, 2, 3],\n        ),\n    ] = None\n    percentiles: Annotated[\n        Optional[List[int]],\n        Query(\n            alias=\"p\",\n            title=\"Percentile values\",\n            description=\"List of percentile values (default to [2, 98]).\",\n            examples=[2, 5, 95, 98],\n        ),\n    ] = None\n\n    def __post_init__(self):\n        \"\"\"Set percentiles default.\"\"\"\n        if not self.percentiles:\n            self.percentiles = [2, 98]\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.TileParams","title":"TileParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>Tile options.</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass TileParams(DefaultDependency):\n    \"\"\"Tile options.\"\"\"\n\n    buffer: Annotated[\n        Optional[float],\n        Query(\n            gt=0,\n            title=\"Tile buffer.\",\n            description=\"Buffer on each side of the given tile. It must be a multiple of `0.5`. Output **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257, 1.0 = 258x258).\",\n        ),\n    ] = None\n\n    padding: Annotated[\n        Optional[int],\n        Query(\n            gt=0,\n            title=\"Tile padding.\",\n            description=\"Padding to apply to each tile edge. Helps reduce resampling artefacts along edges. Defaults to `0`.\",\n        ),\n    ] = None\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.BufferParams","title":"BufferParams","text":"<pre><code>BufferParams(\n    buffer: Annotated[\n        Optional[float],\n        Query(\n            gt=0,\n            title=\"Tile buffer.\",\n            description=\"Buffer on each side of the given tile. It must be a multiple of `0.5`. Output **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257, 1.0 = 258x258).\",\n        ),\n    ] = None,\n) -&gt; Optional[float]\n</code></pre> <p>Tile buffer Parameter.</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>def BufferParams(\n    buffer: Annotated[\n        Optional[float],\n        Query(\n            gt=0,\n            title=\"Tile buffer.\",\n            description=\"Buffer on each side of the given tile. It must be a multiple of `0.5`. Output **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257, 1.0 = 258x258).\",\n        ),\n    ] = None,\n) -&gt; Optional[float]:\n    \"\"\"Tile buffer Parameter.\"\"\"\n    return buffer\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.CRSParams","title":"CRSParams","text":"<pre><code>CRSParams(\n    crs: Annotated[Optional[str], Query(description=\"Coordinate Reference System.\")] = None,\n) -&gt; Optional[CRS]\n</code></pre> <p>Coordinate Reference System Coordinates Param.</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>def CRSParams(\n    crs: Annotated[\n        Optional[str],\n        Query(\n            description=\"Coordinate Reference System.\",\n        ),\n    ] = None,\n) -&gt; Optional[CRS]:\n    \"\"\"Coordinate Reference System Coordinates Param.\"\"\"\n    if crs:\n        return CRS.from_user_input(crs)\n\n    return None\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.CoordCRSParams","title":"CoordCRSParams","text":"<pre><code>CoordCRSParams(\n    crs: Annotated[\n        Optional[str],\n        Query(\n            alias=coord_crs,\n            description=\"Coordinate Reference System of the input coords. Default to `epsg:4326`.\",\n        ),\n    ] = None,\n) -&gt; Optional[CRS]\n</code></pre> <p>Coordinate Reference System Coordinates Param.</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>def CoordCRSParams(\n    crs: Annotated[\n        Optional[str],\n        Query(\n            alias=\"coord_crs\",\n            description=\"Coordinate Reference System of the input coords. Default to `epsg:4326`.\",\n        ),\n    ] = None,\n) -&gt; Optional[CRS]:\n    \"\"\"Coordinate Reference System Coordinates Param.\"\"\"\n    if crs:\n        return CRS.from_user_input(crs)\n\n    return None\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.DatasetPathParams","title":"DatasetPathParams","text":"<pre><code>DatasetPathParams(url: Annotated[str, Query(description='Dataset URL')]) -&gt; str\n</code></pre> <p>Create dataset path from args</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>def DatasetPathParams(url: Annotated[str, Query(description=\"Dataset URL\")]) -&gt; str:\n    \"\"\"Create dataset path from args\"\"\"\n    return url\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.DstCRSParams","title":"DstCRSParams","text":"<pre><code>DstCRSParams(\n    crs: Annotated[\n        Optional[str], Query(alias=dst_crs, description=\"Output Coordinate Reference System.\")\n    ] = None,\n) -&gt; Optional[CRS]\n</code></pre> <p>Coordinate Reference System Coordinates Param.</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>def DstCRSParams(\n    crs: Annotated[\n        Optional[str],\n        Query(\n            alias=\"dst_crs\",\n            description=\"Output Coordinate Reference System.\",\n        ),\n    ] = None,\n) -&gt; Optional[CRS]:\n    \"\"\"Coordinate Reference System Coordinates Param.\"\"\"\n    if crs:\n        return CRS.from_user_input(crs)\n\n    return None\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.create_colormap_dependency","title":"create_colormap_dependency","text":"<pre><code>create_colormap_dependency(cmap: ColorMaps) -&gt; Callable\n</code></pre> <p>Create Colormap Dependency.</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>def create_colormap_dependency(cmap: ColorMaps) -&gt; Callable:\n    \"\"\"Create Colormap Dependency.\"\"\"\n\n    def deps(\n        colormap_name: Annotated[  # type: ignore\n            Literal[tuple(cmap.list())],\n            Query(description=\"Colormap name\"),\n        ] = None,\n        colormap: Annotated[\n            Optional[str], Query(description=\"JSON encoded custom Colormap\")\n        ] = None,\n    ):\n        if colormap_name:\n            return cmap.get(colormap_name)\n\n        if colormap:\n            try:\n                c = json.loads(\n                    colormap,\n                    object_hook=lambda x: {\n                        int(k): parse_color(v) for k, v in x.items()\n                    },\n                )\n\n                # Make sure to match colormap type\n                if isinstance(c, Sequence):\n                    c = [(tuple(inter), parse_color(v)) for (inter, v) in c]\n\n                return c\n            except json.JSONDecodeError as e:\n                raise HTTPException(\n                    status_code=400, detail=\"Could not parse the colormap value.\"\n                ) from e\n\n        return None\n\n    return deps\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.parse_asset_expression","title":"parse_asset_expression","text":"<pre><code>parse_asset_expression(asset_expression: Union[Sequence[str], Dict[str, str]]) -&gt; Dict[str, str]\n</code></pre> <p>parse asset expression parameters.</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>def parse_asset_expression(\n    asset_expression: Union[Sequence[str], Dict[str, str]],\n) -&gt; Dict[str, str]:\n    \"\"\"parse asset expression parameters.\"\"\"\n    return {idx.split(\"|\")[0]: idx.split(\"|\")[1] for idx in asset_expression}\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.parse_asset_indexes","title":"parse_asset_indexes","text":"<pre><code>parse_asset_indexes(\n    asset_indexes: Union[Sequence[str], Dict[str, Sequence[int]]],\n) -&gt; Dict[str, Sequence[int]]\n</code></pre> <p>parse asset indexes parameters.</p> Source code in <code>src/titiler/core/titiler/core/dependencies.py</code> <pre><code>def parse_asset_indexes(\n    asset_indexes: Union[Sequence[str], Dict[str, Sequence[int]]],\n) -&gt; Dict[str, Sequence[int]]:\n    \"\"\"parse asset indexes parameters.\"\"\"\n    return {\n        idx.split(\"|\")[0]: list(map(int, idx.split(\"|\")[1].split(\",\")))\n        for idx in asset_indexes\n    }\n</code></pre>"},{"location":"api/titiler/core/errors/","title":"errors","text":""},{"location":"api/titiler/core/errors/#titiler.core.errors","title":"titiler.core.errors","text":"<p>Titiler error classes.</p>"},{"location":"api/titiler/core/errors/#titiler.core.errors.BadRequestError","title":"BadRequestError","text":"<p>               Bases: <code>TilerError</code></p> <p>Bad request error.</p>"},{"location":"api/titiler/core/errors/#titiler.core.errors.TileNotFoundError","title":"TileNotFoundError","text":"<p>               Bases: <code>TilerError</code></p> <p>Tile not found error.</p>"},{"location":"api/titiler/core/errors/#titiler.core.errors.TilerError","title":"TilerError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception class.</p>"},{"location":"api/titiler/core/errors/#titiler.core.errors.add_exception_handlers","title":"add_exception_handlers","text":"<pre><code>add_exception_handlers(app: FastAPI, status_codes: Dict[Type[Exception], int]) -&gt; None\n</code></pre> <p>Add exception handlers to the FastAPI app.</p>"},{"location":"api/titiler/core/errors/#titiler.core.errors.exception_handler_factory","title":"exception_handler_factory","text":"<pre><code>exception_handler_factory(status_code: int) -&gt; Callable\n</code></pre> <p>Create a FastAPI exception handler from a status code.</p>"},{"location":"api/titiler/core/factory/","title":"factory","text":""},{"location":"api/titiler/core/factory/#titiler.core.factory","title":"titiler.core.factory","text":"<p>TiTiler Router factories.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.AlgorithmFactory","title":"AlgorithmFactory","text":"<p>               Bases: <code>BaseFactory</code></p> <p>Algorithm endpoints Factory.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.AlgorithmFactory._get_algo_metadata","title":"_get_algo_metadata","text":"<pre><code>_get_algo_metadata(algorithm: BaseAlgorithm) -&gt; AlgorithmMetadata\n</code></pre> <p>Algorithm Metadata</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.AlgorithmFactory.register_routes","title":"register_routes","text":"<pre><code>register_routes()\n</code></pre> <p>Register Algorithm routes.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.BaseFactory","title":"BaseFactory","text":"<p>Base Factory.</p> <p>Abstract Base Class which defines most inputs used by dynamic tiler.</p> <p>Attributes:</p> <ul> <li> <code>router</code>               (<code>APIRouter</code>)           \u2013            <p>Application router to register endpoints to.</p> </li> <li> <code>router_prefix</code>               (<code>str</code>)           \u2013            <p>prefix where the router will be mounted in the application.</p> </li> <li> <code>route_dependencies</code>               (<code>list</code>)           \u2013            <p>Additional routes dependencies to add after routes creations.</p> </li> </ul>"},{"location":"api/titiler/core/factory/#titiler.core.factory.BaseFactory.__attrs_post_init__","title":"__attrs_post_init__","text":"<pre><code>__attrs_post_init__()\n</code></pre> <p>Post Init: register route and configure specific options.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.BaseFactory.add_route_dependencies","title":"add_route_dependencies","text":"<pre><code>add_route_dependencies(*, scopes: List[EndpointScope], dependencies=List[Depends])\n</code></pre> <p>Add dependencies to routes.</p> <p>Allows a developer to add dependencies to a route after the route has been defined.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.BaseFactory.add_telemetry","title":"add_telemetry","text":"<pre><code>add_telemetry()\n</code></pre> <p>Applies the factory_trace decorator to all registered API routes.</p> <p>This method iterates through the router's routes and wraps the endpoint of each APIRoute to ensure consistent OpenTelemetry tracing.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.BaseFactory.register_routes","title":"register_routes  <code>abstractmethod</code>","text":"<pre><code>register_routes()\n</code></pre> <p>Register Routes.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.BaseFactory.url_for","title":"url_for","text":"<pre><code>url_for(request: Request, name: str, **path_params: Any) -&gt; str\n</code></pre> <p>Return full url (with prefix) for a specific endpoint.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.ColorMapFactory","title":"ColorMapFactory","text":"<p>               Bases: <code>BaseFactory</code></p> <p>Colormap endpoints Factory.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.ColorMapFactory._image_from_colormap","title":"_image_from_colormap","text":"<pre><code>_image_from_colormap(\n    cmap,\n    orientation: Optional[Literal[\"vertical\", \"horizontal\"]] = None,\n    width: Optional[int] = None,\n    height: Optional[int] = None,\n) -&gt; ImageData\n</code></pre> <p>Create an image from a colormap.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.ColorMapFactory.register_routes","title":"register_routes","text":"<pre><code>register_routes()\n</code></pre> <p>Register ColorMap routes.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.FactoryExtension","title":"FactoryExtension","text":"<p>Factory Extension.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.FactoryExtension.register","title":"register  <code>abstractmethod</code>","text":"<pre><code>register(factory: BaseFactory)\n</code></pre> <p>Register extension to the factory.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.MultiBandTilerFactory","title":"MultiBandTilerFactory","text":"<p>               Bases: <code>TilerFactory</code></p> <p>Custom Tiler Factory for MultiBandReader classes.</p> Note <p>To be able to use the rio_tiler.io.MultiBandReader we need to be able to pass a <code>bands</code> argument to most of its methods. By using the <code>BandsExprParams</code> for the <code>layer_dependency</code>, the .tile(), .point(), .preview() and the .part() methods will receive bands or expression arguments.</p> <p>The rio_tiler.io.MultiBandReader  <code>.info()</code> and <code>.metadata()</code> have <code>bands</code> as a requirement arguments (github.com/cogeotiff/rio-tiler/blob/main/rio_tiler/io/base.py#L775). This means we have to update the /info and /metadata endpoints in order to add the <code>bands</code> dependency.</p> <p>For implementation example see developmentseed/titiler-pds</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.MultiBandTilerFactory.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Register /info endpoint.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.MultiBandTilerFactory.statistics","title":"statistics","text":"<pre><code>statistics()\n</code></pre> <p>add statistics endpoints.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.MultiBaseTilerFactory","title":"MultiBaseTilerFactory","text":"<p>               Bases: <code>TilerFactory</code></p> <p>Custom Tiler Factory for MultiBaseReader classes.</p> Note <p>To be able to use the rio_tiler.io.MultiBaseReader we need to be able to pass a <code>assets</code> argument to most of its methods. By using the <code>AssetsBidxExprParams</code> for the <code>layer_dependency</code>, the .tile(), .point(), .preview() and the .part() methods will receive assets, expression or indexes arguments.</p> <p>The rio_tiler.io.MultiBaseReader  <code>.info()</code> and <code>.metadata()</code> have <code>assets</code> as a requirement arguments (github.com/cogeotiff/rio-tiler/blob/main/rio_tiler/io/base.py#L365). This means we have to update the /info and /metadata endpoints in order to add the <code>assets</code> dependency.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.MultiBaseTilerFactory.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Register /info endpoint.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.MultiBaseTilerFactory.statistics","title":"statistics","text":"<pre><code>statistics()\n</code></pre> <p>Register /statistics endpoint.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TMSFactory","title":"TMSFactory","text":"<p>               Bases: <code>BaseFactory</code></p> <p>TileMatrixSet endpoints Factory.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TMSFactory.register_routes","title":"register_routes","text":"<pre><code>register_routes()\n</code></pre> <p>Register TMS endpoint routes.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TilerFactory","title":"TilerFactory","text":"<p>               Bases: <code>BaseFactory</code></p> <p>Tiler Factory.</p> <p>Attributes:</p> <ul> <li> <code>reader</code>               (<code>BaseReader</code>)           \u2013            <p>A rio-tiler reader. Defaults to <code>rio_tiler.io.Reader</code>.</p> </li> <li> <code>reader_dependency</code>               (<code>DefaultDependency</code>)           \u2013            <p>Endpoint dependency defining BaseReader options.</p> </li> <li> <code>path_dependency</code>               (<code>Callable</code>)           \u2013            <p>Endpoint dependency defining <code>path</code> to pass to the reader init.</p> </li> <li> <code>layer_dependency</code>               (<code>DefaultDependency</code>)           \u2013            <p>Endpoint dependency defining dataset indexes/bands/assets options.</p> </li> <li> <code>dataset_dependency</code>               (<code>DefaultDependency</code>)           \u2013            <p>Endpoint dependency defining dataset overwriting options (e.g nodata).</p> </li> <li> <code>tile_dependency</code>               (<code>DefaultDependency</code>)           \u2013            <p>Endpoint dependency defining tile options (e.g buffer, padding).</p> </li> <li> <code>stats_dependency</code>               (<code>DefaultDependency</code>)           \u2013            <p>Endpoint dependency defining options for rio-tiler's statistics method.</p> </li> <li> <code>histogram_dependency</code>               (<code>DefaultDependency</code>)           \u2013            <p>Endpoint dependency defining options for numpy's histogram method.</p> </li> <li> <code>img_preview_dependency</code>               (<code>DefaultDependency</code>)           \u2013            <p>Endpoint dependency defining options for rio-tiler's preview method.</p> </li> <li> <code>img_part_dependency</code>               (<code>DefaultDependency</code>)           \u2013            <p>Endpoint dependency defining options for rio-tiler's part/feature methods.</p> </li> <li> <code>process_dependency</code>               (<code>DefaultDependency</code>)           \u2013            <p>Endpoint dependency defining image post-processing options (e.g rescaling, color-formula).</p> </li> <li> <code>rescale_dependency</code>               (<code>Callable[..., Optional[RescaleType]]</code>)           \u2013            </li> <li> <code>color_formula_dependency</code>               (<code>Callable[..., Optional[str]]</code>)           \u2013            </li> <li> <code>colormap_dependency</code>               (<code>Callable</code>)           \u2013            <p>Endpoint dependency defining ColorMap options (e.g colormap_name).</p> </li> <li> <code>render_dependency</code>               (<code>DefaultDependency</code>)           \u2013            <p>Endpoint dependency defining image rendering options (e.g add_mask).</p> </li> <li> <code>environment_dependency</code>               (<code>Callable</code>)           \u2013            <p>Endpoint dependency to define GDAL environment at runtime.</p> </li> <li> <code>supported_tms</code>               (<code>TileMatrixSets</code>)           \u2013            <p>TileMatrixSets object holding the supported TileMatrixSets.</p> </li> <li> <code>templates</code>               (<code>Jinja2Templates</code>)           \u2013            <p>Jinja2 templates.</p> </li> <li> <code>add_preview</code>               (<code>bool</code>)           \u2013            <p>add <code>/preview</code> endpoints. Defaults to True.</p> </li> <li> <code>add_part</code>               (<code>bool</code>)           \u2013            <p>add <code>/bbox</code> and <code>/feature</code> endpoints. Defaults to True.</p> </li> <li> <code>add_viewer</code>               (<code>bool</code>)           \u2013            <p>add <code>/map.html</code> endpoints. Defaults to True.</p> </li> </ul>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TilerFactory.bounds","title":"bounds","text":"<pre><code>bounds()\n</code></pre> <p>Register /bounds endpoint.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TilerFactory.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Register /info endpoint.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TilerFactory.map_viewer","title":"map_viewer","text":"<pre><code>map_viewer()\n</code></pre> <p>Register /map.html endpoint.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TilerFactory.ogc_maps","title":"ogc_maps","text":"<pre><code>ogc_maps()\n</code></pre> <p>Register OGC Maps /map` endpoint.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TilerFactory.part","title":"part","text":"<pre><code>part()\n</code></pre> <p>Register /bbox and <code>/feature</code> endpoints.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TilerFactory.point","title":"point","text":"<pre><code>point()\n</code></pre> <p>Register /point endpoints.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TilerFactory.preview","title":"preview","text":"<pre><code>preview()\n</code></pre> <p>Register /preview endpoint.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TilerFactory.register_routes","title":"register_routes","text":"<pre><code>register_routes()\n</code></pre> <p>This Method register routes to the router.</p> <p>Because we wrap the endpoints in a class we cannot define the routes as methods (because of the self argument). The HACK is to define routes inside the class method and register them after the class initialization.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TilerFactory.statistics","title":"statistics","text":"<pre><code>statistics()\n</code></pre> <p>add statistics endpoints.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TilerFactory.tile","title":"tile","text":"<pre><code>tile()\n</code></pre> <p>Register /tiles endpoint.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TilerFactory.tilejson","title":"tilejson","text":"<pre><code>tilejson()\n</code></pre> <p>Register /tilejson.json endpoint.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TilerFactory.tilesets","title":"tilesets","text":"<pre><code>tilesets()\n</code></pre> <p>Register OGC tilesets endpoints.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TilerFactory.wmts","title":"wmts","text":"<pre><code>wmts()\n</code></pre> <p>Register /wmts endpoint.</p>"},{"location":"api/titiler/core/middleware/","title":"middleware","text":""},{"location":"api/titiler/core/middleware/#titiler.core.middleware","title":"titiler.core.middleware","text":"<p>Titiler middlewares.</p>"},{"location":"api/titiler/core/middleware/#titiler.core.middleware.CacheControlMiddleware","title":"CacheControlMiddleware  <code>dataclass</code>","text":"<p>MiddleWare to add CacheControl in response headers.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>ASGIApp</code>)           \u2013            <p>starlette/FastAPI application.</p> </li> <li> <code>cachecontrol</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Cache-Control string to add to the response.</p> </li> <li> <code>exclude_path</code>               (<code>set</code>, default:                   <code>set()</code> )           \u2013            <p>Set of regex expression to use to filter the path.</p> </li> </ul>"},{"location":"api/titiler/core/middleware/#titiler.core.middleware.CacheControlMiddleware.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(scope: Scope, receive: Receive, send: Send)\n</code></pre> <p>Handle call.</p>"},{"location":"api/titiler/core/middleware/#titiler.core.middleware.LoggerMiddleware","title":"LoggerMiddleware  <code>dataclass</code>","text":"<p>MiddleWare to add logging.</p>"},{"location":"api/titiler/core/middleware/#titiler.core.middleware.LoggerMiddleware.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(scope: Scope, receive: Receive, send: Send)\n</code></pre> <p>Handle call.</p>"},{"location":"api/titiler/core/middleware/#titiler.core.middleware.LowerCaseQueryStringMiddleware","title":"LowerCaseQueryStringMiddleware  <code>dataclass</code>","text":"<p>Middleware to make URL parameters case-insensitive. taken from: tiangolo/fastapi#826</p>"},{"location":"api/titiler/core/middleware/#titiler.core.middleware.LowerCaseQueryStringMiddleware.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(scope: Scope, receive: Receive, send: Send)\n</code></pre> <p>Handle call.</p>"},{"location":"api/titiler/core/middleware/#titiler.core.middleware.TotalTimeMiddleware","title":"TotalTimeMiddleware  <code>dataclass</code>","text":"<p>MiddleWare to add Total process time in response headers.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>ASGIApp</code>)           \u2013            <p>starlette/FastAPI application.</p> </li> </ul>"},{"location":"api/titiler/core/middleware/#titiler.core.middleware.TotalTimeMiddleware.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(scope: Scope, receive: Receive, send: Send)\n</code></pre> <p>Handle call.</p>"},{"location":"api/titiler/core/routing/","title":"routing","text":""},{"location":"api/titiler/core/routing/#titiler.core.routing","title":"titiler.core.routing","text":"<p>Custom routing classes.</p>"},{"location":"api/titiler/core/routing/#titiler.core.routing.EndpointScope","title":"EndpointScope","text":"<p>               Bases: <code>TypedDict</code></p> <p>Define endpoint.</p>"},{"location":"api/titiler/core/routing/#titiler.core.routing.add_route_dependencies","title":"add_route_dependencies","text":"<pre><code>add_route_dependencies(\n    routes: List[BaseRoute], *, scopes: List[EndpointScope], dependencies=List[Depends]\n)\n</code></pre> <p>Add dependencies to routes.</p> <p>Allows a developer to add dependencies to a route after the route has been defined.</p>"},{"location":"api/titiler/core/routing/#titiler.core.routing.apiroute_factory","title":"apiroute_factory","text":"<pre><code>apiroute_factory(env: Optional[Dict] = None) -&gt; Type[APIRoute]\n</code></pre> <p>Create Custom API Route class with custom Env.</p> <p>Because we cannot create middleware for specific router we need to create a custom APIRoute which add the <code>rasterio.Env(</code> block before the endpoint is actually called. This way we set the env outside the threads and we make sure that event multithreaded Reader will get the environment set.</p> <p>Note: This has been tested in python 3.6 and 3.7 only.</p>"},{"location":"api/titiler/core/models/OGC/","title":"OGC","text":""},{"location":"api/titiler/core/models/OGC/#titiler.core.models.OGC","title":"titiler.core.models.OGC","text":"<p>OGC models.</p>"},{"location":"api/titiler/core/models/OGC/#titiler.core.models.OGC.BoundingBox","title":"BoundingBox","text":"<p>               Bases: <code>BaseModel</code></p> <p>BoundingBox model.</p> <p>Ref: github.com/opengeospatial/ogcapi-tiles/blob/master/openapi/schemas/tms/2DBoundingBox.yaml</p> <p>Code generated using koxudaxi/datamodel-code-generator</p>"},{"location":"api/titiler/core/models/OGC/#titiler.core.models.OGC.Conformance","title":"Conformance","text":"<p>               Bases: <code>BaseModel</code></p> <p>Conformance model.</p> <p>Ref: schemas.opengis.net/ogcapi/features/part1/1.0/openapi/schemas/confClasses.yaml</p>"},{"location":"api/titiler/core/models/OGC/#titiler.core.models.OGC.GeospatialData","title":"GeospatialData","text":"<p>               Bases: <code>BaseModel</code></p> <p>Geospatial model.</p> <p>Ref: github.com/opengeospatial/ogcapi-tiles/blob/master/openapi/schemas/tms/geospatialData.yaml</p> <p>Code generated using koxudaxi/datamodel-code-generator</p>"},{"location":"api/titiler/core/models/OGC/#titiler.core.models.OGC.Landing","title":"Landing","text":"<p>               Bases: <code>BaseModel</code></p> <p>Landing page model.</p> <p>Ref: schemas.opengis.net/ogcapi/features/part1/1.0/openapi/schemas/landingPage.yaml</p>"},{"location":"api/titiler/core/models/OGC/#titiler.core.models.OGC.Properties","title":"Properties","text":"<p>               Bases: <code>BaseModel</code></p> <p>Properties model.</p> <p>Ref: github.com/opengeospatial/ogcapi-tiles/blob/master/openapi/schemas/tms/propertiesSchema.yaml</p> <p>Code generated using koxudaxi/datamodel-code-generator</p>"},{"location":"api/titiler/core/models/OGC/#titiler.core.models.OGC.PropertiesSchema","title":"PropertiesSchema","text":"<p>               Bases: <code>BaseModel</code></p> <p>PropertiesSchema model.</p> <p>Ref: github.com/opengeospatial/ogcapi-tiles/blob/master/openapi/schemas/tms/propertiesSchema.yaml</p> <p>Code generated using koxudaxi/datamodel-code-generator</p>"},{"location":"api/titiler/core/models/OGC/#titiler.core.models.OGC.Style","title":"Style","text":"<p>               Bases: <code>BaseModel</code></p> <p>Style model.</p> <p>Ref: github.com/opengeospatial/ogcapi-tiles/blob/master/openapi/schemas/tms/style.yaml</p> <p>Code generated using koxudaxi/datamodel-code-generator</p>"},{"location":"api/titiler/core/models/OGC/#titiler.core.models.OGC.TileMatrixLimits","title":"TileMatrixLimits","text":"<p>               Bases: <code>BaseModel</code></p> <p>The limits for an individual tile matrix of a TileSet's TileMatrixSet, as defined in the OGC 2D TileMatrixSet and TileSet Metadata Standard</p> <p>Based on github.com/opengeospatial/ogcapi-tiles/blob/master/openapi/schemas/tms/tileMatrixLimits.yaml</p>"},{"location":"api/titiler/core/models/OGC/#titiler.core.models.OGC.TileMatrixSetList","title":"TileMatrixSetList","text":"<p>               Bases: <code>BaseModel</code></p> <p>TileMatrixSetList model.</p> <p>Based on docs.opengeospatial.org/per/19-069.html#_tilematrixsets</p>"},{"location":"api/titiler/core/models/OGC/#titiler.core.models.OGC.TileMatrixSetRef","title":"TileMatrixSetRef","text":"<p>               Bases: <code>BaseModel</code></p> <p>TileMatrixSetRef model.</p> <p>Based on docs.opengeospatial.org/per/19-069.html#_tilematrixsets</p>"},{"location":"api/titiler/core/models/OGC/#titiler.core.models.OGC.TilePoint","title":"TilePoint","text":"<p>               Bases: <code>BaseModel</code></p> <p>TilePoint model.</p> <p>Ref: github.com/opengeospatial/ogcapi-tiles/blob/master/openapi/schemas/tms/tilePoint.yaml</p> <p>Code generated using koxudaxi/datamodel-code-generator</p>"},{"location":"api/titiler/core/models/OGC/#titiler.core.models.OGC.TileSet","title":"TileSet","text":"<p>               Bases: <code>BaseModel</code></p> <p>TileSet model.</p> <p>Based on github.com/opengeospatial/ogcapi-tiles/blob/master/openapi/schemas/tms/tileSet.yaml</p>"},{"location":"api/titiler/core/models/OGC/#titiler.core.models.OGC.TileSetList","title":"TileSetList","text":"<p>               Bases: <code>BaseModel</code></p> <p>TileSetList model.</p> <p>Based on docs.ogc.org/is/20-057/20-057.html#toc34</p>"},{"location":"api/titiler/core/models/OGC/#titiler.core.models.OGC.TimeStamp","title":"TimeStamp","text":"<p>               Bases: <code>RootModel</code></p> <p>TimeStamp model.</p> <p>Ref: github.com/opengeospatial/ogcapi-tiles/blob/master/openapi/schemas/common-geodata/timeStamp.yaml</p> <p>Code generated using koxudaxi/datamodel-code-generator</p>"},{"location":"api/titiler/core/models/mapbox/","title":"Mapbox/MapLibre","text":""},{"location":"api/titiler/core/models/mapbox/#titiler.core.models.mapbox","title":"titiler.core.models.mapbox","text":"<p>Common response models.</p>"},{"location":"api/titiler/core/models/mapbox/#titiler.core.models.mapbox.LayerJSON","title":"LayerJSON","text":"<p>               Bases: <code>BaseModel</code></p> <p>github.com/mapbox/tilejson-spec/tree/master/3.0.0#33-vector_layers</p>"},{"location":"api/titiler/core/models/mapbox/#titiler.core.models.mapbox.TileJSON","title":"TileJSON","text":"<p>               Bases: <code>BaseModel</code></p> <p>TileJSON model.</p> <p>Based on github.com/mapbox/tilejson-spec/tree/master/3.0.0</p>"},{"location":"api/titiler/core/models/mapbox/#titiler.core.models.mapbox.TileJSON.compute_center","title":"compute_center","text":"<pre><code>compute_center()\n</code></pre> <p>Compute center if it does not exist.</p>"},{"location":"api/titiler/core/models/responses/","title":"responses","text":""},{"location":"api/titiler/core/models/responses/#titiler.core.models.responses","title":"titiler.core.models.responses","text":"<p>TiTiler response models.</p>"},{"location":"api/titiler/core/models/responses/#titiler.core.models.responses.ColorMapList","title":"ColorMapList","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for colormap list.</p>"},{"location":"api/titiler/core/models/responses/#titiler.core.models.responses.ColorMapRef","title":"ColorMapRef","text":"<p>               Bases: <code>BaseModel</code></p> <p>ColorMapRef model.</p>"},{"location":"api/titiler/core/models/responses/#titiler.core.models.responses.Point","title":"Point","text":"<p>               Bases: <code>BaseModel</code></p> <p>Point model.</p> <p>response model for <code>/point</code> endpoints</p>"},{"location":"api/titiler/core/models/responses/#titiler.core.models.responses.StatisticsInGeoJSON","title":"StatisticsInGeoJSON","text":"<p>               Bases: <code>BaseModel</code></p> <p>Statistics model in geojson response.</p>"},{"location":"api/titiler/core/resources/enums/","title":"enums","text":""},{"location":"api/titiler/core/resources/enums/#titiler.core.resources.enums","title":"titiler.core.resources.enums","text":"<p>Titiler.core Enums.</p>"},{"location":"api/titiler/core/resources/enums/#titiler.core.resources.enums.ImageDriver","title":"ImageDriver","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Supported output GDAL drivers.</p>"},{"location":"api/titiler/core/resources/enums/#titiler.core.resources.enums.ImageType","title":"ImageType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Available Output image type.</p>"},{"location":"api/titiler/core/resources/enums/#titiler.core.resources.enums.ImageType.driver","title":"driver","text":"<pre><code>driver()\n</code></pre> <p>Return rio-tiler image default profile.</p>"},{"location":"api/titiler/core/resources/enums/#titiler.core.resources.enums.ImageType.mediatype","title":"mediatype","text":"<pre><code>mediatype()\n</code></pre> <p>Return image media type.</p>"},{"location":"api/titiler/core/resources/enums/#titiler.core.resources.enums.ImageType.profile","title":"profile","text":"<pre><code>profile()\n</code></pre> <p>Return rio-tiler image default profile.</p>"},{"location":"api/titiler/core/resources/enums/#titiler.core.resources.enums.MediaType","title":"MediaType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Responses Media types formerly known as MIME types.</p>"},{"location":"api/titiler/core/resources/enums/#titiler.core.resources.enums.OptionalHeader","title":"OptionalHeader","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Optional Header to add in responses.</p>"},{"location":"api/titiler/core/resources/responses/","title":"responses","text":""},{"location":"api/titiler/core/resources/responses/#titiler.core.resources.responses","title":"titiler.core.resources.responses","text":"<p>Common response models.</p>"},{"location":"api/titiler/core/resources/responses/#titiler.core.resources.responses.GeoJSONResponse","title":"GeoJSONResponse","text":"<p>               Bases: <code>JSONResponse</code></p> <p>GeoJSON Response</p>"},{"location":"api/titiler/core/resources/responses/#titiler.core.resources.responses.JSONResponse","title":"JSONResponse","text":"<p>               Bases: <code>JSONResponse</code></p> <p>Custom JSON Response.</p>"},{"location":"api/titiler/core/resources/responses/#titiler.core.resources.responses.JSONResponse.render","title":"render","text":"<pre><code>render(content: Any) -&gt; bytes\n</code></pre> <p>Render JSON.</p> <p>Same defaults as starlette.responses.JSONResponse.render but allow NaN to be replaced by null using simplejson</p>"},{"location":"api/titiler/core/resources/responses/#titiler.core.resources.responses.NumpyEncoder","title":"NumpyEncoder","text":"<p>               Bases: <code>JSONEncoder</code></p> <p>Custom JSON Encoder.</p>"},{"location":"api/titiler/core/resources/responses/#titiler.core.resources.responses.NumpyEncoder.default","title":"default","text":"<pre><code>default(obj)\n</code></pre> <p>Catch numpy types and convert them.</p>"},{"location":"api/titiler/core/resources/responses/#titiler.core.resources.responses.XMLResponse","title":"XMLResponse","text":"<p>               Bases: <code>Response</code></p> <p>XML Response</p>"},{"location":"api/titiler/extensions/cogeo/","title":"cogeo","text":""},{"location":"api/titiler/extensions/cogeo/#titiler.extensions.cogeo","title":"titiler.extensions.cogeo","text":"<p>rio-cogeo Extension.</p>"},{"location":"api/titiler/extensions/cogeo/#titiler.extensions.cogeo.cogValidateExtension","title":"cogValidateExtension","text":"<p>               Bases: <code>FactoryExtension</code></p> <p>Add /validate endpoint to a COG TilerFactory.</p>"},{"location":"api/titiler/extensions/cogeo/#titiler.extensions.cogeo.cogValidateExtension.register","title":"register","text":"<pre><code>register(factory: TilerFactory)\n</code></pre> <p>Register endpoint to the tiler factory.</p>"},{"location":"api/titiler/extensions/stac/","title":"stac","text":""},{"location":"api/titiler/extensions/stac/#titiler.extensions.stac","title":"titiler.extensions.stac","text":"<p>rio-stac Extension.</p>"},{"location":"api/titiler/extensions/stac/#titiler.extensions.stac.Item","title":"Item","text":"<p>               Bases: <code>TypedDict</code></p> <p>STAC Item.</p>"},{"location":"api/titiler/extensions/stac/#titiler.extensions.stac.stacExtension","title":"stacExtension","text":"<p>               Bases: <code>FactoryExtension</code></p> <p>Add /stac endpoint to a COG TilerFactory.</p>"},{"location":"api/titiler/extensions/stac/#titiler.extensions.stac.stacExtension.register","title":"register","text":"<pre><code>register(factory: TilerFactory)\n</code></pre> <p>Register endpoint to the tiler factory.</p>"},{"location":"api/titiler/extensions/viewer/","title":"viewer","text":""},{"location":"api/titiler/extensions/viewer/#titiler.extensions.viewer","title":"titiler.extensions.viewer","text":"<p>titiler Viewer Extensions.</p>"},{"location":"api/titiler/extensions/viewer/#titiler.extensions.viewer.cogViewerExtension","title":"cogViewerExtension","text":"<p>               Bases: <code>FactoryExtension</code></p> <p>Add /viewer endpoint to the TilerFactory.</p>"},{"location":"api/titiler/extensions/viewer/#titiler.extensions.viewer.cogViewerExtension.register","title":"register","text":"<pre><code>register(factory: TilerFactory)\n</code></pre> <p>Register endpoint to the tiler factory.</p>"},{"location":"api/titiler/extensions/viewer/#titiler.extensions.viewer.stacViewerExtension","title":"stacViewerExtension","text":"<p>               Bases: <code>FactoryExtension</code></p> <p>Add /viewer endpoint to the TilerFactory.</p>"},{"location":"api/titiler/extensions/viewer/#titiler.extensions.viewer.stacViewerExtension.register","title":"register","text":"<pre><code>register(factory: TilerFactory)\n</code></pre> <p>Register endpoint to the tiler factory.</p>"},{"location":"api/titiler/mosaic/errors/","title":"errors","text":""},{"location":"api/titiler/mosaic/errors/#titiler.mosaic.errors","title":"titiler.mosaic.errors","text":"<p>Titiler mosaic errors.</p>"},{"location":"api/titiler/mosaic/factory/","title":"factory","text":""},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory","title":"titiler.mosaic.factory","text":"<p>TiTiler.mosaic Router factories.</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.MosaicTilerFactory","title":"MosaicTilerFactory","text":"<p>               Bases: <code>BaseFactory</code></p> <p>MosaicTiler Factory.</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.MosaicTilerFactory.assets","title":"assets","text":"<pre><code>assets()\n</code></pre> <p>Register /assets endpoint.</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.MosaicTilerFactory.bounds","title":"bounds","text":"<pre><code>bounds()\n</code></pre> <p>Register /bounds endpoint.</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.MosaicTilerFactory.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Register /info endpoint</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.MosaicTilerFactory.map_viewer","title":"map_viewer","text":"<pre><code>map_viewer()\n</code></pre> <p>Register /map.html endpoint.</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.MosaicTilerFactory.point","title":"point","text":"<pre><code>point()\n</code></pre> <p>Register /point endpoint.</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.MosaicTilerFactory.read","title":"read","text":"<pre><code>read()\n</code></pre> <p>Register / (Get) Read endpoint.</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.MosaicTilerFactory.register_routes","title":"register_routes","text":"<pre><code>register_routes()\n</code></pre> <p>This Method register routes to the router.</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.MosaicTilerFactory.tile","title":"tile","text":"<pre><code>tile()\n</code></pre> <p>Register /tiles endpoints.</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.MosaicTilerFactory.tilejson","title":"tilejson","text":"<pre><code>tilejson()\n</code></pre> <p>Add tilejson endpoint.</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.MosaicTilerFactory.tilesets","title":"tilesets","text":"<pre><code>tilesets()\n</code></pre> <p>Register OGC tilesets endpoints.</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.MosaicTilerFactory.validate","title":"validate","text":"<pre><code>validate()\n</code></pre> <p>Register /validate endpoint.</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.MosaicTilerFactory.wmts","title":"wmts","text":"<pre><code>wmts()\n</code></pre> <p>Add wmts endpoint.</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.DatasetPathParams","title":"DatasetPathParams","text":"<pre><code>DatasetPathParams(url: Annotated[str, Query(description='Mosaic URL')]) -&gt; str\n</code></pre> <p>Create dataset path from args</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.PixelSelectionParams","title":"PixelSelectionParams","text":"<pre><code>PixelSelectionParams(\n    pixel_selection: Annotated[\n        Literal[tuple([(name) for e in PixelSelectionMethod])],\n        Query(description=\"Pixel selection method.\"),\n    ] = \"first\",\n) -&gt; MosaicMethodBase\n</code></pre> <p>Returns the mosaic method used to combine datasets together.</p>"},{"location":"api/titiler/mosaic/models/responses/","title":"responses","text":""},{"location":"api/titiler/mosaic/models/responses/#titiler.mosaic.models.responses","title":"titiler.mosaic.models.responses","text":"<p>TiTiler.mosaic response models.</p>"},{"location":"api/titiler/mosaic/models/responses/#titiler.mosaic.models.responses.Point","title":"Point","text":"<p>               Bases: <code>BaseModel</code></p> <p>Point model.</p> <p>response model for <code>/point</code> endpoints</p>"},{"location":"api/titiler/xarray/dependencies/","title":"dependencies","text":""},{"location":"api/titiler/xarray/dependencies/#titiler.xarray.dependencies","title":"titiler.xarray.dependencies","text":"<p>titiler.xarray dependencies.</p>"},{"location":"api/titiler/xarray/dependencies/#titiler.xarray.dependencies.CompatXarrayParams","title":"CompatXarrayParams  <code>dataclass</code>","text":"<p>               Bases: <code>XarrayIOParams</code></p> <p>Custom XarrayParams endpoints.</p> <p>This Dependency aims to be used in a tiler where both GDAL/Xarray dataset would be supported. By default <code>variable</code> won't be required but when using an Xarray dataset, it would fail without the variable query-parameter set.</p>"},{"location":"api/titiler/xarray/dependencies/#titiler.xarray.dependencies.DatasetParams","title":"DatasetParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>Low level WarpedVRT Optional parameters.</p>"},{"location":"api/titiler/xarray/dependencies/#titiler.xarray.dependencies.PartFeatureParams","title":"PartFeatureParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>Common parameters for bbox and feature.</p>"},{"location":"api/titiler/xarray/dependencies/#titiler.xarray.dependencies.PreviewParams","title":"PreviewParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>Common Preview parameters.</p>"},{"location":"api/titiler/xarray/dependencies/#titiler.xarray.dependencies.XarrayDsParams","title":"XarrayDsParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>Xarray Dataset Options.</p>"},{"location":"api/titiler/xarray/dependencies/#titiler.xarray.dependencies.XarrayIOParams","title":"XarrayIOParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>Dataset IO Options.</p>"},{"location":"api/titiler/xarray/dependencies/#titiler.xarray.dependencies.XarrayParams","title":"XarrayParams  <code>dataclass</code>","text":"<p>               Bases: <code>XarrayIOParams</code>, <code>XarrayDsParams</code></p> <p>Xarray Reader dependency.</p>"},{"location":"api/titiler/xarray/extensions/","title":"extensions","text":""},{"location":"api/titiler/xarray/extensions/#titiler.xarray.extensions","title":"titiler.xarray.extensions","text":"<p>titiler.xarray Extensions.</p>"},{"location":"api/titiler/xarray/extensions/#titiler.xarray.extensions.DatasetMetadataExtension","title":"DatasetMetadataExtension","text":"<p>               Bases: <code>FactoryExtension</code></p> <p>Add dataset metadata endpoints to a Xarray TilerFactory.</p>"},{"location":"api/titiler/xarray/extensions/#titiler.xarray.extensions.DatasetMetadataExtension.register","title":"register","text":"<pre><code>register(factory: TilerFactory)\n</code></pre> <p>Register endpoint to the tiler factory.</p>"},{"location":"api/titiler/xarray/extensions/#titiler.xarray.extensions.VariablesExtension","title":"VariablesExtension","text":"<p>               Bases: <code>FactoryExtension</code></p> <p>Add /variables endpoint to a Xarray TilerFactory.</p>"},{"location":"api/titiler/xarray/extensions/#titiler.xarray.extensions.VariablesExtension.__attrs_post_init__","title":"__attrs_post_init__","text":"<pre><code>__attrs_post_init__()\n</code></pre> <p>raise deprecation warning.</p>"},{"location":"api/titiler/xarray/extensions/#titiler.xarray.extensions.VariablesExtension.register","title":"register","text":"<pre><code>register(factory: TilerFactory)\n</code></pre> <p>Register endpoint to the tiler factory.</p>"},{"location":"api/titiler/xarray/factory/","title":"factory","text":""},{"location":"api/titiler/xarray/factory/#titiler.xarray.factory","title":"titiler.xarray.factory","text":"<p>TiTiler.xarray factory.</p>"},{"location":"api/titiler/xarray/factory/#titiler.xarray.factory.TilerFactory","title":"TilerFactory","text":"<p>               Bases: <code>TilerFactory</code></p> <p>Xarray Tiler Factory.</p>"},{"location":"api/titiler/xarray/factory/#titiler.xarray.factory.TilerFactory.__attrs_post_init__","title":"__attrs_post_init__","text":"<pre><code>__attrs_post_init__()\n</code></pre> <p>Raise warning if preview is enabled.</p>"},{"location":"api/titiler/xarray/factory/#titiler.xarray.factory.TilerFactory.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Register /info endpoint.</p>"},{"location":"api/titiler/xarray/factory/#titiler.xarray.factory.TilerFactory.statistics","title":"statistics","text":"<pre><code>statistics()\n</code></pre> <p>add statistics endpoints.</p>"},{"location":"api/titiler/xarray/io/","title":"io","text":""},{"location":"api/titiler/xarray/io/#titiler.xarray.io","title":"titiler.xarray.io","text":"<p>titiler.xarray.io</p>"},{"location":"api/titiler/xarray/io/#titiler.xarray.io.Reader","title":"Reader","text":"<p>               Bases: <code>XarrayReader</code></p> <p>Reader: Open Zarr file and access DataArray.</p>"},{"location":"api/titiler/xarray/io/#titiler.xarray.io.Reader.__attrs_post_init__","title":"__attrs_post_init__","text":"<pre><code>__attrs_post_init__()\n</code></pre> <p>Set bounds and CRS.</p>"},{"location":"api/titiler/xarray/io/#titiler.xarray.io.Reader.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_value, traceback)\n</code></pre> <p>Support using with Context Managers.</p>"},{"location":"api/titiler/xarray/io/#titiler.xarray.io.Reader.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close xarray dataset.</p>"},{"location":"api/titiler/xarray/io/#titiler.xarray.io._arrange_dims","title":"_arrange_dims","text":"<pre><code>_arrange_dims(da: DataArray) -&gt; DataArray\n</code></pre> <p>Arrange coordinates and time dimensions.</p> <p>An rioxarray.exceptions.InvalidDimensionOrder error is raised if the coordinates are not in the correct order time, y, and x. See: corteva/rioxarray?674</p> <p>We conform to using x and y as the spatial dimension names..</p>"},{"location":"api/titiler/xarray/io/#titiler.xarray.io.get_variable","title":"get_variable","text":"<pre><code>get_variable(\n    ds: Dataset,\n    variable: str,\n    sel: Optional[List[str]] = None,\n    method: Optional[Literal[\"nearest\", \"pad\", \"ffill\", \"backfill\", \"bfill\"]] = None,\n) -&gt; DataArray\n</code></pre> <p>Get Xarray variable as DataArray.</p> <p>Parameters:</p> <ul> <li> <code>ds</code>               (<code>Dataset</code>)           \u2013            <p>Xarray Dataset.</p> </li> <li> <code>variable</code>               (<code>str</code>)           \u2013            <p>Variable to extract from the Dataset.</p> </li> <li> <code>sel</code>               (<code>list of str</code>, default:                   <code>None</code> )           \u2013            <p>List of Xarray Indexes.</p> </li> <li> <code>method</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Xarray indexing method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataArray</code>           \u2013            <p>xarray.DataArray: 2D or 3D DataArray.</p> </li> </ul>"},{"location":"api/titiler/xarray/io/#titiler.xarray.io.xarray_open_dataset","title":"xarray_open_dataset","text":"<pre><code>xarray_open_dataset(\n    src_path: str, group: Optional[str] = None, decode_times: bool = True\n) -&gt; Dataset\n</code></pre> <p>Open Xarray dataset with fsspec.</p> <p>Parameters:</p> <ul> <li> <code>src_path</code>               (<code>str</code>)           \u2013            <p>dataset path.</p> </li> <li> <code>group</code>               (<code>(Optional, str)</code>, default:                   <code>None</code> )           \u2013            <p>path to the netCDF/Zarr group in the given file to open given as a str.</p> </li> <li> <code>decode_times</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, decode times encoded in the standard NetCDF datetime format into datetime objects. Otherwise, leave them encoded as numbers.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dataset</code>           \u2013            <p>xarray.Dataset</p> </li> </ul>"},{"location":"deployment/azure/","title":"Azure","text":""},{"location":"deployment/azure/#function","title":"Function","text":"<p>TiTiler is built on top of FastAPI, a modern, fast, Python web framework for building APIs. We can make our FastAPI application work as an Azure Function by wrapping it within the Azure Function Python worker.</p> <p>If you are not familiar with Azure functions, we recommend checking docs.microsoft.com/en-us/azure/azure-functions/ first.</p> <p>Minimal TiTiler Azure function code: <pre><code>import azure.functions as func\nfrom titiler.application.main import cog, mosaic, stac, tms\nfrom fastapi import FastAPI\n\n\napp = FastAPI()\napp.include_router(cog.router, prefix=\"/cog\", tags=[\"Cloud Optimized GeoTIFF\"])\napp.include_router(\n    stac.router, prefix=\"/stac\", tags=[\"SpatioTemporal Asset Catalog\"]\n)\napp.include_router(mosaic.router, prefix=\"/mosaicjson\", tags=[\"MosaicJSON\"])\napp.include_router(tms.router, tags=[\"TileMatrixSets\"])\n\n\nasync def main(\n    req: func.HttpRequest, context: func.Context,\n) -&gt; func.HttpResponse:\n    return await func.AsgiMiddleware(app).handle_async(req, context)\n</code></pre></p>"},{"location":"deployment/azure/#requirements","title":"Requirements","text":"<ul> <li>Azure CLI: docs.microsoft.com/en-us/cli/azure/install-azure-cli</li> <li>Azure Function Tool: docs.microsoft.com/en-us/azure/azure-functions/functions-run-local</li> </ul>"},{"location":"deployment/azure/#deployment","title":"Deployment","text":"<p>See: docs.microsoft.com/en-us/azure/azure-functions/create-first-function-cli-python?tabs=azure-cli%2Cbash%2Cbrowser#create-supporting-azure-resources-for-your-function</p> <pre><code>$ git clone https://github.com/developmentseed/titiler.git\n$ cd titiler/deployment/azure\n\n$ az login\n$ az group create --name AzureFunctionsTiTiler-rg --location eastus\n$ az storage account create --name {your-new-storage-name} --sku Standard_LRS -g AzureFunctionsTiTiler-rg\n$ az functionapp create --consumption-plan-location eastus --runtime python --runtime-version 3.9 --functions-version 4 --name {your-new-function-name} --os-type linux -g AzureFunctionsTiTiler-rg -s {your-new-storage-name}\n$ func azure functionapp publish titiler --python\n</code></pre> <p>or</p> <p>use VScode: docs.microsoft.com/en-us/azure/azure-functions/create-first-function-vs-code-python#publish-the-project-to-azure</p>"},{"location":"deployment/azure/#docs","title":"Docs","text":"<ul> <li>docs.microsoft.com/en-us/azure/azure-functions/functions-deployment-technologies</li> <li>docs.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings</li> <li>docs.microsoft.com/en-us/azure/azure-functions/functions-reference-python</li> </ul>"},{"location":"deployment/k8s/","title":"k8s / Helm Deployment","text":""},{"location":"deployment/k8s/#k8s-helm-deployment","title":"k8s / Helm Deployment","text":"<p>Try locally:</p> <pre><code>minikube start\nkubectl config use-context minikube\nhelm init --wait\n\n# in the k8s directory\nhelm install -f titiler/Chart.yaml titiler\n</code></pre> <p>For more info about K8S cluster and node configuration, please see: developmentseed/titiler#212</p>"},{"location":"deployment/aws/intro/","title":"Amazon Web Services deployments","text":"<p>Examples of AWS deployments can be found in github.com/developmentseed/titiler/tree/main/deployment/aws. Those examples use AWS Cloud Development Kit to define stacks using python code.</p>"},{"location":"deployment/aws/intro/#configurationsettings","title":"Configuration/Settings","text":"<p>Deployment settings are managed via pydantic.BaseSettings and stored in config.py. Pydantic BaseSettings can receive input to overwrite the default value from a <code>.env</code> file or from environment variables.</p> <p>Variables in <code>.env</code> or in environment variable need to be prefixed with <code>TITILER_STACK_</code>:</p> <pre><code>TITILER_STACK_NAME=\"my-tiler\"\nTITILER_STACK_STAGE=\"dev\"\n\nTITILER_STACK_BUCKETS='[\"my-bucket*\", \"*\"]'\n\nTITILER_STACK_MEMORY=3008\n\n# Uncomment to allow lambda to access content on requester-payer buckets\n# TITILER_STACK_ENV='{\"AWS_REQUEST_PAYER\":\"requester\"}'\n\n# Uncomment if you only on the /cog endpoint\n# TITILER_STACK_ENV='{\"TITILER_API_DISABLE_STAC\": \"TRUE\", \"TITILER_API_DISABLE_MOSAIC\": \"TRUE\"}'\n</code></pre> <p>Default values from config.py: <pre><code>name: str = \"titiler\"\nstage: str = \"production\"\n\nowner: Optional[str]\nclient: Optional[str]\n\n# Default options are optimized for CloudOptimized GeoTIFF\n# For more information on GDAL env see: https://gdal.org/user/configoptions.html\nenv: Dict = {\n    \"CPL_VSIL_CURL_ALLOWED_EXTENSIONS\": \".tif,.TIF,.tiff\",\n    \"GDAL_CACHEMAX\": \"200\" # 200 mb\n    \"GDAL_DISABLE_READDIR_ON_OPEN\": \"EMPTY_DIR\",\n    \"GDAL_HTTP_MERGE_CONSECUTIVE_RANGES\": \"YES\",\n    \"GDAL_HTTP_MULTIPLEX\": \"YES\",\n    \"GDAL_HTTP_VERSION\": \"2\",\n    \"PYTHONWARNINGS\": \"ignore\",\n    \"VSI_CACHE\": \"TRUE\",\n    \"VSI_CACHE_SIZE\": \"5000000\" # 5 MB (per file-handle)\n}\n\n# add S3 bucket where TiTiler could do HEAD and GET Requests\nbuckets: List = []\n\n###########################################################################\n# AWS LAMBDA\n# The following settings only apply to AWS Lambda deployment\ntimeout: int = 10\nmemory: int = 1536\n# more about lambda config: https://www.sentiatechblog.com/aws-re-invent-2020-day-3-optimizing-lambda-cost-with-multi-threading\n\n# The maximum of concurrent executions you want to reserve for the function.\n# Default: - No specific limit - account limit.\nmax_concurrent: Optional[int]\n</code></pre></p>"},{"location":"deployment/aws/lambda/","title":"AWS Lambda","text":"<p>TiTiler is built on top of FastAPI, a modern, fast, Python web framework for building APIs. It doesn't work natively with AWS Lambda and API Gateway because FastAPI understands HTTP requests, not API Gateway's <code>event</code> and <code>context</code> JSON objects. However, we can make our FastAPI application work on Lambda by wrapping it with the awesome <code>mangum</code> module, which translates API Gateway events into HTTP requests.</p> <pre><code>from mangum import Mangum\nfrom titiler.main import app\n\nhandler = Mangum(app, enable_lifespan=False)\n</code></pre>"},{"location":"deployment/aws/lambda/#deploy","title":"Deploy","text":"<p>The Lambda stack is also deployed by the AWS CDK utility. Under the hood, CDK will create the deployment package required for AWS Lambda, upload it to AWS, and handle the creation of the Lambda and API Gateway resources.</p> <ol> <li> <p>Install CDK and connect to your AWS account. This step is only necessary once per AWS account.</p> <pre><code># Download titiler repo\ngit clone https://github.com/developmentseed/titiler.git\ncd titiler/deployment/aws\n\n# Create a virtual environment\npython -m pip install --upgrade virtualenv\nvirtualenv .venv\nsource .venv/bin/activate\n\n# Install CDK dependencies\npython -m pip install -r requirements-cdk.txt\n\n# Install NodeJS dependencies\nnpm install\n\n$ npm run cdk -- bootstrap # Deploys the CDK toolkit stack into an AWS environment\n\n# or in specific region\n$ npm run cdk -- bootstrap aws://${AWS_ACCOUNT_ID}/eu-central-1\n</code></pre> </li> <li> <p>Pre-Generate CFN template</p> <pre><code>$ npm run cdk -- synth  # Synthesizes and prints the CloudFormation template for this stack\n</code></pre> </li> <li> <p>Update settings (see intro.md)</p> <pre><code>export TITILER_STACK_NAME=\"mytiler\"\nexport TITILER_STACK_STAGE=\"dev\"\nexport TITILER_STACK_MEMORY=512\n</code></pre> <p>Available settings for AWS Lambda:</p> <pre><code>timeout: int = 10\nmemory: int = 1536\n\n# The maximum of concurrent executions you want to reserve for the function.\n# Default: - No specific limit - account limit.\nmax_concurrent: Optional[int]\n</code></pre> </li> <li> <p>Deploy</p> <pre><code>$ npm run cdk -- deploy mytiler-lambda-dev # Deploys the stack(s) titiler-lambda-dev in cdk/app.py\n\n# Deploy in specific region\n$ AWS_DEFAULT_REGION=eu-central-1 AWS_REGION=eu-central-1 npm run cdk -- deploy mytiler-lambda-dev\n</code></pre> </li> </ol>"},{"location":"deployment/aws/sam/","title":"AWS Serverless Application (SAM)","text":"<p>An AWS SAM (Serverless Application Model) application is publicly available over serverlessrepo.aws.amazon.com/applications/us-east-1/552819999234/TiTiler</p> <p>This enable almost a <code>one click</code> deployment solution</p> <p></p> <p>The SAM template is built on top of developmentseed/titiler-lambda-layer.</p> <p></p>"},{"location":"endpoints/algorithms/","title":"/algorithms","text":"<p>In addition to the <code>/cog</code>, <code>/stac</code> and <code>/mosaicjson</code> endpoints, the <code>titiler.application</code> package FastAPI application commes with additional metadata endpoints.</p>"},{"location":"endpoints/algorithms/#algorithms","title":"Algorithms","text":""},{"location":"endpoints/algorithms/#api","title":"API","text":"Method URL Output Description <code>GET</code> <code>/algorithms</code> JSON retrieve the list of available Algorithms <code>GET</code> <code>/algorithms/{algorithmId}</code> JSON retrieve the metadata of the specified algorithm."},{"location":"endpoints/algorithms/#description","title":"Description","text":""},{"location":"endpoints/algorithms/#list-algorithm","title":"List Algorithm","text":"<p><code>:endpoint:/algorithm</code> - Get the list of supported TileMatrixSet</p> <pre><code>$ curl https://myendpoint/algorithms | jq\n\n{\n  \"hillshade\": {\n    \"title\": \"Hillshade\",\n    \"description\": \"Create hillshade from DEM dataset.\",\n    \"inputs\": {\n      \"nbands\": 1\n    },\n    \"outputs\": {\n      \"nbands\": 1,\n      \"dtype\": \"uint8\",\n      \"min\": null,\n      \"max\": null\n    },\n    \"parameters\": {\n      \"azimuth\": {\n        \"default\": 90,\n        \"maximum\": 360,\n        \"minimum\": 0,\n        \"title\": \"Azimuth\",\n        \"type\": \"integer\"\n      },\n      \"angle_altitude\": {\n        \"default\": 90.0,\n        \"maximum\": 90.0,\n        \"minimum\": -90.0,\n        \"title\": \"Angle Altitude\",\n        \"type\": \"number\"\n      },\n      \"buffer\": {\n        \"default\": 3,\n        \"maximum\": 99,\n        \"minimum\": 0,\n        \"title\": \"Buffer\",\n        \"type\": \"integer\"\n      }\n    }\n  },\n  ...\n}\n</code></pre>"},{"location":"endpoints/algorithms/#get-algorithm-info","title":"Get Algorithm info","text":"<p><code>:endpoint:/algorithms/{algorithmId}</code> - Get the algorithm metadata</p> <ul> <li>PathParams:<ul> <li>algorithmId: algorithm name</li> </ul> </li> </ul> <pre><code>$ curl http://127.0.0.1:8000/algorithms/contours | jq\n\n{\n  \"title\": \"Contours\",\n  \"description\": \"Create contours from DEM dataset.\",\n  \"inputs\": {\n    \"nbands\": 1\n  },\n  \"outputs\": {\n    \"nbands\": 3,\n    \"dtype\": \"uint8\",\n    \"min\": null,\n    \"max\": null\n  },\n  \"parameters\": {\n    \"increment\": {\n      \"default\": 35,\n      \"maximum\": 999,\n      \"minimum\": 0,\n      \"title\": \"Increment\",\n      \"type\": \"integer\"\n    },\n    \"thickness\": {\n      \"default\": 1,\n      \"maximum\": 10,\n      \"minimum\": 0,\n      \"title\": \"Thickness\",\n      \"type\": \"integer\"\n    },\n    \"minz\": {\n      \"default\": -12000,\n      \"maximum\": 99999,\n      \"minimum\": -99999,\n      \"title\": \"Minz\",\n      \"type\": \"integer\"\n    },\n    \"maxz\": {\n      \"default\": 8000,\n      \"maximum\": 99999,\n      \"minimum\": -99999,\n      \"title\": \"Maxz\",\n      \"type\": \"integer\"\n    }\n  }\n}\n</code></pre>"},{"location":"endpoints/cog/","title":"/cog","text":"<p>The <code>titiler.application</code> package comes with a full FastAPI application with COG, STAC and MosaicJSON supports.</p>"},{"location":"endpoints/cog/#cloud-optimized-geotiff","title":"Cloud Optimized GeoTIFF","text":"<p>The <code>/cog</code> routes are based on <code>titiler.core.factory.TilerFactory</code> but with <code>cogValidateExtension</code> and <code>cogViewerExtension</code> extensions.</p>"},{"location":"endpoints/cog/#api","title":"API","text":"Method URL Output Description <code>GET</code> <code>/cog/bounds</code> JSON return dataset's bounds <code>GET</code> <code>/cog/info</code> JSON return dataset's basic info <code>GET</code> <code>/cog/info.geojson</code> GeoJSON return dataset's basic info as a GeoJSON feature <code>GET</code> <code>/cog/statistics</code> JSON return dataset's statistics <code>POST</code> <code>/cog/statistics</code> GeoJSON return dataset's statistics for a GeoJSON <code>GET</code> <code>/cog/tiles</code> JSON List of OGC Tilesets available <code>GET</code> <code>/cog/tiles/{tileMatrixSetId}</code> JSON OGC Tileset metadata <code>GET</code> <code>/cog/tiles/{tileMatrixSetId}/{z}/{x}/{y}[@{scale}x][.{format}]</code> image/bin create a web map tile image from a dataset <code>GET</code> <code>/cog/{tileMatrixSetId}/map.html</code> HTML simple map viewer <code>GET</code> <code>/cog/{tileMatrixSetId}/tilejson.json</code> JSON return a Mapbox TileJSON document <code>GET</code> <code>/cog/{tileMatrixSetId}/WMTSCapabilities.xml</code> XML return OGC WMTS Get Capabilities <code>GET</code> <code>/cog/point/{lon},{lat}</code> JSON return pixel values from a dataset <code>GET</code> <code>/cog/bbox/{minx},{miny},{maxx},{maxy}[/{width}x{height}].{format}</code> image/bin create an image from part of a dataset <code>POST</code> <code>/cog/feature[/{width}x{height}][.{format}]</code> image/bin create an image from a GeoJSON feature <code>GET</code> <code>/cog/preview[/{width}x{height}][.{format}]</code> image/bin create a preview image from a dataset <code>GET</code> <code>/cog/map</code> image/bin create map image from a dataset <code>GET</code> <code>/cog/validate</code> JSON validate a COG and return dataset info (from <code>titiler.extensions.cogValidateExtension</code>) <code>GET</code> <code>/cog/viewer</code> HTML demo webpage (from <code>titiler.extensions.cogViewerExtension</code>) <code>GET</code> <code>/cog/stac</code> GeoJSON create STAC Items from a dataset (from <code>titiler.extensions.stacExtension</code>)"},{"location":"endpoints/cog/#description","title":"Description","text":""},{"location":"endpoints/cog/#tiles","title":"Tiles","text":"<p><code>:endpoint:/cog/tiles/{tileMatrixSetId}/{z}/{x}/{y}[@{scale}x][.{format}]</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>tileMatrixSetId (str): TileMatrixSet name (e.g <code>WebMercatorQuad</code>)</li> <li>z (int): TMS tile's zoom level.</li> <li>x (int): TMS tile's column.</li> <li>y (int): TMS tile's row.</li> <li>scale (int): Tile size scale, default is set to 1 (256x256). Optional</li> <li>format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Optional</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): Cloud Optimized GeoTIFF URL. Required</li> <li>bidx (array[int]): Dataset band indexes (e.g <code>bidx=1</code>, <code>bidx=1&amp;bidx=2&amp;bidx=3</code>).</li> <li>expression (str): rio-tiler's band math expression (e.g <code>expression=b1/b2</code>).</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>buffer (float): Buffer on each side of the given tile. It must be a multiple of <code>0.5</code>. Output tilesize will be expanded to <code>tilesize + 2 * buffer</code> (e.g 0.5 = 257x257, 1.0 = 258x258).</li> <li>padding (int): Padding to apply to each tile edge. Helps reduce resampling artefacts along edges. Defaults to <code>0</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/tiles/WebMercatorQuad/1/2/3?url=https://somewhere.com/mycog.tif</code></li> <li><code>https://myendpoint/cog/tiles/WebMercatorQuad/1/2/3.jpg?url=https://somewhere.com/mycog.tif&amp;bidx=3&amp;bidx=1&amp;bidx2</code></li> <li><code>https://myendpoint/cog/tiles/WorldCRS84Quad/1/2/3@2x.png?url=https://somewhere.com/mycog.tif</code></li> <li><code>https://myendpoint/cog/tiles/WorldCRS84Quad/1/2/3?url=https://somewhere.com/mycog.tif&amp;bidx=1&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul>"},{"location":"endpoints/cog/#preview","title":"Preview","text":"<p><code>:endpoint:/cog/preview</code></p> <p><code>:endpoint:/cog/preview.{format}</code></p> <p><code>:endpoint:/cog/preview/{width}x{height}.{format}</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>format (str, optional): Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Also a QueryParam</li> <li>height (int, optional): Force output image height. Also a QueryParam</li> <li>width (int, optional): Force output image width. Also a QueryParam</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): Cloud Optimized GeoTIFF URL. Required</li> <li>bidx (array[int]): Dataset band indexes (e.g <code>bidx=1</code>, <code>bidx=1&amp;bidx=2&amp;bidx=3</code>).</li> <li>expression (str): rio-tiler's band math expression (e.g <code>expression=b1/b2</code>).</li> <li> <p>max_size (int): Max image size, default is 1024.</p> </li> <li> <p>nodata (str, int, float): Overwrite internal Nodata value.</p> </li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Important</p> <p>if height or width is provided max_size will be ignored.</p> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/preview?url=https://somewhere.com/mycog.tif</code></li> <li><code>https://myendpoint/cog/preview.jpg?url=https://somewhere.com/mycog.tif&amp;bidx=3&amp;bidx=1&amp;bidx2</code></li> <li><code>https://myendpoint/cog/preview/100x100.jpg?url=https://somewhere.com/mycog.tif&amp;bidx=3&amp;bidx=1&amp;bidx2</code></li> <li><code>https://myendpoint/cog/preview?url=https://somewhere.com/mycog.tif&amp;bidx=1&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul>"},{"location":"endpoints/cog/#bbox","title":"Bbox","text":"<p><code>:endpoint:/cog/bbox/{minx},{miny},{maxx},{maxy}.{format}</code></p> <p><code>:endpoint:/cog/bbox/{minx},{miny},{maxx},{maxy}/{width}x{height}.{format}</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>minx,miny,maxx,maxy (str): Comma (',') delimited bounding box in WGS84.</li> <li>format (str): Output image format</li> <li>height (int, optional): Force output image height. Also a QueryParam</li> <li>width (int, optional): Force output image width. Also a QueryParam</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): Cloud Optimized GeoTIFF URL. Required</li> <li>bidx (array[int]): Dataset band indexes (e.g <code>bidx=1</code>, <code>bidx=1&amp;bidx=2&amp;bidx=3</code>).</li> <li>expression (str): rio-tiler's band math expression (e.g <code>expression=b1/b2</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input coordinates. Default to <code>epsg:4326</code>.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to <code>coord_crs</code>.</li> <li>max_size (int): Max image size.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Important</p> <p>if height or width is provided max_size will be ignored.</p> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/bbox/0,0,10,10.png?url=https://somewhere.com/mycog.tif&amp;bidx=1&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> <li><code>https://myendpoint/cog/bbox/0,0,10,10/100x100.png?url=https://somewhere.com/mycog.tif</code></li> </ul>"},{"location":"endpoints/cog/#ogc-maps-api-getmap","title":"OGC Maps API - GetMap","text":"<p><code>:endpoint:/cog/map</code></p> <ul> <li>QueryParams:<ul> <li>url (str): Cloud Optimized GeoTIFF URL. Required</li> <li>bidx (array[int]): Dataset band indexes (e.g <code>bidx=1</code>, <code>bidx=1&amp;bidx=2&amp;bidx=3</code>).</li> <li>expression (str): rio-tiler's band math expression (e.g <code>expression=b1/b2</code>).</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>bbox (str): Comma (',') delimited bounding box.</li> <li>bbox-crs (str, optional): Coordinate Reference System of the input coordinates. Default to <code>epsg:4326</code>.</li> <li>crs (str, optional): Output Coordinate Reference System. Default to dataset'crs.</li> <li>height (int, optional): Force output image height. Also a QueryParam</li> <li>width (int, optional): Force output image width. Also a QueryParam</li> <li>f (str): Output image format</li> </ul> </li> </ul>"},{"location":"endpoints/cog/#feature","title":"Feature","text":"<p><code>:endpoint:/cog/feature - [POST]</code></p> <p><code>:endpoint:/cog/feature.{format} - [POST]</code></p> <p><code>:endpoint:/cog/feature/{width}x{height}.{format} - [POST]</code></p> <ul> <li> <p>Body:</p> <ul> <li>feature (JSON): A valid GeoJSON feature (Polygon or MultiPolygon)</li> </ul> </li> <li> <p>PathParams:</p> <ul> <li>height (int, optional): Force output image height. Also a QueryParam</li> <li>width (int, optional): Force output image width. Also a QueryParam</li> <li>format (str, optional): Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Also a QueryParam</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): Cloud Optimized GeoTIFF URL. Required</li> <li>bidx (array[int]): Dataset band indexes (e.g <code>bidx=1</code>, <code>bidx=1&amp;bidx=2&amp;bidx=3</code>).</li> <li>expression (str): rio-tiler's band math expression (e.g <code>expression=b1/b2</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input geometry coordinates. Default to <code>epsg:4326</code>.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to <code>coord_crs</code>.</li> <li>max_size (int): Max image size.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Important</p> <p>if height or width is provided max_size will be ignored.</p> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/feature?url=https://somewhere.com/mycog.tif</code></li> <li><code>https://myendpoint/cog/feature.png?url=https://somewhere.com/mycog.tif</code></li> <li><code>https://myendpoint/cog/feature/100x100.png?url=https://somewhere.com/mycog.tif&amp;bidx=1&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul>"},{"location":"endpoints/cog/#point","title":"Point","text":"<p><code>:endpoint:/cog/point/{lon},{lat}</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>lon,lat, (str): Comma (',') delimited point Longitude and Latitude WGS84.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): Cloud Optimized GeoTIFF URL. Required</li> <li>bidx (array[int]): Dataset band indexes (e.g <code>bidx=1</code>, <code>bidx=1&amp;bidx=2&amp;bidx=3</code>).</li> <li>expression (str): rio-tiler's band math expression (e.g <code>expression=b1/b2</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input coordinates. Default to <code>epsg:4326</code>.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/point/0,0?url=https://somewhere.com/mycog.tif</code></li> <li><code>https://myendpoint/cog/point/0,0?url=https://somewhere.com/mycog.tif&amp;bidx=1</code></li> </ul>"},{"location":"endpoints/cog/#tilesjson","title":"TilesJSON","text":"<p><code>:endpoint:/cog/{tileMatrixSetId}/tilejson.json</code> tileJSON document</p> <ul> <li> <p>PathParams:</p> <ul> <li>tileMatrixSetId (str): TileMatrixSet name (e.g <code>WebMercatorQuad</code>)</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): Cloud Optimized GeoTIFF URL. Required</li> <li>tile_format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value.</li> <li>tile_scale (int): Tile size scale, default is set to 1 (256x256).</li> <li>minzoom (int): Overwrite default minzoom.</li> <li>maxzoom (int): Overwrite default maxzoom.</li> <li>bidx (array[int]): Dataset band indexes (e.g <code>bidx=1</code>, <code>bidx=1&amp;bidx=2&amp;bidx=3</code>).</li> <li>expression (str): rio-tiler's band math expression (e.g <code>expression=b1/b2</code>).</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>buffer (float): Buffer on each side of the given tile. It must be a multiple of <code>0.5</code>. Output tilesize will be expanded to <code>tilesize + 2 * buffer</code> (e.g 0.5 = 257x257, 1.0 = 258x258).</li> <li>padding (int): Padding to apply to each tile edge. Helps reduce resampling artefacts along edges. Defaults to <code>0</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/WebMercatorQuad/tilejson.json?url=https://somewhere.com/mycog.tif</code></li> <li><code>https://myendpoint/cog/WebMercatorQuad/tilejson.json?url=https://somewhere.com/mycog.tif&amp;tile_format=png</code></li> <li><code>https://myendpoint/cog/WorldCRS84Quad/tilejson.json?url=https://somewhere.com/mycog.tif&amp;tile_scale=2&amp;bidx=1,2,3</code></li> </ul>"},{"location":"endpoints/cog/#map","title":"Map","text":"<p><code>:endpoint:/cog/{tileMatrixSetId}/map.html</code> Simple viewer</p> <ul> <li> <p>PathParams:</p> <ul> <li>tileMatrixSetId (str): TileMatrixSet name (e.g <code>WebMercatorQuad</code>)</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): Cloud Optimized GeoTIFF URL. Required</li> <li>tile_format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value.</li> <li>tile_scale (int): Tile size scale, default is set to 1 (256x256).</li> <li>minzoom (int): Overwrite default minzoom.</li> <li>maxzoom (int): Overwrite default maxzoom.</li> <li>bidx (array[int]): Dataset band indexes (e.g <code>bidx=1</code>, <code>bidx=1&amp;bidx=2&amp;bidx=3</code>).</li> <li>expression (str): rio-tiler's band math expression (e.g <code>expression=b1/b2</code>).</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>buffer (float): Buffer on each side of the given tile. It must be a multiple of <code>0.5</code>. Output tilesize will be expanded to <code>tilesize + 2 * buffer</code> (e.g 0.5 = 257x257, 1.0 = 258x258).</li> <li>padding (int): Padding to apply to each tile edge. Helps reduce resampling artefacts along edges. Defaults to <code>0</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/WebMercatorQuad/map.html?url=https://somewhere.com/mycog.tif</code></li> <li><code>https://myendpoint/cog/WebMercatorQuad/map.html?url=https://somewhere.com/mycog.tif&amp;tile_format=png</code></li> <li><code>https://myendpoint/cog/WorldCRS84Quad/map.html?url=https://somewhere.com/mycog.tif&amp;tile_scale=2&amp;bidx=1,2,3</code></li> </ul>"},{"location":"endpoints/cog/#bounds","title":"Bounds","text":"<p><code>:endpoint:/cog/bounds</code> general image bounds</p> <ul> <li>QueryParams:<ul> <li>url (str): Cloud Optimized GeoTIFF URL. Required</li> <li>crs (str): Geographic Coordinate Reference System. Default to <code>epsg:4326</code>.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/bounds?url=https://somewhere.com/mycog.tif</code></li> </ul>"},{"location":"endpoints/cog/#info","title":"Info","text":"<p><code>:endpoint:/cog/info</code> general raster info</p> <ul> <li>QueryParams:<ul> <li>url (str): Cloud Optimized GeoTIFF URL. Required</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/info?url=https://somewhere.com/mycog.tif</code></li> </ul> <p><code>:endpoint:/cog/info.geojson</code> general raster info as a GeoJSON feature</p> <ul> <li>QueryParams:<ul> <li>url (str): Cloud Optimized GeoTIFF URL. Required</li> <li>crs (str): Geographic Coordinate Reference System. Default to <code>epsg:4326</code>.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/info.geojson?url=https://somewhere.com/mycog.tif</code></li> </ul>"},{"location":"endpoints/cog/#statistics","title":"Statistics","text":"<p>Advanced raster statistics</p> <p><code>:endpoint:/cog/statistics - [GET]</code></p> <ul> <li>QueryParams:<ul> <li>url (str): Cloud Optimized GeoTIFF URL. Required</li> <li>bidx (array[int]): Dataset band indexes (e.g <code>bidx=1</code>, <code>bidx=1&amp;bidx=2&amp;bidx=3</code>).</li> <li>expression (str): rio-tiler's band math expression (e.g <code>expression=b1/b2</code>).</li> <li>max_size (int): Max image size from which to calculate statistics, default is 1024.</li> <li>height (int): Force image height from which to calculate statistics.</li> <li>width (int): Force image width from which to calculate statistics.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>categorical (bool): Return statistics for categorical dataset, default is false.</li> <li>c (array[float]): Pixels values for categories.</li> <li>p (array[int]): Percentile values.</li> <li>histogram_bins (str): Histogram bins.</li> <li>histogram_range (str): Comma (',') delimited Min,Max histogram bounds.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/statistics?url=https://somewhere.com/mycog.tif&amp;bidx=1,2,3&amp;categorical=true&amp;c=1&amp;c=2&amp;c=3&amp;p=2&amp;p98</code></li> </ul> <p><code>:endpoint:/cog/statistics - [POST]</code></p> <ul> <li> <p>Body:</p> <ul> <li>feature (JSON): A valid GeoJSON feature or FeatureCollection</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): Cloud Optimized GeoTIFF URL. Required</li> <li>bidx (array[int]): Dataset band indexes (e.g <code>bidx=1</code>, <code>bidx=1&amp;bidx=2&amp;bidx=3</code>).</li> <li>expression (str): rio-tiler's band math expression (e.g <code>expression=b1/b2</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input geometry coordinates. Default to <code>epsg:4326</code>.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to <code>coord_crs</code>.</li> <li>max_size (int): Max image size from which to calculate statistics.</li> <li>height (int): Force image height from which to calculate statistics.</li> <li>width (int): Force image width from which to calculate statistics.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>categorical (bool): Return statistics for categorical dataset, default is false.</li> <li>c (array[float]): Pixels values for categories.</li> <li>p (array[int]): Percentile values.</li> <li>histogram_bins (str): Histogram bins.</li> <li>histogram_range (str): Comma (',') delimited Min,Max histogram bounds.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/statistics?url=https://somewhere.com/mycog.tif&amp;bidx=1,2,3&amp;categorical=true&amp;c=1&amp;c=2&amp;c=3&amp;p=2&amp;p98</code></li> </ul>"},{"location":"endpoints/cog/#viewer","title":"Viewer","text":"<p><code>:endpoint:/cog/viewer</code> - COG Viewer</p> <ul> <li>QueryParams:<ul> <li>url: Cloud Optimized GeoTIFF URL. Required</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/viewer?url=https://somewhere.com/mycog.tif</code></li> </ul>"},{"location":"endpoints/cog/#validate","title":"Validate","text":"<p><code>:endpoint:/cog/validate</code> - COG Viewer</p> <ul> <li>QueryParams:<ul> <li>url: Cloud Optimized GeoTIFF URL. Required</li> <li>strict: Treat warnings as errors (bool, default is False).</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/validate?url=https://somewhere.com/mycog.tif</code></li> </ul>"},{"location":"endpoints/cog/#stac","title":"Stac","text":"<p><code>:endpoint:/cog/stac</code> - Create STAC Item</p> <ul> <li>QueryParams:<ul> <li>url: Cloud Optimized GeoTIFF URL. Required</li> <li>datetime (str): The date and time of the assets, in UTC (e.g 2020-01-01, 2020-01-01T01:01:01).</li> <li>extension (array[uri]): STAC extension URL the Item implements.</li> <li>collection (str): The Collection ID that this item belongs to.</li> <li>collection_url (uri): Link to the STAC Collection.</li> <li>id (str): Id to assign to the item (default to the source basename).</li> <li>asset_name (str): asset name for the source (default to 'data').</li> <li>asset_roles (array[str]): List of asset's roles.</li> <li>asset_media_type (str): Asset's media type.</li> <li>asset_href (uri): Asset's URI (default to source's path).</li> <li>with_proj (bool): Add the <code>projection</code> extension and properties.</li> <li>with_raster (bool): Add the <code>raster</code> extension and properties.</li> <li>with_eo (bool): Add the <code>eo</code> extension and properties.</li> <li>max_size (int): Limit array size from which to get the raster statistics.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/stac?url=https://somewhere.com/mycog.tif</code></li> </ul>"},{"location":"endpoints/colormaps/","title":"/colormaps","text":"<p>In addition to the <code>/cog</code>, <code>/stac</code> and <code>/mosaicjson</code> endpoints, the <code>titiler.application</code> package FastAPI application commes with additional metadata endpoints.</p>"},{"location":"endpoints/colormaps/#algorithms","title":"Algorithms","text":""},{"location":"endpoints/colormaps/#api","title":"API","text":"Method URL Output Description <code>GET</code> <code>/colorMaps</code> JSON retrieve the list of available colorMaps <code>GET</code> <code>/colorMaps/{colorMapId}</code> JSON retrieve the metadata or image of the specified colorMap."},{"location":"endpoints/colormaps/#description","title":"Description","text":""},{"location":"endpoints/colormaps/#list-colormaps","title":"List colormaps","text":"<p><code>:endpoint:/colorMaps</code> - Get the list of supported ColorMaps</p> <pre><code>$ curl https://myendpoint/colorMaps | jq\n\n{\n  \"colorMaps\": [\n    \"dense_r\",\n    \"delta\",\n    ...\n  ],\n  \"links\": [\n    {\n      \"href\": \"http://myendpoint/colorMaps\",\n      \"rel\": \"self\",\n      \"type\": \"application/json\",\n      \"title\": \"List of available colormaps\"\n    },\n    {\n      \"href\": \"http://myendpoint/colorMaps/{colorMapId}\",\n      \"rel\": \"data\",\n      \"type\": \"application/json\",\n      \"templated\": true,\n      \"title\": \"Retrieve colormap metadata\"\n    },\n    {\n      \"href\": \"http://myendpoint/colorMaps/{colorMapId}?format=png\",\n      \"rel\": \"data\",\n      \"type\": \"image/png\",\n      \"templated\": true,\n      \"title\": \"Retrieve colormap as image\"\n    }\n  ]\n}\n</code></pre>"},{"location":"endpoints/colormaps/#get-colormap-metadata-or-as-image","title":"Get ColorMap metadata or as image","text":"<p><code>:endpoint:/colorMaps/{colorMapId}</code> - Get the ColorMap metadata or image</p> <ul> <li> <p>PathParams:</p> <ul> <li>colorMapId: colormap name</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>format (str): output image format (PNG/JPEG...). Defaults to JSON output.</li> <li>orientation ([\"vertical\", \"horizontal\"]): image orientation. Defaults to <code>horizontal</code>.</li> <li>height (int): output image height. Default to 20px for horizontal or 256px for vertical.</li> <li>width (int): output image width. Defaults to 256px for horizontal or 20px for vertical.</li> </ul> </li> </ul> <pre><code>$ curl http://myendpoint/colorMaps/viridis | jq\n\n{\n  \"0\": [\n    68,\n    1,\n    84,\n    255\n  ],\n  ...\n  \"255\": [\n    253,\n    231,\n    36,\n    255\n  ]\n}\n</code></pre> <pre><code>curl http://myendpoint/colorMaps/viridis?format=png\n</code></pre> <pre><code>curl http://myendpoint/colorMaps/viridis?format=png&amp;orientation=vertical\n</code></pre> <pre><code>curl http://myendpoint/colorMaps/viridis?format=png&amp;orientation=vertical&amp;width=100&amp;height=1000\n</code></pre>"},{"location":"endpoints/mosaic/","title":"/mosaicjson","text":"<p>The <code>titiler.application</code> package comes with a full FastAPI application with COG, STAC and MosaicJSON supports.</p>"},{"location":"endpoints/mosaic/#mosaicjson","title":"MosaicJSON","text":"<p>Read Mosaic Info/Metadata and create Web map Tiles from a multiple COG. The <code>mosaic</code> router is built on top of <code>titiler.mosaic.factor.MosaicTilerFactory</code>.</p>"},{"location":"endpoints/mosaic/#api","title":"API","text":"Method URL Output Description <code>GET</code> <code>/mosaicjson/</code> JSON return a MosaicJSON document <code>GET</code> <code>/mosaicjson/bounds</code> JSON return mosaic's bounds <code>GET</code> <code>/mosaicjson/info</code> JSON return mosaic's basic info <code>GET</code> <code>/mosaicjson/info.geojson</code> GeoJSON return mosaic's basic info as a GeoJSON feature <code>GET</code> <code>/mosaicjson/tiles</code> JSON List of OGC Tilesets available <code>GET</code> <code>/mosaicjson/tiles/{tileMatrixSetId}</code> JSON OGC Tileset metadata <code>GET</code> <code>/mosaicjson/tiles/{tileMatrixSetId}/{z}/{x}/{y}[@{scale}x][.{format}]</code> image/bin create a web map tile image from mosaic assets <code>GET</code> <code>/mosaicjson/{tileMatrixSetId}/map.html</code> HTML simple map viewer <code>GET</code> <code>/mosaicjson/{tileMatrixSetId}/tilejson.json</code> JSON return a Mapbox TileJSON document <code>GET</code> <code>/mosaicjson/{tileMatrixSetId}/WMTSCapabilities.xml</code> XML return OGC WMTS Get Capabilities <code>GET</code> <code>/mosaicjson/point/{lon},{lat}</code> JSON return pixel value from a mosaic assets <code>GET</code> <code>/mosaicjson/tiles/{tileMatrixSetId}/{z}/{x}/{y}/assets</code> JSON return list of assets intersecting a XYZ tile <code>GET</code> <code>/mosaicjson/point/{lon},{lat}/assets</code> JSON return list of assets intersecting a point <code>GET</code> <code>/mosaicjson/bbox/{minx},{miny},{maxx},{maxy}/assets</code> JSON return list of assets intersecting a bounding box"},{"location":"endpoints/mosaic/#description","title":"Description","text":"<p>[TODO]</p>"},{"location":"endpoints/stac/","title":"/stac","text":"<p>The <code>titiler.application</code> package comes with a full FastAPI application with COG, STAC and MosaicJSON supports.</p>"},{"location":"endpoints/stac/#spatiotemporal-asset-catalog","title":"SpatioTemporal Asset Catalog","text":"<p>The <code>/stac</code> routes are based on <code>titiler.core.factory.MultiBaseTilerFactory</code> but with <code>stacViewerExtension</code> extension.</p>"},{"location":"endpoints/stac/#api","title":"API","text":"Method URL Output Description <code>GET</code> <code>/stac/assets</code> JSON return available assets within the STAC item <code>GET</code> <code>/stac/bounds</code> JSON return STAC item bounds <code>GET</code> <code>/stac/info</code> JSON return asset's basic info <code>GET</code> <code>/stac/info.geojson</code> GeoJSON return asset's basic info as a GeoJSON feature <code>GET</code> <code>/stac/asset_statistics</code> JSON return per asset statistics <code>GET</code> <code>/stac/statistics</code> JSON return asset's statistics <code>POST</code> <code>/stac/statistics</code> GeoJSON return asset's statistics for a GeoJSON <code>GET</code> <code>/stac/tiles</code> JSON List of OGC Tilesets available <code>GET</code> <code>/stac/tiles/{tileMatrixSetId}</code> JSON OGC Tileset metadata <code>GET</code> <code>/stac/tiles/{tileMatrixSetId}/{z}/{x}/{y}[@{scale}x][.{format}]</code> image/bin create a web map tile image from assets <code>GET</code> <code>/stac/{tileMatrixSetId}/map.html</code> HTML simple map viewer <code>GET</code> <code>/stac/{tileMatrixSetId}/tilejson.json</code> JSON return a Mapbox TileJSON document <code>GET</code> <code>/stac/{tileMatrixSetId}/WMTSCapabilities.xml</code> XML return OGC WMTS Get Capabilities <code>GET</code> <code>/stac/point/{lon},{lat}</code> JSON return pixel value from assets <code>GET</code> <code>/stac/bbox/{minx},{miny},{maxx},{maxy}[/{width}x{height}].{format}</code> image/bin create an image from part of assets <code>POST</code> <code>/stac/feature[/{width}x{height}][.{format}]</code> image/bin create an image from a geojson covering the assets <code>GET</code> <code>/stac/preview[/{width}x{height}][.{format}]</code> image/bin create a preview image from assets <code>GET</code> <code>/stac/viewer</code> HTML demo webpage (from <code>titiler.extensions.stacViewerExtension</code>)"},{"location":"endpoints/stac/#description","title":"Description","text":""},{"location":"endpoints/stac/#tiles","title":"Tiles","text":"<p><code>:endpoint:/stac/tiles/{tileMatrixSetId}/{z}/{x}/{y}[@{scale}x][.{format}]</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>tileMatrixSetId (str): TileMatrixSet name (e.g <code>WebMercatorQuad</code>)</li> <li>z (int): TMS tile's zoom level.</li> <li>x (int): TMS tile's column.</li> <li>y (int): TMS tile's row.</li> <li>scale (int): Tile size scale, default is set to 1 (256x256). Optional</li> <li>format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Optional</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): STAC Item URL. Required</li> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1,2,3</code>).</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>buffer (float): Buffer on each side of the given tile. It must be a multiple of <code>0.5</code>. Output tilesize will be expanded to <code>tilesize + 2 * buffer</code> (e.g 0.5 = 257x257, 1.0 = 258x258).</li> <li>padding (int): Padding to apply to each tile edge. Helps reduce resampling artefacts along edges. Defaults to <code>0</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Important</p> <p>assets OR expression is required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/tiles/WebMercatorQuad/1/2/3?url=https://somewhere.com/item.json&amp;assets=B01&amp;assets=B00</code></li> <li><code>https://myendpoint/stac/tiles/WebMercatorQuad/1/2/3.jpg?url=https://somewhere.com/item.json&amp;assets=B01</code></li> <li><code>https://myendpoint/stac/tiles/WorldCRS84Quad/1/2/3@2x.png?url=https://somewhere.com/item.json&amp;assets=B01</code></li> <li><code>https://myendpoint/stac/tiles/WorldCRS84Quad/1/2/3?url=https://somewhere.com/item.json&amp;expression=B01/B02&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul>"},{"location":"endpoints/stac/#preview","title":"Preview","text":"<p><code>:endpoint:/stac/preview</code></p> <p><code>:endpoint:/stac/preview/.{format}</code></p> <p><code>:endpoint:/stac/preview/{width}x{height}.{format}</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>format (str, optional): Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Also a QueryParam</li> <li>height (int, optional): Force output image height. Also a QueryParam</li> <li>width (int, optional): Force output image width. Also a QueryParam</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): STAC Item URL. Required</li> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1,2,3</code>).</li> <li>max_size (int): Max image size, default is 1024.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to dataset's CRS.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Important</p> <ul> <li> <p>assets OR expression is required</p> </li> <li> <p>if height or width is provided max_size will be ignored.</p> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/preview?url=https://somewhere.com/item.json&amp;assets=B01</code></li> <li><code>https://myendpoint/stac/preview.jpg?url=https://somewhere.com/item.json&amp;assets=B01</code></li> <li><code>https://myendpoint/stac/preview/100x100.jpg?url=https://somewhere.com/item.json&amp;assets=B01</code></li> <li><code>https://myendpoint/stac/preview?url=https://somewhere.com/item.json&amp;assets=B01&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul>"},{"location":"endpoints/stac/#bbox","title":"Bbox","text":"<p><code>:endpoint:/stac/bbox/{minx},{miny},{maxx},{maxy}.{format}</code></p> <p><code>:endpoint:/stac/bbox/{minx},{miny},{maxx},{maxy}/{width}x{height}.{format}</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>minx,miny,maxx,maxy (str): Comma (',') delimited bounding box in WGS84.</li> <li>format (str): Output image format.</li> <li>height (int, optional): Force output image height. Also a QueryParam</li> <li>width (int, optional): Force output image width. Also a QueryParam</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): STAC Item URL. Required</li> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1,2,3</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input coordinates. Default to <code>epsg:4326</code>.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to <code>coord_crs</code>.</li> <li>max_size (int): Max image size.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Important</p> <ul> <li> <p>assets OR expression is required</p> </li> <li> <p>if height or width is provided max_size will be ignored.</p> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/bbox/0,0,10,10.png?url=https://somewhere.com/item.json&amp;assets=B01</code></li> <li><code>https://myendpoint/stac/bbox/0,0,10,10/100x100.png?url=https://somewhere.com/item.json&amp;assets=B01</code></li> <li><code>https://myendpoint/stac/bbox/0,0,10,10.png?url=https://somewhere.com/item.json&amp;assets=B01&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul>"},{"location":"endpoints/stac/#ogc-maps-api-getmap","title":"OGC Maps API - GetMap","text":"<p><code>:endpoint:/stac/map</code></p> <ul> <li>QueryParams:<ul> <li>url (str): STAC Item URL. Required</li> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1,2,3</code>).</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>bbox (str): Comma (',') delimited bounding box.</li> <li>bbox-crs (str, optional): Coordinate Reference System of the input coordinates. Default to <code>epsg:4326</code>.</li> <li>crs (str, optional): Output Coordinate Reference System. Default to dataset'crs.</li> <li>height (int, optional): Force output image height. Also a QueryParam</li> <li>width (int, optional): Force output image width. Also a QueryParam</li> <li>f (str): Output image format</li> </ul> </li> </ul> <p>Important</p> <ul> <li>assets OR expression is require</li> </ul>"},{"location":"endpoints/stac/#feature","title":"Feature","text":"<p><code>:endpoint:/stac/feature - [POST]</code></p> <p><code>:endpoint:/stac/feature.{format} - [POST]</code></p> <p><code>:endpoint:/stac/feature/{width}x{height}.{format} - [POST]</code></p> <ul> <li> <p>Body:</p> <ul> <li>feature (JSON): A valid GeoJSON feature (Polygon or MultiPolygon)</li> </ul> </li> <li> <p>PathParams:</p> <ul> <li>format (str, optional): Output image format. Also a QueryParam</li> <li>height (int, optional): Force output image height. Also a QueryParam</li> <li>width (int, optional): Force output image width. Also a QueryParam</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): STAC Item URL. Required</li> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1,2,3</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input geometry coordinates. Default to <code>epsg:4326</code>.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to <code>coord_crs</code>.</li> <li>max_size (int): Max image size.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Important</p> <ul> <li> <p>assets OR expression is required</p> </li> <li> <p>if height or width is provided max_size will be ignored.</p> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/feature?url=https://somewhere.com/item.json&amp;assets=B01</code></li> <li><code>https://myendpoint/stac/feature.png?url=https://somewhere.com/item.json&amp;assets=B01</code></li> <li><code>https://myendpoint/stac/feature/100x100.png?url=https://somewhere.com/item.json&amp;assets=B01&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul>"},{"location":"endpoints/stac/#point","title":"Point","text":"<p><code>:endpoint:/cog/point/{lon},{lat}</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>lon,lat, (str): Comma (',') delimited point Longitude and Latitude WGS84.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): STAC Item URL. Required</li> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1,2,3</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input coordinates. Default to <code>epsg:4326</code>.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> </ul> </li> </ul> <p>Important</p> <p>assets OR expression is required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/point/0,0?url=https://somewhere.com/item.json&amp;assets=B01</code></li> </ul>"},{"location":"endpoints/stac/#tilesjson","title":"TilesJSON","text":"<p><code>:endpoint:/stac/{tileMatrixSetId}/tilejson.json</code> tileJSON document</p> <ul> <li> <p>PathParams:</p> <ul> <li>tileMatrixSetId (str): TileMatrixSet name (e.g <code>WebMercatorQuad</code>)</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): STAC Item URL. Required</li> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1,2,3</code>).</li> <li>tile_format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value.</li> <li>tile_scale (int): Tile size scale, default is set to 1 (256x256).</li> <li>minzoom (int): Overwrite default minzoom.</li> <li>maxzoom (int): Overwrite default maxzoom.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>buffer (float): Buffer on each side of the given tile. It must be a multiple of <code>0.5</code>. Output tilesize will be expanded to <code>tilesize + 2 * buffer</code> (e.g 0.5 = 257x257, 1.0 = 258x258).</li> <li>padding (int): Padding to apply to each tile edge. Helps reduce resampling artefacts along edges. Defaults to <code>0</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Important</p> <p>assets OR expression is required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/WebMercatorQuad/tilejson.json?url=https://somewhere.com/item.json&amp;assets=B01</code></li> <li><code>https://myendpoint/stac/WebMercatorQuad/tilejson.json?url=https://somewhere.com/item.json&amp;assets=B01&amp;tile_format=png</code></li> <li><code>https://myendpoint/stac/WorldCRS84Quad/tilejson.json?url=https://somewhere.com/item.json&amp;tile_scale=2&amp;expression=B01/B02</code></li> </ul>"},{"location":"endpoints/stac/#map","title":"Map","text":"<p><code>:endpoint:/stac/{tileMatrixSetId}/map.html</code>  Simple viewer</p> <ul> <li> <p>PathParams:</p> <ul> <li>tileMatrixSetId (str): TileMatrixSet name (e.g <code>WebMercatorQuad</code>)</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): STAC Item URL. Required</li> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1,2,3</code>).</li> <li>tile_format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value.</li> <li>tile_scale (int): Tile size scale, default is set to 1 (256x256).</li> <li>minzoom (int): Overwrite default minzoom.</li> <li>maxzoom (int): Overwrite default maxzoom.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>buffer (float): Buffer on each side of the given tile. It must be a multiple of <code>0.5</code>. Output tilesize will be expanded to <code>tilesize + 2 * buffer</code> (e.g 0.5 = 257x257, 1.0 = 258x258).</li> <li>padding (int): Padding to apply to each tile edge. Helps reduce resampling artefacts along edges. Defaults to <code>0</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Important</p> <p>assets OR expression is required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/WebMercatorQuad/tilejson.json?url=https://somewhere.com/item.json&amp;assets=B01</code></li> <li><code>https://myendpoint/stac/WebMercatorQuad/tilejson.json?url=https://somewhere.com/item.json&amp;assets=B01&amp;tile_format=png</code></li> <li><code>https://myendpoint/stac/WorldCRS84Quad/tilejson.json?url=https://somewhere.com/item.json&amp;tile_scale=2&amp;expression=B01/B02</code></li> </ul>"},{"location":"endpoints/stac/#bounds","title":"Bounds","text":"<p><code>:endpoint:/stac/bounds</code> - Return the bounds of the STAC item.</p> <ul> <li>QueryParams:<ul> <li>url (str): STAC Item URL. Required</li> <li>crs (str): Geographic Coordinate Reference System. Default to <code>epsg:4326</code>.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/bounds?url=https://somewhere.com/item.json</code></li> </ul>"},{"location":"endpoints/stac/#info","title":"Info","text":"<p><code>:endpoint:/stac/info</code> - Return basic info on STAC item's COG.</p> <ul> <li>QueryParams:<ul> <li>url (str): STAC Item URL. Required</li> <li>assets (array[str]): asset names. Default to all available assets.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/info?url=https://somewhere.com/item.json&amp;assets=B01</code></li> </ul> <p><code>:endpoint:/stac/info.geojson</code> - Return basic info on STAC item's COG as a GeoJSON feature</p> <ul> <li>QueryParams:<ul> <li>url (str): STAC Item URL. Required</li> <li>assets (array[str]): asset names. Default to all available assets.</li> <li>crs (str): Geographic Coordinate Reference System. Default to <code>epsg:4326</code>.</li> </ul> </li> </ul> <p><code>:endpoint:/stac/assets</code> - Return the list of available assets</p> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/assets?url=https://somewhere.com/item.json</code></li> </ul>"},{"location":"endpoints/stac/#statistics","title":"Statistics","text":"<p><code>:endpoint:/stac/asset_statistics - [GET]</code></p> <ul> <li>QueryParams:<ul> <li>url (str): STAC Item URL. Required</li> <li>assets (array[str]): asset names. Default to all available assets.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1,2,3</code>).</li> <li>asset_expression (array[str]): Per asset band math expression (e.g <code>Asset1|b1\\*b2</code>).</li> <li>max_size (int): Max image size from which to calculate statistics, default is 1024.</li> <li>height (int): Force image height from which to calculate statistics.</li> <li>width (int): Force image width from which to calculate statistics.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>categorical (bool): Return statistics for categorical dataset, default is false.</li> <li>c (array[float]): Pixels values for categories.</li> <li>p (array[int]): Percentile values.</li> <li>histogram_bins (str): Histogram bins.</li> <li>histogram_range (str): Comma (',') delimited Min,Max histogram bounds</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/statistics?url=https://somewhere.com/item.json&amp;assets=B01&amp;categorical=true&amp;c=1&amp;c=2&amp;c=3&amp;p=2&amp;p98</code></li> </ul> <p><code>:endpoint:/stac/statistics - [GET]</code></p> <ul> <li>QueryParams:<ul> <li>url (str): STAC Item URL. Required</li> <li>assets (array[str]): asset names. Default to all available assets.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1,2,3</code>).</li> <li>max_size (int): Max image size from which to calculate statistics, default is 1024.</li> <li>height (int): Force image height from which to calculate statistics.</li> <li>width (int): Force image width from which to calculate statistics.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>categorical (bool): Return statistics for categorical dataset, default is false.</li> <li>c (array[float]): Pixels values for categories.</li> <li>p (array[int]): Percentile values.</li> <li>histogram_bins (str): Histogram bins.</li> <li>histogram_range (str): Comma (',') delimited Min,Max histogram bounds</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/statistics?url=https://somewhere.com/item.json&amp;assets=B01&amp;categorical=true&amp;c=1&amp;c=2&amp;c=3&amp;p=2&amp;p98</code></li> </ul> <p><code>:endpoint:/stac/statistics - [POST]</code></p> <ul> <li> <p>Body:</p> <ul> <li>feature (JSON): A valid GeoJSON feature or FeatureCollection</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): STAC Item URL. Required</li> <li>assets (array[str]): asset names. Default to all available assets.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1,2,3</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input geometry coordinates. Default to <code>epsg:4326</code>.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to <code>coord_crs</code>.</li> <li>max_size (int): Max image size from which to calculate statistics.</li> <li>height (int): Force image height from which to calculate statistics.</li> <li>width (int): Force image width from which to calculate statistics.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>categorical (bool): Return statistics for categorical dataset, default is false.</li> <li>c (array[float]): Pixels values for categories.</li> <li>p (array[int]): Percentile values.</li> <li>histogram_bins (str): Histogram bins.</li> <li>histogram_range (str): Comma (',') delimited Min,Max histogram bounds</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/statistics?url=https://somewhere.com/item.json&amp;assets=B01&amp;categorical=true&amp;c=1&amp;c=2&amp;c=3&amp;p=2&amp;p98</code></li> </ul>"},{"location":"endpoints/stac/#viewer","title":"Viewer","text":"<p><code>:endpoint:/stac/viewer</code> - STAC viewer</p> <ul> <li>QueryParams:<ul> <li>url: STAC Item URL. Optional</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/viewer?url=https://somewhere.com/item.json</code></li> </ul>"},{"location":"endpoints/tms/","title":"/tileMatrixSets","text":"<p>In addition to the <code>/cog</code>, <code>/stac</code> and <code>/mosaicjson</code> endpoints, the <code>titiler.application</code> package FastAPI application comes with additional metadata endpoints.</p>"},{"location":"endpoints/tms/#tilematrixsets","title":"TileMatrixSets","text":""},{"location":"endpoints/tms/#api","title":"API","text":"Method URL Output Description <code>GET</code> <code>/tileMatrixSets</code> JSON return the list of supported TileMatrixSet <code>GET</code> <code>/tileMatrixSets/{tileMatrixSetId}</code> JSON return the TileMatrixSet JSON document"},{"location":"endpoints/tms/#description","title":"Description","text":""},{"location":"endpoints/tms/#list-tms","title":"List TMS","text":"<p><code>:endpoint:/tileMatrixSets</code> - Get the list of supported TileMatrixSet</p> <pre><code>$ curl https://myendpoint/tileMatrixSets | jq\n\n{\n  \"tileMatrixSets\": [\n    {\n      \"id\": \"LINZAntarticaMapTilegrid\",\n      \"title\": \"LINZ Antarctic Map Tile Grid (Ross Sea Region)\",\n      \"links\": [\n        {\n          \"href\": \"https://myendpoint/tileMatrixSets/LINZAntarticaMapTilegrid\",\n          \"rel\": \"item\",\n          \"type\": \"application/json\"\n        }\n      ]\n    },\n    ...\n  ]\n}\n</code></pre>"},{"location":"endpoints/tms/#get-tms-info","title":"Get TMS info","text":"<p><code>:endpoint:/tileMatrixSets/{tileMatrixSetId}</code> - Get the TileMatrixSet JSON document</p> <ul> <li>PathParams:<ul> <li>tileMatrixSetId: TileMatrixSet name</li> </ul> </li> </ul> <pre><code>$ curl http://127.0.0.1:8000/tileMatrixSets/WebMercatorQuad | jq\n\n{\n  \"type\": \"TileMatrixSetType\",\n  \"title\": \"Google Maps Compatible for the World\",\n  \"identifier\": \"WebMercatorQuad\",\n  \"supportedCRS\": \"http://www.opengis.net/def/crs/EPSG/0/3857\",\n  \"wellKnownScaleSet\": \"http://www.opengis.net/def/wkss/OGC/1.0/GoogleMapsCompatible\",\n  \"boundingBox\": {\n    \"type\": \"BoundingBoxType\",\n    \"crs\": \"http://www.opengis.net/def/crs/EPSG/0/3857\",\n    \"lowerCorner\": [\n      -20037508.3427892,\n      -20037508.3427892\n    ],\n    \"upperCorner\": [\n      20037508.3427892,\n      20037508.3427892\n    ]\n  },\n  \"tileMatrix\": [\n    {\n      \"type\": \"TileMatrixType\",\n      \"identifier\": \"0\",\n      \"scaleDenominator\": 559082264.028717,\n      \"topLeftCorner\": [\n        -20037508.3427892,\n        20037508.3427892\n      ],\n      \"tileWidth\": 256,\n      \"tileHeight\": 256,\n      \"matrixWidth\": 1,\n      \"matrixHeight\": 1\n    },\n    ...\n</code></pre>"},{"location":"examples/code/create_gdal_wmts_extension/","title":"GDAL WMTS Extension","text":"<p>Goal: add a <code>/wmts.xml</code> endpoint to return a GDAL WMTS service description XML file</p> <p>requirements: titiler.extension &gt;=0.11</p> <p>1 - Create an extension</p> <pre><code># wmts.py\n\"\"\"gdal WMTS service Extension.\"\"\"\n\nimport xml.etree.ElementTree as ET\nfrom dataclasses import dataclass\nfrom typing import Literal\nfrom urllib.parse import urlencode\n\nfrom fastapi import Depends, Query\nfrom starlette.requests import Request\n\nfrom titiler.core.factory import BaseTilerFactory, FactoryExtension\nfrom titiler.core.resources.responses import XMLResponse\n\n\n@dataclass\nclass gdalwmtsExtension(FactoryExtension):\n    \"\"\"Add /wmts.xml endpoint to a TilerFactory.\"\"\"\n\n    def register(self, factory: BaseTilerFactory):  # noqa: C901\n        \"\"\"Register endpoint to the tiler factory.\"\"\"\n\n        @factory.router.get(\n            \"/{tileMatrixSetId}/wmts.xml\",\n            response_class=XMLResponse,\n            responses={\n                200: {\n                    \"description\": \"GDAL WMTS service description XML file\",\n                    \"content\": {\n                        \"application/xml\": {},\n                    },\n                },\n            },\n        )\n        def gdal_wmts(\n            request: Request,\n            tileMatrixSetId: Literal[tuple(factory.supported_tms.list())] = Path(  # type: ignore\n                description=\"TileMatrixSet Name\",\n            ),\n            url: str = Depends(factory.path_dependency),  # noqa\n            bandscount: int = Query(\n                ..., description=\"Number of band returned by the tiler\"\n            ),\n            datatype: str = Query(..., description=\"Datatype returned by the tiler\"),\n            maxconnections: int = Query(\n                None,\n                description=\"Maximum number of simultaneous connections (defaults to 2).\",\n            ),\n            timeout: int = Query(\n                None, description=\"Connection timeout in seconds (defaults to 30).\"\n            ),\n            cache: bool = Query(None, description=\"Allow local cache.\"),\n        ):\n            \"\"\"Return a GDAL WMTS Service description.\"\"\"\n            route_params = {\n                \"tileMatrixSetId\": tileMatrixSetId,\n            }\n            wmts_url = factory.url_for(request, \"wmts\", **route_params)\n\n            qs_key_to_remove = [\n                \"tilematrixsetid\",\n                \"bandscount\",\n                \"datatype\",\n                \"maxconnections\",\n                \"timeout\",\n            ]\n            qs = [\n                (key, value)\n                for (key, value) in request.query_params._list\n                if key.lower() not in qs_key_to_remove\n            ]\n            if qs:\n                wmts_url += f\"?{urlencode(qs)}\"\n\n            maxconnections = maxconnections or 2\n            timeout = timeout or 30\n\n            xml = ET.Element(\"GDAL_WMTS\")\n            cap = ET.SubElement(xml, \"GetCapabilitiesUrl\")\n            cap.text = wmts_url\n\n            bandel = ET.SubElement(xml, \"BandsCount\")\n            bandel.text = str(bandscount)\n            datael = ET.SubElement(xml, \"DataType\")\n            datael.text = datatype\n\n            if cache:\n                cacheel = ET.SubElement(xml, \"Cache\")\n\n            connel = ET.SubElement(xml, \"MaxConnections\")\n            connel.text = str(maxconnections)\n            timeel = ET.SubElement(xml, \"Timeout\")\n            timeel.text = str(timeout)\n            codeel = ET.SubElement(xml, \"ZeroBlockHttpCodes\")\n            codeel.text = \"404\"\n            excepel = ET.SubElement(xml, \"ZeroBlockOnServerException\")\n            excepel.text = \"true\"\n\n            return XMLResponse(ET.tostring(xml))\n</code></pre> <p>2 - Create app and register our extension</p> <pre><code>\"\"\"app.\n\napp/main.py\n\n\"\"\"\n\nfrom titiler.core.errors import DEFAULT_STATUS_CODES, add_exception_handlers\nfrom titiler.core.factory import TilerFactory\n\nfrom fastapi import FastAPI\n\nfrom .wmts import gdalwmtsExtension\n\napp = FastAPI(title=\"My simple app with custom TMS\")\n\n# Create  a set of endpoints using TilerFactory and add our extension\ntiler = TilerFactory(extensions=[gdalwmtsExtension()])\n\napp.include_router(tiler.router)\nadd_exception_handlers(app, DEFAULT_STATUS_CODES)\n</code></pre> <p>3 - Use it</p> <pre><code>from rio_tiler.io import Reader\n\nwith Reader(\"http://0.0.0.0/WebMercatorQuad/wmts.xml?url=file.tif&amp;bidx=1&amp;bandscount=1&amp;datatype=float32&amp;tile_format=tif\") as src:\n    im = src.preview()\n</code></pre> <p>Notes</p> <p>The <code>/wmts.xml</code> endpoint has no idea about the data itself and do not care about the <code>bidx</code> or <code>expression</code> which is why we need to set <code>bandscount</code> and <code>datatype</code> parameters.</p> <p>In the example above we use <code>tile_format=tif</code> so GDAL will fetch <code>tif</code> tiles and keep the datatype from the data (which we assume to be float32)</p>"},{"location":"examples/code/mini_cog_tiler/","title":"Minimal COG Tiler","text":"<p>Goal: Create a simple Raster tiler</p> <p>requirements: titiler.core</p> <pre><code>\"\"\"Minimal COG tiler.\"\"\"\n\nfrom titiler.core.factory import TilerFactory\nfrom titiler.core.errors import DEFAULT_STATUS_CODES, add_exception_handlers\n\nfrom fastapi import FastAPI\n\n\napp = FastAPI(title=\"My simple app\")\n\ncog = TilerFactory()\napp.include_router(cog.router, tags=[\"Cloud Optimized GeoTIFF\"])\n\nadd_exception_handlers(app, DEFAULT_STATUS_CODES)\n\n\n@app.get(\"/healthz\", description=\"Health Check\", tags=[\"Health Check\"])\ndef ping():\n    \"\"\"Health check.\"\"\"\n    return {\"ping\": \"pong!\"}\n</code></pre>"},{"location":"examples/code/mosaic_from_urls/","title":"Mosaic from COG urls","text":"<p>Goal: Create a custom mosaic tiler which takes multiple URL as input</p> <p>requirements: titiler.core | titiler.mosaic</p> <p>1 - Create a custom Mosaic Backends</p> <pre><code>\"\"\"mosaic backends.\n\nThe goal is to build a minimalist Mosaic Backend which takes COG paths as input.\n\n&gt;&gt;&gt; with MultiFilesBackend([\"cog1.tif\", \"cog2.tif\"]) as mosaic:\n    img = mosaic.tile(1, 1, 1)\n\napp/backends.py\n\n\"\"\"\nfrom typing import Type, List, Tuple, Dict, Union\n\nimport attr\nfrom rio_tiler.io import BaseReader, COGReader, MultiBandReader, MultiBaseReader\nfrom rio_tiler.constants import WEB_MERCATOR_TMS, WGS84_CRS\nfrom rasterio.crs import CRS\nfrom morecantile import TileMatrixSet\n\nfrom cogeo_mosaic.backends.base import BaseBackend\nfrom cogeo_mosaic.mosaic import MosaicJSON\n\n\n@attr.s\nclass MultiFilesBackend(BaseBackend):\n\n    input: List[str] = attr.ib()\n\n    reader: Union[\n        Type[BaseReader],\n        Type[MultiBaseReader],\n        Type[MultiBandReader],\n    ] = attr.ib(default=COGReader)\n    reader_options: Dict = attr.ib(factory=dict)\n\n    geographic_crs: CRS = attr.ib(default=WGS84_CRS)\n\n    tms: TileMatrixSet = attr.ib(default=WEB_MERCATOR_TMS)\n    minzoom: int = attr.ib(default=0)\n    maxzoom: int = attr.ib(default=30)\n\n    # default values for bounds\n    bounds: Tuple[float, float, float, float] = attr.ib(\n        default=(-180, -90, 180, 90)\n    )\n    crs: CRS = attr.ib(init=False, default=WGS84_CRS)\n\n    # mosaic_def is outside the __init__ method\n    mosaic_def: MosaicJSON = attr.ib(init=False)\n\n    _backend_name = \"MultiFiles\"\n\n    def __attrs_post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        # Construct a FAKE/Empty mosaicJSON\n        # mosaic_def has to be defined.\n        self.mosaic_def = MosaicJSON(\n            mosaicjson=\"0.0.2\",\n            name=\"it's fake but it's ok\",\n            minzoom=self.minzoom,\n            maxzoom=self.maxzoom,\n            tiles=[]  # we set `tiles` to an empty list.\n        )\n\n    def write(self, overwrite: bool = True):\n        \"\"\"This method is not used but is required by the abstract class.\"\"\"\n        pass\n\n    def update(self):\n        \"\"\"We overwrite the default method.\"\"\"\n        pass\n\n    def _read(self) -&gt; MosaicJSON:\n        \"\"\"This method is not used but is required by the abstract class.\"\"\"\n        pass\n\n    def assets_for_tile(self, x: int, y: int, z: int) -&gt; List[str]:\n        \"\"\"Retrieve assets for tile.\"\"\"\n        return self.get_assets()\n\n    def assets_for_point(self, lng: float, lat: float) -&gt; List[str]:\n        \"\"\"Retrieve assets for point.\"\"\"\n        return self.get_assets()\n\n    def get_assets(self) -&gt; List[str]:\n        \"\"\"assets are just files we give in path\"\"\"\n        return self.input\n\n    @property\n    def _quadkeys(self) -&gt; List[str]:\n        return []\n</code></pre> <p>2 - Create endpoints</p> <pre><code>\"\"\"routes.\n\napp/routers.py\n\n\"\"\"\n\nfrom dataclasses import dataclass\nfrom typing import List\n\nfrom titiler.mosaic.factory import MosaicTilerFactory\nfrom fastapi import Query\n\nfrom .backends import MultiFilesBackend\n\n@dataclass\nclass MosaicTiler(MosaicTilerFactory):\n    \"\"\"Custom MosaicTilerFactory.\n\n    Note this is a really simple MosaicTiler Factory with only few endpoints.\n    \"\"\"\n\n    def register_routes(self):\n        \"\"\"This Method register routes to the router. \"\"\"\n\n        self.tile()\n        self.tilejson()\n\n\ndef DatasetPathParams(url: str = Query(..., description=\"Dataset URL\")) -&gt; List[str]:\n    \"\"\"Create dataset path from args\"\"\"\n    return url.split(\",\")\n\n\nmosaic = MosaicTiler(backend=MultiFilesBackend, path_dependency=DatasetPathParams)\n</code></pre> <p>3 - Create app and register our custom endpoints</p> <pre><code>\"\"\"app.\n\napp/main.py\n\n\"\"\"\n\nfrom titiler.core.errors import DEFAULT_STATUS_CODES, add_exception_handlers\nfrom titiler.mosaic.errors import MOSAIC_STATUS_CODES\n\nfrom fastapi import FastAPI\n\nfrom .routers import mosaic\n\napp = FastAPI()\napp.include_router(mosaic.router)\nadd_exception_handlers(app, DEFAULT_STATUS_CODES)\nadd_exception_handlers(app, MOSAIC_STATUS_CODES)\n</code></pre> <ol> <li>Run and Use</li> </ol> <pre><code>$ uvicorn app:app --reload\n\n$ curl http://127.0.0.1:8000/tilejson.json?url=cog1.tif,cog2.tif\n</code></pre> <p>Gotcha</p> <ul> <li>bounds of the mosaic backend is set to <code>[-180, -90, 180, 90]</code></li> <li>minzoom is set to 0</li> <li>maxzoom is set to 30</li> </ul>"},{"location":"examples/code/tiler_for_sentinel2/","title":"Custom Sentinel 2 Tiler","text":"<p>Goal: Create a dynamic tiler for Sentinel-2 (using AWS Public Dataset)</p> <p>requirements: titiler.core, titiler.mosaic, rio-tiler-pds</p> <p>Note: See developmentseed/titiler-pds for a end-to-end implementation</p>"},{"location":"examples/code/tiler_for_sentinel2/#sentinel-2","title":"Sentinel 2","text":"<p>Thanks to Digital Earth Africa and in collaboration with Sinergise, Element 84, Amazon Web Services (AWS) and the Committee on Earth Observation Satellites (CEOS), Sentinel 2 (Level 2) data over Africa, usually stored as JPEG2000, has been translated to COG. More importantly, a STAC database and API has been set up.</p> <p>www.digitalearthafrica.org/news/operational-and-ready-use-satellite-data-now-available-across-africa</p> <p>The API is provided by @element84 and follows the latest specification: earth-search.aws.element84.com/v0</p> <pre><code>\"\"\"Sentinel 2 (COG) Tiler.\"\"\"\n\nfrom titiler.core.factory import MultiBandTilerFactory\nfrom titiler.core.dependencies import BandsExprParams\nfrom titiler.mosaic.factory import MosaicTilerFactory\n\nfrom rio_tiler_pds.sentinel.aws import S2COGReader\nfrom rio_tiler_pds.sentinel.utils import s2_sceneid_parser\n\nfrom fastapi import FastAPI, Query\n\n\ndef CustomPathParams(\n    sceneid: str = Query(..., description=\"Sentinel 2 Sceneid.\")\n):\n    \"\"\"Create dataset path from args\"\"\"\n    assert s2_sceneid_parser(sceneid)  # Makes sure the sceneid is valid\n    return sceneid\n\n\napp = FastAPI()\n\nscene_tiler = MultiBandTilerFactory(reader=S2COGReader, path_dependency=CustomPathParams, router_prefix=\"scenes\")\napp.include_router(scene_tiler.router, prefix=\"/scenes\", tags=[\"scenes\"])\n\nmosaic_tiler = MosaicTilerFactory(\n    router_prefix=\"mosaic\",\n    dataset_reader=S2COGReader,\n    layer_dependency=BandsExprParams,\n)\napp.include_router(mosaic_tiler.router, prefix=\"/mosaic\", tags=[\"mosaic\"])\n</code></pre>"},{"location":"examples/code/tiler_for_sentinel2/#how-to","title":"How to","text":"<ol> <li> <p>Search for Data <pre><code>import os\nimport json\nimport base64\nimport httpx\nimport datetime\nimport itertools\nimport urllib.parse\nimport pathlib\n\nfrom io import BytesIO\nfrom functools import partial\nfrom concurrent import futures\n\nfrom rasterio.plot import reshape_as_image\nfrom rasterio.features import bounds as featureBounds\n\n# Endpoint variables\ntitiler_endpoint = \"http://127.0.0.1:8000\"\nstac_endpoint = \"https://earth-search.aws.element84.com/v0/search\"\n\n# Make sure both are up\nassert httpx.get(f\"{titiler_endpoint}/docs\").status_code == 200\nassert httpx.get(stac_endpoint).status_code == 200\n\ngeojson = {\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"properties\": {},\n      \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n          [\n            [\n              -2.83447265625,\n              4.12728532324537\n            ],\n            [\n              2.120361328125,\n              4.12728532324537\n            ],\n            [\n              2.120361328125,\n              8.254982704877875\n            ],\n            [\n              -2.83447265625,\n              8.254982704877875\n            ],\n            [\n              -2.83447265625,\n              4.12728532324537\n            ]\n          ]\n        ]\n      }\n    }\n  ]\n}\n\nbounds = featureBounds(geojson)\n\nstart = datetime.datetime.strptime(\"2019-01-01\", \"%Y-%m-%d\").strftime(\"%Y-%m-%dT00:00:00Z\")\nend = datetime.datetime.strptime(\"2019-12-11\", \"%Y-%m-%d\").strftime(\"%Y-%m-%dT23:59:59Z\")\n\n# POST body\nquery = {\n    \"collections\": [\"sentinel-s2-l2a-cogs\"],\n    \"datetime\": f\"{start}/{end}\",\n    \"query\": {\n        \"eo:cloud_cover\": {\n            \"lt\": 3\n        },\n        \"sentinel:data_coverage\": {\n            \"gt\": 10\n        }\n    },\n    \"intersects\": geojson[\"features\"][0][\"geometry\"],\n    \"limit\": 1000,\n    \"fields\": {\n      'include': ['id', 'properties.datetime', 'properties.eo:cloud_cover'],  # This will limit the size of returned body\n      'exclude': ['assets', 'links']  # This will limit the size of returned body\n    },\n    \"sortby\": [\n        {\n            \"field\": \"properties.eo:cloud_cover\",\n            \"direction\": \"desc\"\n        },\n    ]\n}\n\n# POST Headers\nheaders = {\n    \"Content-Type\": \"application/json\",\n    \"Accept-Encoding\": \"gzip\",\n    \"Accept\": \"application/geo+json\",\n}\n\ndata = httpx.post(stac_endpoint, headers=headers, json=query).json()\nprint(\"Results context:\")\nprint(data[\"context\"])\n\nsceneid = [f[\"id\"] for f in data[\"features\"]]\ncloudcover = [f[\"properties\"][\"eo:cloud_cover\"] for f in data[\"features\"]]\ndates = [f[\"properties\"][\"datetime\"][0:10] for f in data[\"features\"]]\n</code></pre></p> </li> <li> <p>Get TileJSON <pre><code># Fetch TileJSON\n# For this example we use the first `sceneid` returned from the STAC API\n# and we sent the Bands to B04,B03,B02 which are red,green,blue\ndata = httpx.get(f\"{titiler_endpoint}/scenes/WebMercatorQuad/tilejson.json?sceneid={sceneid[4]}&amp;bands=B04&amp;bands=B03&amp;bands=B02&amp;rescale=0,2000\").json()\nprint(data)\n</code></pre></p> </li> <li> <p>Mosaic</p> </li> </ol> <pre><code>from cogeo_mosaic.backends import MosaicBackend\nfrom typing import Dict, List, Sequence, Optional\nfrom pygeos import polygons\nimport mercantile\n\n# Simple Mosaic\ndef custom_accessor(feature):\n    \"\"\"Return feature identifier.\"\"\"\n    return feature[\"id\"]\n\nwith MosaicBackend(\n    \"stac+https://earth-search.aws.element84.com/v0/search\",\n    query,\n    minzoom=8,\n    maxzoom=15,\n    mosaic_options={\"accessor\": custom_accessor},\n) as mosaic:\n    print(mosaic.metadata)\n    mosaic_doc = mosaic.mosaic_def.dict(exclude_none=True)\n\n# Optimized Mosaic\ndef optimized_filter(\n    tile: mercantile.Tile,  # noqa\n    dataset: Sequence[Dict],\n    geoms: Sequence[polygons],\n    minimum_tile_cover=None,  # noqa\n    tile_cover_sort=False,  # noqa\n    maximum_items_per_tile: Optional[int] = None,\n) -&gt; List:\n    \"\"\"Optimized filter that keeps only one item per grid ID.\"\"\"\n    gridid: List[str] = []\n    selected_dataset: List[Dict] = []\n\n    for item in dataset:\n        grid = item[\"id\"].split(\"_\")[1]\n        if grid not in gridid:\n            gridid.append(grid)\n            selected_dataset.append(item)\n\n    dataset = selected_dataset\n\n    indices = list(range(len(dataset)))\n    if maximum_items_per_tile:\n        indices = indices[:maximum_items_per_tile]\n\n    return [dataset[ind] for ind in indices]\n\n\nwith MosaicBackend(\n    \"stac+https://earth-search.aws.element84.com/v0/search\",\n    query,\n    minzoom=8,\n    maxzoom=14,\n    mosaic_options={\"accessor\": custom_accessor, \"asset_filter\": optimized_filter},\n) as mosaic:\n    print(mosaic.metadata)\n    mosaic_doc = mosa\n\n# Write the mosaic\nmosaic_file = \"mymosaic.json.gz\"\nwith MosaicBackend(mosaic_file, mosaic_def=mosaic_doc) as mosaic:\n    mosaic.write(overwrite=True)\n</code></pre> <p>Use the mosaic in titiler <pre><code>mosaic = str(pathlib.Path(mosaic_file).absolute())\ndata = httpx.get(f\"{titiler_endpoint}/mosaic/WebMercatorQuad/tilejson.json?url=file:///{mosaic}&amp;bands=B01&amp;rescale=0,1000\").json()\nprint(data)\n</code></pre></p>"},{"location":"examples/code/tiler_with_auth/","title":"Tiler with Auth","text":"<p>Goal: Add simple token auth</p> <p>requirements: titiler.core, python-jose[cryptography]</p> <p>Learn more about security over FastAPI documentation</p> <p>1 - Security settings (secret key)</p> <pre><code>\"\"\"Security Settings.\n\napp/settings.py\n\n\"\"\"\n\nfrom pydantic import BaseSettings\n\n\nclass AuthSettings(BaseSettings):\n    \"\"\"Application settings\"\"\"\n\n    # Create secret key using `openssl rand -hex 32`\n    # example: \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\"\n    secret: str\n    expires: int = 3600\n    algorithm: str = \"HS256\"\n\n    class Config:\n        \"\"\"model config\"\"\"\n\n        env_prefix = \"SECURITY_\"\n\n\nauth_config = AuthSettings()\n</code></pre> <p>2 - Create a Token <code>Model</code></p> <pre><code>\"\"\"Models.\n\napp/models.py\n\n\"\"\"\n\nfrom datetime import datetime, timedelta, timezone\nfrom typing import List, Optional\n\nfrom jose import jwt\nfrom pydantic import BaseModel, Field, validator\n\nfrom .settings import auth_config\n\n# We add scopes - because we are fancy\navailables_scopes = [\"tiles:read\"]\n\n\nclass AccessToken(BaseModel):\n    \"\"\"API Token info.\"\"\"\n\n    sub: str = Field(..., alias=\"username\", regex=\"^[a-zA-Z0-9-_]{1,32}$\")\n    scope: List = [\"tiles:read\"]\n    iat: Optional[datetime] = None\n    exp: Optional[datetime] = None\n    groups: Optional[List[str]]\n\n    @validator(\"iat\", pre=True, always=True)\n    def set_creation_time(cls, v) -&gt; datetime:\n        \"\"\"Set token creation time (iat).\"\"\"\n        return datetime.now(timezone.UTC)\n\n    @validator(\"exp\", always=True)\n    def set_expiration_time(cls, v, values) -&gt; datetime:\n        \"\"\"Set token expiration time (iat).\"\"\"\n        return values[\"iat\"] + timedelta(seconds=auth_config.expires)\n\n    @validator(\"scope\", each_item=True)\n    def valid_scopes(cls, v, values):\n        \"\"\"Validate Scopes.\"\"\"\n        v = v.lower()\n        if v not in availables_scopes:\n            raise ValueError(f\"Invalid scope: {v}\")\n        return v.lower()\n\n    class Config:\n        \"\"\"Access Token Model config.\"\"\"\n\n        extra = \"forbid\"\n\n    @property\n    def username(self) -&gt; str:\n        \"\"\"Return Username.\"\"\"\n        return self.sub\n\n    def __str__(self):\n        \"\"\"Create jwt token string.\"\"\"\n        return jwt.encode(\n            self.dict(exclude_none=True),\n            auth_config.secret,\n            algorithm=auth_config.algorithm,\n        )\n\n    @classmethod\n    def from_string(cls, token: str):\n        \"\"\"Parse jwt token string.\"\"\"\n        res = jwt.decode(token, auth_config.secret, algorithms=[auth_config.algorithm])\n        user = res.pop(\"sub\")\n        res[\"username\"] = user\n        return cls(**res)\n</code></pre> <p>3 - Create a custom <code>path dependency</code></p> <p>The <code>DatasetPathParams</code> will add 2 querystring parameter to our application: - <code>url</code>: the dataset url (like in the regular titiler app) - <code>access_token</code>: our <code>token</code> parameter</p> <pre><code>\"\"\"Dependencies.\n\napp/dependencies.py\n\n\"\"\"\n\nfrom jose import JWTError\n\nfrom fastapi import HTTPException, Query, Security\nfrom fastapi.security.api_key import APIKeyQuery\n\nfrom .models import AccessToken\n\napi_key_query = APIKeyQuery(name=\"access_token\", auto_error=False)\n\n\n# Custom Dataset Path dependency\ndef DatasetPathParams(\n    url: str = Query(..., description=\"Dataset URL\"),\n    api_key_query: str = Security(api_key_query)\n) -&gt; str:\n    \"\"\"Create dataset path from args\"\"\"\n\n    if not api_key_query:\n        raise HTTPException(status_code=401, detail=\"Missing `access_token`\")\n\n    try:\n        AccessToken.from_string(api_key_query)\n    except JWTError:\n        raise HTTPException(status_code=401, detail=\"Invalid `access_token`\")\n\n    return url\n</code></pre> <p>3b - Create a Token creation/read endpoint (Optional)</p> <pre><code>\"\"\"Tokens App.\n\napp/tokens.py\n\n\"\"\"\n\nfrom typing import Any, Dict\n\nfrom .models import AccessToken\n\nfrom fastapi import APIRouter, Query\n\nrouter = APIRouter()\n\n\n@router.post(r\"/create\", responses={200: {\"description\": \"Create a token\"}})\ndef create_token(body: AccessToken):\n    \"\"\"create token.\"\"\"\n    return {\"token\": str(body)}\n\n\n@router.get(r\"/create\", responses={200: {\"description\": \"Create a token\"}})\ndef get_token(\n    username: str = Query(..., description=\"Username\"),\n    scope: str = Query(None, description=\"Coma (,) delimited token scopes\"),\n):\n    \"\"\"create token.\"\"\"\n    params: Dict[str, Any] = {\"username\": username}\n    if scope:\n        params[\"scope\"] = scope.split(\",\")\n    token = AccessToken(**params)\n    return {\"token\": str(token)}\n</code></pre> <p>4 - Create the Tiler app with our custom <code>DatasetPathParams</code></p> <pre><code>\"\"\"app\n\napp/main.py\n\n\"\"\"\n\nfrom titiler.core.factory import TilerFactory\nfrom titiler.core.errors import DEFAULT_STATUS_CODES, add_exception_handlers\n\nfrom fastapi import FastAPI\n\nfrom .dependencies import DatasetPathParams\n\napp = FastAPI(title=\"My simple app with auth\")\n\n# here we create a custom Tiler with out custom DatasetPathParams function\ncog = TilerFactory(path_dependency=DatasetPathParams)\napp.include_router(cog.router, tags=[\"Cloud Optimized GeoTIFF\"])\n\n# optional\nfrom . import tokens\napp.include_router(tokens.router)\n\nadd_exception_handlers(app, DEFAULT_STATUS_CODES)\n</code></pre>"},{"location":"examples/code/tiler_with_cache/","title":"Tiler with Cache","text":"<p>Goal: Add a cache layer on top of the tiler</p> <p>requirements: titiler.core, aiocache[redis]</p> <p>Note: Use aioredis 1.3 because aiocache doesnt work with aioredis version 2.0</p> <p>1 - Cache settings</p> <pre><code>\"\"\"settings.\n\napp/settings.py\n\n\"\"\"\n\nfrom pydantic import BaseSettings\nfrom typing import Optional\n\n\nclass CacheSettings(BaseSettings):\n    \"\"\"Cache settings\"\"\"\n\n    endpoint: Optional[str] = None\n    ttl: int = 3600\n    namespace: str = \"\"\n\n    class Config:\n        \"\"\"model config\"\"\"\n\n        env_file = \".env\"\n        env_prefix = \"CACHE_\"\n\n\ncache_setting = CacheSettings()\n</code></pre> <p>Env file example with redis URI</p> <pre><code>CACHE_ENDPOINT=redis://127.0.0.1:6379/0\n</code></pre> <p>2 - Cache plugin</p> <p>Because <code>aiocache.cached</code> doesn't support non-async method we have to create a custom <code>cached</code> class</p> <pre><code>\"\"\"Cache Plugin.\n\napp/cache.py\n\n\"\"\"\n\nimport asyncio\nimport urllib\nfrom typing import Any, Dict\n\nimport aiocache\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.responses import Response\n\nfrom fastapi.dependencies.utils import is_coroutine_callable\n\nfrom .settings import cache_setting\n\n\nclass cached(aiocache.cached):\n    \"\"\"Custom Cached Decorator.\"\"\"\n\n    async def get_from_cache(self, key):\n        try:\n            value = await self.cache.get(key)\n            if isinstance(value, Response):\n                value.headers[\"X-Cache\"] = \"HIT\"\n            return value\n        except Exception:\n            aiocache.logger.exception(\n                \"Couldn't retrieve %s, unexpected error\", key\n            )\n\n    async def decorator(\n        self,\n        f,\n        *args,\n        cache_read=True,\n        cache_write=True,\n        aiocache_wait_for_write=True,\n        **kwargs,\n    ):\n        key = self.get_cache_key(f, args, kwargs)\n\n        if cache_read:\n            value = await self.get_from_cache(key)\n            if value is not None:\n                return value\n\n        # CUSTOM, we add support for non-async method\n        if is_coroutine_callable(f):\n            result = await f(*args, **kwargs)\n        else:\n            result = await run_in_threadpool(f, *args, **kwargs)\n\n        if cache_write:\n            if aiocache_wait_for_write:\n                await self.set_in_cache(key, result)\n            else:\n                asyncio.ensure_future(self.set_in_cache(key, result))\n\n        return result\n\n\ndef setup_cache():\n    \"\"\"Setup aiocache.\"\"\"\n    config: Dict[str, Any] = {\n        'cache': \"aiocache.SimpleMemoryCache\",\n        'serializer': {\n            'class': \"aiocache.serializers.PickleSerializer\"\n        }\n    }\n    if cache_setting.ttl is not None:\n        config[\"ttl\"] = cache_setting.ttl\n\n    if cache_setting.endpoint:\n        url = urllib.parse.urlparse(cache_setting.endpoint)\n        ulr_config = dict(urllib.parse.parse_qsl(url.query))\n        config.update(ulr_config)\n\n        cache_class = aiocache.Cache.get_scheme_class(url.scheme)\n        config.update(cache_class.parse_uri_path(url.path))\n        config[\"endpoint\"] = url.hostname\n        config[\"port\"] = str(url.port)\n\n        # Add other configuration into config here, Example for namespace:\n        \"\"\"\n        if cache_setting.namespace != \"\":\n            config[\"namespace\"] = cache_setting.namespace\n        \"\"\"\n\n        if url.password:\n            config[\"password\"] = url.password\n\n        if cache_class == aiocache.Cache.REDIS:\n            config[\"cache\"] = \"aiocache.RedisCache\"\n        elif cache_class == aiocache.Cache.MEMCACHED:\n            config[\"cache\"] = \"aiocache.MemcachedCache\"\n\n    aiocache.caches.set_config({\"default\": config})\n</code></pre> <p>3 - Write a custom minimal Tiler with Cache</p> <pre><code>\"\"\"routes.\n\napp/routes.py\n\"\"\"\nfrom dataclasses import dataclass\nfrom typing import Callable, Dict, Type, Literal, List, Tuple, Optional\nfrom urllib.parse import urlencode\n\nfrom fastapi import Depends, Path, Query\nfrom starlette.requests import Request\nfrom starlette.responses import Response\n\nfrom morecantile import TileMatrixSet\nfrom rio_tiler.io import BaseReader, Reader\n\nfrom titiler.core.factory import img_endpoint_params\nfrom titiler.core.factory import TilerFactory as TiTilerFactory\nfrom titiler.core.dependencies import RescalingParams\nfrom titiler.core.models.mapbox import TileJSON\nfrom titiler.core.resources.enums import ImageType\n\nfrom .cache import cached\n\n\n@dataclass\nclass TilerFactory(TiTilerFactory):\n\n    reader: Type[BaseReader] = Reader\n\n    def register_routes(self):\n        \"\"\"This Method register routes to the router.\"\"\"\n\n        @self.router.get(r\"/tiles/{z}/{x}/{y}\", **img_endpoint_params)\n        @self.router.get(r\"/tiles/{z}/{x}/{y}.{format}\", **img_endpoint_params)\n        @self.router.get(r\"/tiles/{z}/{x}/{y}@{scale}x\", **img_endpoint_params)\n        @self.router.get(r\"/tiles/{z}/{x}/{y}@{scale}x.{format}\", **img_endpoint_params)\n        @self.router.get(r\"/tiles/{tileMatrixSetId}/{z}/{x}/{y}\", **img_endpoint_params)\n        @self.router.get(\n            r\"/tiles/{tileMatrixSetId}/{z}/{x}/{y}.{format}\", **img_endpoint_params\n        )\n        @self.router.get(\n            r\"/tiles/{tileMatrixSetId}/{z}/{x}/{y}@{scale}x\", **img_endpoint_params\n        )\n        @self.router.get(\n            r\"/tiles/{tileMatrixSetId}/{z}/{x}/{y}@{scale}x.{format}\",\n            **img_endpoint_params,\n        )\n        # Add default cache config dictionary into cached alias.\n        # Note: if alias is used, other arguments in cached will be ignored. Add other arguments into default dicttionary in setup_cache function.\n        @cached(alias=\"default\")\n        def tile(\n            z: int = Path(..., ge=0, le=30, description=\"TMS tiles's zoom level\"),\n            x: int = Path(..., description=\"TMS tiles's column\"),\n            y: int = Path(..., description=\"TMS tiles's row\"),\n            tileMatrixSetId: Literal[tuple(self.supported_tms.list())] = Query(\n                self.default_tms,\n                description=f\"TileMatrixSet Name (default: '{self.default_tms}')\",\n            ),\n            scale: int = Query(\n                1, gt=0, lt=4, description=\"Tile size scale. 1=256x256, 2=512x512...\"\n            ),\n            format: ImageType = Query(\n                None, description=\"Output image type. Default is auto.\"\n            ),\n            src_path=Depends(self.path_dependency),\n            layer_params=Depends(self.layer_dependency),\n            dataset_params=Depends(self.dataset_dependency),\n            buffer: Optional[float] = Query(\n                None,\n                gt=0,\n                title=\"Tile buffer.\",\n                description=\"Buffer on each side of the given tile. It must be a multiple of `0.5`. Output **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257, 1.0 = 258x258).\",\n            ),\n            post_process=Depends(self.process_dependency),\n            rescale: Optional[List[Tuple[float, ...]]] = Depends(RescalingParams),\n            color_formula: Optional[str] = Query(\n                None,\n                title=\"Color Formula\",\n                description=\"rio-color formula (info: https://github.com/mapbox/rio-color)\",\n            ),\n            colormap=Depends(self.colormap_dependency),\n            render_params=Depends(self.render_dependency),\n            reader_params=Depends(self.reader_dependency),\n        ):\n            \"\"\"Create map tile from a dataset.\"\"\"\n            tms = self.supported_tms.get(tileMatrixSetId)\n\n            with self.reader(src_path, tms=tms, **reader_params) as src_dst:\n                image = src_dst.tile(\n                    x,\n                    y,\n                    z,\n                    tilesize=scale * 256,\n                    buffer=buffer,\n                    **layer_params,\n                    **dataset_params,\n                )\n                dst_colormap = getattr(src_dst, \"colormap\", None)\n\n\n            if post_process:\n                image = post_process(image)\n\n            if rescale:\n                image.rescale(rescale)\n\n            if color_formula:\n                image.apply_color_formula(color_formula)\n\n            if cmap := colormap or dst_colormap:\n                image = image.apply_colormap(cmap)\n\n            if not format:\n                format = ImageType.jpeg if image.mask.all() else ImageType.png\n\n            content = image.render(\n                img_format=format.driver,\n                **format.profile,\n                **render_params,\n            )\n\n            return Response(content, media_type=format.mediatype)\n\n        @self.router.get(\n            \"/tilejson.json\",\n            response_model=TileJSON,\n            responses={200: {\"description\": \"Return a tilejson\"}},\n            response_model_exclude_none=True,\n        )\n        @self.router.get(\n            \"/{tileMatrixSetId}/tilejson.json\",\n            response_model=TileJSON,\n            responses={200: {\"description\": \"Return a tilejson\"}},\n            response_model_exclude_none=True,\n        )\n        @cached(alias=\"default\")\n        def tilejson(\n            request: Request,\n            tileMatrixSetId: Literal[tuple(self.supported_tms.list())] = Query(\n                self.default_tms,\n                description=f\"TileMatrixSet Name (default: '{self.default_tms}')\",\n            ),\n            src_path=Depends(self.path_dependency),\n            tile_format: Optional[ImageType] = Query(\n                None, description=\"Output image type. Default is auto.\"\n            ),\n            tile_scale: int = Query(\n                1, gt=0, lt=4, description=\"Tile size scale. 1=256x256, 2=512x512...\"\n            ),\n            minzoom: Optional[int] = Query(\n                None, description=\"Overwrite default minzoom.\"\n            ),\n            maxzoom: Optional[int] = Query(\n                None, description=\"Overwrite default maxzoom.\"\n            ),\n            layer_params=Depends(self.layer_dependency),  # noqa\n            dataset_params=Depends(self.dataset_dependency),  # noqa\n            buffer: Optional[float] = Query(  # noqa\n                None,\n                gt=0,\n                title=\"Tile buffer.\",\n                description=\"Buffer on each side of the given tile. It must be a multiple of `0.5`. Output **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257, 1.0 = 258x258).\",\n            ),\n            post_process=Depends(self.process_dependency),  # noqa\n            rescale: Optional[List[Tuple[float, ...]]] = Depends(\n                RescalingParams\n            ),  # noqa\n            color_formula: Optional[str] = Query(  # noqa\n                None,\n                title=\"Color Formula\",\n                description=\"rio-color formula (info: https://github.com/mapbox/rio-color)\",\n            ),\n            colormap=Depends(self.colormap_dependency),  # noqa\n            render_params=Depends(self.render_dependency),  # noqa\n            reader_params=Depends(self.reader_dependency),\n        ):\n            \"\"\"Return TileJSON document for a dataset.\"\"\"\n            route_params = {\n                \"z\": \"{z}\",\n                \"x\": \"{x}\",\n                \"y\": \"{y}\",\n                \"scale\": tile_scale,\n                \"tileMatrixSetId\": tileMatrixSetId,\n            }\n            if tile_format:\n                route_params[\"format\"] = tile_format.value\n\n            tiles_url = self.url_for(request, \"tile\", **route_params)\n\n            qs_key_to_remove = [\n                \"tilematrixsetid\",\n                \"tile_format\",\n                \"tile_scale\",\n                \"minzoom\",\n                \"maxzoom\",\n            ]\n            qs = [\n                (key, value)\n                for (key, value) in request.query_params._list\n                if key.lower() not in qs_key_to_remove\n            ]\n            if qs:\n                tiles_url += f\"?{urlencode(qs)}\"\n\n            tms = self.supported_tms.get(tileMatrixSetId)\n            with self.reader(src_path, tms=tms, **reader_params) as src_dst:\n                return {\n                    \"bounds\": src_dst.geographic_bounds,\n                    \"minzoom\": minzoom if minzoom is not None else src_dst.minzoom,\n                    \"maxzoom\": maxzoom if maxzoom is not None else src_dst.maxzoom,\n                    \"tiles\": [tiles_url],\n                }\n\n        # Register Map viewer\n        self.map_viewer()\n\ncog = TilerFactory()\n</code></pre> <p>4 - Create the Tiler app with our custom <code>DatasetPathParams</code></p> <pre><code>\"\"\"app\n\napp/main.py\n\n\"\"\"\n\nfrom titiler.core.errors import DEFAULT_STATUS_CODES, add_exception_handlers\n\nfrom fastapi import FastAPI\n\nfrom .cache import setup_cache\nfrom .routes import cog\n\napp = FastAPI(title=\"My simple app with cache\")\n\n# Setup Cache on Startup\napp.add_event_handler(\"startup\", setup_cache)\nadd_exception_handlers(app, DEFAULT_STATUS_CODES)\n\napp.include_router(cog.router, tags=[\"Cloud Optimized GeoTIFF\"])\n</code></pre>"},{"location":"examples/code/tiler_with_custom_algorithm/","title":"Add custom algorithms","text":"<p>Goal: add custom Algorithm to a tiler</p> <p>requirements: titiler.core</p> <p>1 - Create a custom algorithm and register it to the list of available algorithms</p> <pre><code>\"\"\"algos.\n\napp/algorithms.py\n\n\"\"\"\nfrom titiler.core.algorithm import BaseAlgorithm\nfrom titiler.core.algorithm import algorithms as default_algorithms\n\nfrom rio_tiler.models import ImageData\n\n\nclass Multiply(BaseAlgorithm):\n\n    # Parameters\n    factor: int # There is no default, which means calls to this algorithm without any parameter will fail\n\n    # We don't set any metadata for this Algorithm\n\n    def __call__(self, img: ImageData) -&gt; ImageData:\n        # Multiply image data bcy factor\n        data = img.data * self.factor\n\n        # Create output ImageData\n        return ImageData(\n            data,\n            assets=img.assets,\n            crs=img.crs,\n            bounds=img.bounds,\n        )\n\n# default_algorithms is a `titiler.core.algorithm.Algorithms` Object\nalgorithms = default_algorithms.register(\n    {\n        \"multiply\": Multiply,\n    }\n)\n</code></pre> <p>2 - Create application and register endpoints</p> <pre><code>\"\"\"application.\n\napp/app.py\n\n\"\"\"\nfrom fastapi import FastAPI\nfrom titiler.core.factory import TilerFactory\n\nfrom .algorithms import algorithms\n\n\napp = FastAPI(title=\"My simple app with custom Algorithm\")\n\n# The Algorithms class (titiler.core.algorithm.algorithms) as a `dependency` property which return a process_dependency.\ntiler = TilerFactory(process_dependency=algorithms.dependency)\napp.include_router(tiler.router)\n</code></pre>"},{"location":"examples/code/tiler_with_custom_colormap/","title":"Tiler with custom Colormap dependency","text":"<p>Goal: Add a custom colormap dependency to allow user pass linear <code>colormap</code> definition.</p> <pre><code># https://colorbrewer2.org/#type=sequential&amp;scheme=BuGn&amp;n=3\ncmap = urlencode(\n    {\n        \"colormap\": json.dumps(\n            {\n                \"0\": \"#e5f5f9\",\n                \"10\": \"#99d8c9\",\n                \"255\": \"#2ca25f\",\n            }\n        )\n    }\n)\nresponse = requests.get(\n    f\"http://127.0.0.1:8000/cog/tiles/WebMercatorQuad/8/53/50.png?url=https://myurl.com/cog.tif&amp;bidx=1&amp;rescale=0,10000&amp;{cmap}\"\n)\n</code></pre> <p>requirements: titiler.core matplotlib</p> <p>1 - Create a custom <code>ColorMapParams</code> dependency</p> <pre><code>\"\"\"dependencies.\n\napp/dependencies.py\n\n\"\"\"\n\nimport json\n\nfrom typing import Dict, Optional, Literal\nfrom typing_extensions import Annotated\n\nimport numpy\nimport matplotlib\nfrom rio_tiler.colormap import parse_color\nfrom rio_tiler.colormap import cmap as default_cmap\nfrom fastapi import HTTPException, Query\n\n\ndef ColorMapParams(\n    colormap_name: Annotated[  # type: ignore\n        Literal[tuple(default_cmap.list())],\n        Query(description=\"Colormap name\"),\n    ] = None,\n    colormap: Annotated[\n        str,\n        Query(description=\"JSON encoded custom Colormap\"),\n    ] = None,\n    colormap_type: Annotated[\n        Literal[\"explicit\", \"linear\"],\n        Query(description=\"User input colormap type.\"),\n    ] = \"explicit\",\n) -&gt; Optional[Dict]:\n    \"\"\"Colormap Dependency.\"\"\"\n    if colormap_name:\n        return default_cmap.get(colormap_name)\n\n    if colormap:\n        try:\n            cm = json.loads(\n                colormap,\n                object_hook=lambda x: {int(k): parse_color(v) for k, v in x.items()},\n            )\n        except json.JSONDecodeError:\n            raise HTTPException(\n                status_code=400, detail=\"Could not parse the colormap value.\"\n            )\n\n        if colormap_type == \"linear\":\n            # input colormap has to start from 0 to 255 ?\n            cm = matplotlib.colors.LinearSegmentedColormap.from_list(\n                'custom',\n                [\n                    (k / 255, matplotlib.colors.to_hex([v / 255 for v in rgba]))\n                    for (k, rgba) in cm.items()\n                ],\n                256,\n            )\n            x = numpy.linspace(0, 1, 256)\n            cmap_vals = cm(x)[:, :]\n            cmap_uint8 = (cmap_vals * 255).astype('uint8')\n            cm = {idx: value.tolist() for idx, value in enumerate(cmap_uint8)}\n\n        return cm\n\n    return None\n</code></pre> <p>2 - Create app and register our custom endpoints</p> <pre><code>\"\"\"app.\n\napp/main.py\n\n\"\"\"\n\nfrom titiler.core.errors import DEFAULT_STATUS_CODES, add_exception_handlers\nfrom titiler.core.factory import TilerFactory\n\nfrom fastapi import FastAPI\n\nfrom .dependencies import ColorMapParams\n\napp = FastAPI(title=\"My simple app with custom TMS\")\n\ncog = TilerFactory(colormap_dependency=ColorMapParams)\napp.include_router(cog.router, tags=[\"Cloud Optimized GeoTIFF\"])\nadd_exception_handlers(app, DEFAULT_STATUS_CODES)\n</code></pre>"},{"location":"examples/code/tiler_with_custom_stac%2Bxarray/","title":"STAC + Xarray","text":"<p>Goal: Create a custom STAC Reader supporting both COG and NetCDF/Zarr dataset</p> <p>requirements:</p> <ul> <li><code>titiler.core</code></li> <li><code>titiler.xarray</code></li> <li><code>fsspec</code></li> <li><code>zarr</code></li> <li><code>h5netcdf</code></li> <li><code>aiohttp</code> (optional)</li> <li><code>s3fs</code> (optional)</li> </ul> <p>links:</p> <ul> <li>cogeotiff.github.io/rio-tiler/examples/STAC_datacube_support/</li> </ul>"},{"location":"examples/code/tiler_with_custom_stac%2Bxarray/#1-custom-stacreader","title":"1. Custom STACReader","text":"<p>First, we need to create a custom <code>STACReader</code> which will support both COG and NetCDF/Zarr dataset. The custom parts will be:</p> <ul> <li>add <code>netcdf</code> and <code>zarr</code> as valid asset media types</li> <li>introduce a new <code>md://</code> prefixed asset form, so users can pass <code>assets=md://{netcdf asset name}?variable={variable name}</code> as we do for the <code>GDAL vrt string connection</code> support.</li> </ul> stac.py<pre><code>from typing import Set, Type, Tuple, Dict, Optional\n\nimport attr\nfrom urllib.parse import urlparse, parse_qsl\nfrom rio_tiler.types import AssetInfo\nfrom rio_tiler.io import BaseReader, Reader\nfrom rio_tiler.io import stac\n\nfrom titiler.xarray.io import Reader as XarrayReader\n\nvalid_types = {\n    *stac.DEFAULT_VALID_TYPE,\n    \"application/x-netcdf\",\n    \"application/vnd+zarr\",\n}\n\n\n@attr.s\nclass STACReader(stac.STACReader):\n    \"\"\"Custom STACReader which adds support for `md://` prefixed assets.\n\n    Example:\n    &gt;&gt;&gt; with STACReader(\"https://raw.githubusercontent.com/cogeotiff/rio-tiler/refs/heads/main/tests/fixtures/stac_netcdf.json\") as src:\n            print(src.assets)\n            print(src._get_asset_info(\"md://netcdf?variable=dataset\"))\n\n        ['geotiff', 'netcdf']\n        {'url': 'https://raw.githubusercontent.com/cogeotiff/rio-tiler/refs/heads/main/tests/fixtures/dataset_2d.nc', 'metadata': {}, 'reader_options': {'variable': 'dataset'}, 'media_type': 'application/x-netcdf'}\n\n    \"\"\"\n    include_asset_types: Set[str] = attr.ib(default=valid_types)\n\n    def _get_reader(self, asset_info: AssetInfo) -&gt; Tuple[Type[BaseReader], Dict]:\n        \"\"\"Get Asset Reader.\"\"\"\n        asset_type = asset_info.get(\"media_type\", None)\n        if asset_type and asset_type in [\n            \"application/x-netcdf\",\n            \"application/vnd+zarr\",\n            \"application/x-hdf5\",\n            \"application/x-hdf\",\n        ]:\n            return XarrayReader, asset_info.get(\"reader_options\", {})\n\n        return Reader, asset_info.get(\"reader_options\", {})\n\n    def _parse_md_asset(self, asset: str) -&gt; Tuple[str, Optional[Dict]]:\n        \"\"\"Parse md:// asset string and return both asset name and reader options\"\"\"\n        if asset.startswith(\"md://\") and asset not in self.assets:\n            parsed = urlparse(asset)\n            if not parsed.netloc or parsed.netloc not in self.assets:\n                raise InvalidAssetName(\n                    f\"'{parsed.netloc}' is not valid, should be one of {self.assets}\"\n                )\n\n            # NOTE: by using `parse_qsl` we assume the\n            # reader_options are in form of `key=single_value`\n            # reader_options for XarrayReader are:\n            # - variable: str\n            # - group: Optional[str]\n            # - decode_times: bool = True\n            # - datetime: Optional[str]\n            # - drop_dim: Optional[str]\n            return parsed.netloc, dict(parse_qsl(parsed.query))\n\n        return asset, None\n\n    def _get_asset_info(self, asset: str) -&gt; AssetInfo:\n        \"\"\"Validate asset names and return asset's info.\n\n        Args:\n            asset (str): STAC asset name.\n\n        Returns:\n            AssetInfo: STAC asset info.\n\n        \"\"\"\n        vrt_options = None\n        reader_options = None\n        if asset.startswith(\"vrt://\"):\n            asset, vrt_options = self._parse_vrt_asset(asset)\n\n        # not part of the original STACReader\n        elif asset.startswith(\"md://\"):\n            asset, reader_options = self._parse_md_asset(asset)\n\n        if asset not in self.assets:\n            raise InvalidAssetName(\n                f\"'{asset}' is not valid, should be one of {self.assets}\"\n            )\n\n        asset_info = self.item.assets[asset]\n        extras = asset_info.extra_fields\n\n        info = AssetInfo(\n            url=asset_info.get_absolute_href() or asset_info.href,\n            metadata=extras if not vrt_options else None,\n            reader_options=reader_options or {}\n        )\n\n        if stac.STAC_ALTERNATE_KEY and extras.get(\"alternate\"):\n            if alternate := extras[\"alternate\"].get(stac.STAC_ALTERNATE_KEY):\n                info[\"url\"] = alternate[\"href\"]\n\n        if asset_info.media_type:\n            info[\"media_type\"] = asset_info.media_type\n\n        # https://github.com/stac-extensions/file\n        if head := extras.get(\"file:header_size\"):\n            info[\"env\"] = {\"GDAL_INGESTED_BYTES_AT_OPEN\": head}\n\n        # https://github.com/stac-extensions/raster\n        if extras.get(\"raster:bands\") and not vrt_options:\n            bands = extras.get(\"raster:bands\")\n            stats = [\n                (b[\"statistics\"][\"minimum\"], b[\"statistics\"][\"maximum\"])\n                for b in bands\n                if {\"minimum\", \"maximum\"}.issubset(b.get(\"statistics\", {}))\n            ]\n            # check that stats data are all double and make warning if not\n            if (\n                stats\n                and all(isinstance(v, (int, float)) for stat in stats for v in stat)\n                and len(stats) == len(bands)\n            ):\n                info[\"dataset_statistics\"] = stats\n            else:\n                warnings.warn(\n                    \"Some statistics data in STAC are invalid, they will be ignored.\"\n                )\n\n        if vrt_options:\n            info[\"url\"] = f\"vrt://{info['url']}?{vrt_options}\"\n\n        return info\n</code></pre>"},{"location":"examples/code/tiler_with_custom_stac%2Bxarray/#2-endpoint-factory","title":"2. Endpoint Factory","text":"<p>Custom <code>MultiBaseTilerFactory</code> which removes some endpoints (<code>/preview</code>) and adapt dependencies to work with both COG and Xarray Datasets.</p> factory.py<pre><code>\"\"\"Custom MultiBaseTilerFactory.\"\"\"\nfrom dataclasses import dataclass\nfrom typing import Type, Union, Optional, List\nfrom typing_extensions import Annotated\nfrom attrs import define, field\nfrom geojson_pydantic.features import Feature, FeatureCollection\nfrom fastapi import Body, Depends, Query\nfrom titiler.core import factory\nfrom titiler.core.dependencies import (\n    DefaultDependency,\n    BidxParams,\n    AssetsParams,\n    AssetsBidxExprParamsOptional,\n    CoordCRSParams,\n    DstCRSParams,\n)\nfrom titiler.core.models.responses import MultiBaseStatisticsGeoJSON\nfrom titiler.core.resources.responses import GeoJSONResponse\nfrom rio_tiler.constants import WGS84_CRS\nfrom rio_tiler.io import MultiBaseReader\n\nfrom stac import STACReader\n\n\n# Simple Asset dependency (1 asset, no expression)\n@dataclass\nclass SingleAssetsParams(DefaultDependency):\n    \"\"\"Custom Assets parameters which only accept ONE asset and make it required.\"\"\"\n\n    assets: Annotated[\n        str,\n        Query(title=\"Asset names\", description=\"Asset's name.\"),\n    ]\n\n    indexes: Annotated[\n        Optional[List[int]],\n        Query(\n            title=\"Band indexes\",\n            alias=\"bidx\",\n            description=\"Dataset band indexes\",\n            openapi_examples={\n                \"user-provided\": {\"value\": None},\n                \"one-band\": {\"value\": [1]},\n                \"multi-bands\": {\"value\": [1, 2, 3]},\n            },\n        ),\n    ] = None\n\n\n@define(kw_only=True)\nclass MultiBaseTilerFactory(factory.MultiBaseTilerFactory):\n\n    reader: Type[MultiBaseReader] = STACReader\n\n    # Assets/Indexes/Expression dependency\n    layer_dependency: Type[DefaultDependency] = SingleAssetsParams\n\n    # Assets dependency (for /info endpoints)\n    assets_dependency: Type[DefaultDependency] = AssetsParams\n\n    # remove preview endpoints\n    img_preview_dependency: Type[DefaultDependency] = field(init=False)\n    add_preview: bool = field(init=False, default=False)\n\n    # Overwrite the `/statistics` endpoint to remove `full` dataset statistics (which could be unusable for NetCDF dataset)\n    def statistics(self):  # noqa: C901\n        \"\"\"Register /statistics endpoint.\"\"\"\n\n        @self.router.post(\n            \"/statistics\",\n            response_model=MultiBaseStatisticsGeoJSON,\n            response_model_exclude_none=True,\n            response_class=GeoJSONResponse,\n            responses={\n                200: {\n                    \"content\": {\"application/geo+json\": {}},\n                    \"description\": \"Return dataset's statistics from feature or featureCollection.\",\n                }\n            },\n        )\n        def geojson_statistics(\n            geojson: Annotated[\n                Union[FeatureCollection, Feature],\n                Body(description=\"GeoJSON Feature or FeatureCollection.\"),\n            ],\n            src_path=Depends(self.path_dependency),\n            reader_params=Depends(self.reader_dependency),\n            layer_params=Depends(AssetsBidxExprParamsOptional),\n            dataset_params=Depends(self.dataset_dependency),\n            coord_crs=Depends(CoordCRSParams),\n            dst_crs=Depends(DstCRSParams),\n            post_process=Depends(self.process_dependency),\n            image_params=Depends(self.img_part_dependency),\n            stats_params=Depends(self.stats_dependency),\n            histogram_params=Depends(self.histogram_dependency),\n            env=Depends(self.environment_dependency),\n        ):\n            \"\"\"Get Statistics from a geojson feature or featureCollection.\"\"\"\n            fc = geojson\n            if isinstance(fc, Feature):\n                fc = FeatureCollection(type=\"FeatureCollection\", features=[geojson])\n\n            with rasterio.Env(**env):\n                with self.reader(src_path, **reader_params.as_dict()) as src_dst:\n                    # Default to all available assets\n                    if not layer_params.assets and not layer_params.expression:\n                        layer_params.assets = src_dst.assets\n\n                    for feature in fc:\n                        image = src_dst.feature(\n                            feature.model_dump(exclude_none=True),\n                            shape_crs=coord_crs or WGS84_CRS,\n                            dst_crs=dst_crs,\n                            align_bounds_with_dataset=True,\n                            **layer_params.as_dict(),\n                            **image_params.as_dict(),\n                            **dataset_params.as_dict(),\n                        )\n\n                        if post_process:\n                            image = post_process(image)\n\n                        stats = image.statistics(\n                            **stats_params.as_dict(),\n                            hist_options=histogram_params.as_dict(),\n                        )\n\n                    feature.properties = feature.properties or {}\n                    # NOTE: because we use `src_dst.feature` the statistics will be in form of\n                    # `Dict[str, BandStatistics]` and not `Dict[str, Dict[str, BandStatistics]]`\n                    feature.properties.update({\"statistics\": stats})\n\n            return fc.features[0] if isinstance(geojson, Feature) else fc\n</code></pre>"},{"location":"examples/code/tiler_with_custom_stac%2Bxarray/#3-application","title":"3. Application","text":"main.py<pre><code>\"\"\"FastAPI application.\"\"\"\n\nfrom fastapi import FastAPI\n\nfrom titiler.core.dependencies import DatasetPathParams\nfrom titiler.core.errors import DEFAULT_STATUS_CODES, add_exception_handlers\n\nfrom factory import MultiBaseTilerFactory\n\n# STAC uses MultiBaseReader so we use MultiBaseTilerFactory to built the default endpoints\nstac = MultiBaseTilerFactory(router_prefix=\"stac\")\n\n# Create FastAPI application\napp = FastAPI()\napp.include_router(stac.router, tags=[\"STAC\"])\nadd_exception_handlers(app, DEFAULT_STATUS_CODES)\n</code></pre> <pre><code>uvicorn app:app --port 8080 --reload\n</code></pre> <pre><code>curl http://127.0.0.1:8080/assets\\?url\\=https%3A%2F%2Fraw.githubusercontent.com%2Fcogeotiff%2Frio-tiler%2Frefs%2Fheads%2Fmain%2Ftests%2Ffixtures%2Fstac_netcdf.json | jq\n\n[\n  \"geotiff\",\n  \"netcdf\"\n]\n</code></pre> <pre><code>curl http://127.0.0.1:8080/info?url=https://raw.githubusercontent.com/cogeotiff/rio-tiler/refs/heads/main/tests/fixtures/stac_netcdf.json&amp;assets=md://netcdf?variable=dataset  | jq\n{\n  \"md://netcdf?variable=dataset\": {\n    \"bounds\": [\n      -170.085,\n      -80.08,\n      169.914999999975,\n      79.91999999999659\n    ],\n    \"crs\": \"http://www.opengis.net/def/crs/EPSG/0/4326\",\n    \"band_metadata\": [\n      [\n        \"b1\",\n        {}\n      ]\n    ],\n    \"band_descriptions\": [\n      [\n        \"b1\",\n        \"value\"\n      ]\n    ],\n    \"dtype\": \"float64\",\n    \"nodata_type\": \"Nodata\",\n    \"name\": \"dataset\",\n    \"count\": 1,\n    \"width\": 2000,\n    \"height\": 1000,\n    \"attrs\": {\n      \"valid_min\": 1.0,\n      \"valid_max\": 1000.0,\n      \"fill_value\": 0\n    }\n  }\n}\n</code></pre> <pre><code>curl http://127.0.0.1:8080/tiles/WebMercatorQuad/1/0/0?url=https://raw.githubusercontent.com/cogeotiff/rio-tiler/refs/heads/main/tests/fixtures/stac_netcdf.json&amp;assets=md://netcdf?variable=dataset&amp;rescale=0,1000\n</code></pre>"},{"location":"examples/code/tiler_with_custom_stac_validation/","title":"STAC endpoints with custom `/validate`","text":"<p>Goal: Create a custom STAC endpoints with validation</p> <p>requirements: <code>titiler.core</code> &amp;&amp; <code>jsonschema</code></p> <pre><code>\"\"\"FastAPI application.\"\"\"\n\nfrom fastapi import FastAPI\n\nfrom rio_tiler.io import STACReader\n\nfrom titiler.core.dependencies import DatasetPathParams\nfrom titiler.core.factory import MultiBaseTilerFactory\nfrom titiler.core.errors import DEFAULT_STATUS_CODES, add_exception_handlers\n\n\n# STAC uses MultiBaseReader so we use MultiBaseTilerFactory to built the default endpoints\nstac = MultiBaseTilerFactory(reader=STACReader, router_prefix=\"stac\")\n\n\n# We add `/validate` to the router\n@stac.router.get(\"/validate\")\ndef stac_validate_get(src_path=Depends(DatasetPathParams)):\n    \"\"\"STAC validation.\"\"\"\n    with STACReader(src_path) as stac_src:\n       return stac_src.item.validate()\n\n\n# Create FastAPI application\napp = FastAPI(title=\"My simple app with custom STAC endpoint\")\napp.include_router(stac.router, tags=[\"STAC\"])\nadd_exception_handlers(app, DEFAULT_STATUS_CODES)\n</code></pre>"},{"location":"examples/code/tiler_with_custom_tms/","title":"Tiler with custom TMS","text":"<p>Goal: add custom TMS to a tiler</p> <p>requirements: titiler.core</p> <p>1 - Create custom TMS and custom endpoints</p> <pre><code>\"\"\"routes.\n\napp/routes.py\n\n\"\"\"\n\nfrom titiler.core.factory import TilerFactory, TMSFactory\nfrom morecantile import tms, TileMatrixSet\nfrom pyproj import CRS\n\n# 1. Create Custom TMS\nEPSG6933 = TileMatrixSet.custom(\n    (-17357881.81713629, -7324184.56362408, 17357881.81713629, 7324184.56362408),\n    CRS.from_epsg(6933),\n    id=\"EPSG6933\",\n    matrix_scale=[1, 1],\n)\n# 2. Register TMS\ntms = tms.register({EPSG6933.id:EPSG6933})\n\ntms_factory = TMSFactory(supported_tms=tms)\ncog_factory = TilerFactory(supported_tms=tms)\n</code></pre> <p>2 - Create app and register our custom endpoints</p> <pre><code>\"\"\"app.\n\napp/main.py\n\n\"\"\"\n\nfrom titiler.core.errors import DEFAULT_STATUS_CODES, add_exception_handlers\n\nfrom fastapi import FastAPI\n\nfrom .routes import cog_factory, tms_factory\n\napp = FastAPI(title=\"My simple app with custom TMS\")\n\napp.include_router(cog_factory.router, tags=[\"Cloud Optimized GeoTIFF\"])\napp.include_router(tms_factory.router, tags=[\"Tiling Schemes\"])\nadd_exception_handlers(app, DEFAULT_STATUS_CODES)\n</code></pre>"},{"location":"examples/code/tiler_with_layers/","title":"Custom Layers","text":"<p>Goal: Create a Custom TiTiler with a limited set of supported <code>layers</code></p> <p>requirements: titiler.core</p> <p>How:</p> <p>The idea is to create a set of endpoints with a <code>/layers/{layer_id}</code> prefix and a set of configuration, e.g</p> <pre><code>config = {\n    \"layer_1\": {\n        \"url\": \"dataset_1 url\",\n        \"indexes\": [1],\n        \"render\": {\n            \"rescale\": [(0, 1000)],\n            \"colormap_name\": \"viridis\"\n        }\n    },\n    ...\n}\n</code></pre> <p>We then use custom set of endpoint dependencies to get the <code>layer</code> configuration and <code>inject</code> the parameters.</p> <pre><code>import json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, Literal, Annotated, Optional, Sequence\n\nfrom fastapi import FastAPI, Path, HTTPException, Query\nfrom rio_tiler.colormap import ColorMaps\nfrom rio_tiler.colormap import cmap as default_cmap\nfrom rio_tiler.colormap import parse_color\nfrom starlette.requests import Request\n\nfrom titiler.core import dependencies\nfrom titiler.core.errors import DEFAULT_STATUS_CODES, add_exception_handlers\nfrom titiler.core.factory import TilerFactory\n\n\n# Layers Configuration\navailable_layers = {\n    \"red\": {\n        \"url\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/21/J/XN/2021/2/S2B_21JXN_20210214_1_L2A/B04.tif\",\n        \"render\": {\n            \"rescale\": [\n                (0, 1000),\n            ],\n        },\n    },\n    \"green\": {\n        \"url\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/21/J/XN/2021/2/S2B_21JXN_20210214_1_L2A/B03.tif\",\n        \"render\": {\n            \"rescale\": [\n                (0, 1000),\n            ],\n        },\n    },\n    \"bleue\": {\n        \"url\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/21/J/XN/2021/2/S2B_21JXN_20210214_1_L2A/B02.tif\",\n        \"render\": {\n            \"rescale\": [\n                (0, 1000),\n            ],\n        },\n    },\n}\n\n# VRT of bands B04, B03, B02, and B05 files\n# gdalbuildvrt vrt.vrt /vsicurl/https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/21/J/XN/2021/2/S2B_21JXN_20210214_1_L2A/B{04,03,02,08}.tif -separate\n# cat vrt.vrt | tr -d '\\n' | tr -d ' '\nvrt_rdbnir = '&lt;VRTDataset rasterXSize=\"10980\" rasterYSize=\"10980\"&gt;  &lt;SRS dataAxisToSRSAxisMapping=\"1,2\"&gt;PROJCS[\"WGS 84 / UTM zone 21S\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-57],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",10000000],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],AUTHORITY[\"EPSG\",\"32721\"]]&lt;/SRS&gt;  &lt;GeoTransform&gt;  6.0000000000000000e+05,  1.0000000000000000e+01,  0.0000000000000000e+00,  7.3000000000000000e+06,  0.0000000000000000e+00, -1.0000000000000000e+01&lt;/GeoTransform&gt;  &lt;VRTRasterBand dataType=\"UInt16\" band=\"1\"&gt;    &lt;NoDataValue&gt;0&lt;/NoDataValue&gt;    &lt;ComplexSource&gt;      &lt;SourceFilename relativeToVRT=\"0\"&gt;/vsicurl/https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/21/J/XN/2021/2/S2B_21JXN_20210214_1_L2A/B04.tif&lt;/SourceFilename&gt;      &lt;SourceBand&gt;1&lt;/SourceBand&gt;      &lt;SourceProperties RasterXSize=\"10980\" RasterYSize=\"10980\" DataType=\"UInt16\" BlockXSize=\"1024\" BlockYSize=\"1024\" /&gt;      &lt;SrcRect xOff=\"0\" yOff=\"0\" xSize=\"10980\" ySize=\"10980\" /&gt;      &lt;DstRect xOff=\"0\" yOff=\"0\" xSize=\"10980\" ySize=\"10980\" /&gt;      &lt;NODATA&gt;0&lt;/NODATA&gt;    &lt;/ComplexSource&gt;  &lt;/VRTRasterBand&gt;  &lt;VRTRasterBand dataType=\"UInt16\" band=\"2\"&gt;    &lt;NoDataValue&gt;0&lt;/NoDataValue&gt;    &lt;ComplexSource&gt;      &lt;SourceFilename relativeToVRT=\"0\"&gt;/vsicurl/https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/21/J/XN/2021/2/S2B_21JXN_20210214_1_L2A/B03.tif&lt;/SourceFilename&gt;      &lt;SourceBand&gt;1&lt;/SourceBand&gt;      &lt;SourceProperties RasterXSize=\"10980\" RasterYSize=\"10980\" DataType=\"UInt16\" BlockXSize=\"1024\" BlockYSize=\"1024\" /&gt;      &lt;SrcRect xOff=\"0\" yOff=\"0\" xSize=\"10980\" ySize=\"10980\" /&gt;      &lt;DstRect xOff=\"0\" yOff=\"0\" xSize=\"10980\" ySize=\"10980\" /&gt;      &lt;NODATA&gt;0&lt;/NODATA&gt;    &lt;/ComplexSource&gt;  &lt;/VRTRasterBand&gt;  &lt;VRTRasterBand dataType=\"UInt16\" band=\"3\"&gt;    &lt;NoDataValue&gt;0&lt;/NoDataValue&gt;    &lt;ComplexSource&gt;      &lt;SourceFilename relativeToVRT=\"0\"&gt;/vsicurl/https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/21/J/XN/2021/2/S2B_21JXN_20210214_1_L2A/B02.tif&lt;/SourceFilename&gt;      &lt;SourceBand&gt;1&lt;/SourceBand&gt;      &lt;SourceProperties RasterXSize=\"10980\" RasterYSize=\"10980\" DataType=\"UInt16\" BlockXSize=\"1024\" BlockYSize=\"1024\" /&gt;      &lt;SrcRect xOff=\"0\" yOff=\"0\" xSize=\"10980\" ySize=\"10980\" /&gt;      &lt;DstRect xOff=\"0\" yOff=\"0\" xSize=\"10980\" ySize=\"10980\" /&gt;      &lt;NODATA&gt;0&lt;/NODATA&gt;    &lt;/ComplexSource&gt;  &lt;/VRTRasterBand&gt;  &lt;VRTRasterBand dataType=\"UInt16\" band=\"4\"&gt;    &lt;NoDataValue&gt;0&lt;/NoDataValue&gt;    &lt;ComplexSource&gt;      &lt;SourceFilename relativeToVRT=\"0\"&gt;/vsicurl/https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/21/J/XN/2021/2/S2B_21JXN_20210214_1_L2A/B08.tif&lt;/SourceFilename&gt;      &lt;SourceBand&gt;1&lt;/SourceBand&gt;      &lt;SourceProperties RasterXSize=\"10980\" RasterYSize=\"10980\" DataType=\"UInt16\" BlockXSize=\"1024\" BlockYSize=\"1024\" /&gt;      &lt;SrcRect xOff=\"0\" yOff=\"0\" xSize=\"10980\" ySize=\"10980\" /&gt;      &lt;DstRect xOff=\"0\" yOff=\"0\" xSize=\"10980\" ySize=\"10980\" /&gt;      &lt;NODATA&gt;0&lt;/NODATA&gt;    &lt;/ComplexSource&gt;  &lt;/VRTRasterBand&gt;&lt;/VRTDataset&gt;'\n\n# Mpre configs (using VRT)\navailable_layers.update(\n    {\n        \"true_color\": {\n            \"url\": vrt_rdbnir,\n            \"indexes\": [1, 2, 3],\n            \"render\": {\n                \"rescale\": [\n                    (0, 3000),\n                    (0, 3000),\n                    (0, 3000),\n                ],\n            },\n        },\n        \"false_color\": {\n            \"url\": vrt_rdbnir,\n            \"indexes\": [4, 1, 2],\n            \"render\": {\n                \"rescale\": [\n                    (0, 4000),\n                    (0, 3000),\n                    (0, 3000),\n                ],\n            },\n        },\n        \"ndvi\": {\n            \"url\": vrt_rdbnir,\n            \"expression\": \"(b4-b1)/(b4+b1)\",\n            \"render\": {\n                \"rescale\": [\n                    (-1, 1),\n                ],\n                \"colormap_name\": \"viridis\",\n            },\n        },\n    }\n)\n\n# List of all Layers\nlayers_list = Literal[\"red\", \"green\", \"blue\", \"true_color\", \"false_color\", \"ndvi\"]\n\n\n# Custom `DatasetPathParams` which return the dataset URL for a `layer_id`\ndef DatasetPathParams(layer_id: layers_list = Path()) -&gt; str:\n    return available_layers[layer_id][\"url\"]\n\n\n@dataclass\nclass CustomAsDict:\n    \"\"\"Custom `DefaultDependency` to ignore `requests`\"\"\"\n    def as_dict(self, exclude_none: bool = True) -&gt; Dict:\n        \"\"\"Transform dataclass to dict.\"\"\"\n        exclude_keys = {\"request\"}\n        if exclude_none:\n            return {\n                k: v\n                for k, v in self.__dict__.items()\n                if v is not None and k not in exclude_keys\n            }\n\n        return {k: v for k, v in self.__dict__.items() if k not in exclude_keys}\n\n\n# Custom Layer Param\n@dataclass\nclass LayerParams(CustomAsDict, dependencies.BidxExprParams):\n\n    request: Request = field(default=None)\n\n    def __post_init__(self):\n        if (layer := self.request.path_params.get(\"layer_id\")) and not any(\n            [self.indexes, self.expression]\n        ):\n            layer_params = available_layers[layer]\n            if indexes := layer_params.get(\"indexes\"):\n                self.indexes = indexes\n            elif expr := layer_params.get(\"expression\"):\n                self.expression = expr\n\n# Custom Rendering Params\n@dataclass\nclass RenderingParams(CustomAsDict, dependencies.ImageRenderingParams):\n\n    request: Request = field(default=None)\n\n    def __post_init__(self):\n        super().__post_init__()\n\n        if layer := self.request.path_params.get(\"layer_id\"):\n            layer_params = available_layers[layer].get(\"render\", {})\n\n            if not self.rescale and (rescale := layer_params.get(\"rescale\")):\n                self.rescale = rescale\n\n            if not self.color_formula and (color_formula := layer_params.get(\"color_formula\")):\n                self.color_formula = color_formula\n\n            if self.add_mask is not None and (add_mask := layer_params.get(\"add_mask\")):\n                self.add_mask = add_mask\n\n\n# Custom ColorMap Params\ndef ColorMapParams(\n    request: Request,\n    colormap_name: Annotated[  # type: ignore\n        Literal[tuple(default_cmap.list())],\n        Query(description=\"Colormap name\"),\n    ] = None,\n    colormap: Annotated[\n        Optional[str], Query(description=\"JSON encoded custom Colormap\")\n    ] = None,\n):\n    if layer := request.path_params.get(\"layer_id\"):\n        layer_params = available_layers[layer].get(\"render\", {})\n        colormap_name = layer_params.get(\"colormap_name\", colormap_name)\n        colormap = layer_params.get(\"colormap\", colormap)\n\n    if colormap_name:\n        return default_cmap.get(colormap_name)\n\n    if colormap:\n        try:\n            c = json.loads(\n                colormap,\n                object_hook=lambda x: {\n                    int(k): parse_color(v) for k, v in x.items()\n                },\n            )\n\n            # Make sure to match colormap type\n            if isinstance(c, Sequence):\n                c = [(tuple(inter), parse_color(v)) for (inter, v) in c]\n\n            return c\n        except json.JSONDecodeError as e:\n            raise HTTPException(\n                status_code=400, detail=\"Could not parse the colormap value.\"\n            ) from e\n\n    return None\n\n\napp = FastAPI()\n\ncog = TilerFactory(\n    path_dependency=DatasetPathParams,\n    layer_dependency=LayerParams,\n    render_dependency=RenderingParams,\n    colormap_dependency=ColorMapParams,\n    router_prefix=\"/layers/{layer_id}\",\n)\napp.include_router(cog.router, prefix=\"/layers/{layer_id}\")\nadd_exception_handlers(app, DEFAULT_STATUS_CODES)\n\n# Run the application\nimport uvicorn\nuvicorn.run(app=app, host=\"127.0.0.1\", port=8080, log_level=\"info\")\n</code></pre> <p><code>http://127.0.0.1:8080/docs</code></p> <p></p> <p><code>http://127.0.0.1:8080/layers/true_color/preview</code></p> <p></p>"},{"location":"examples/code/working_with_signed_urls/","title":"Loading data with signed URLs","text":"<p>ref: developmentseed/titiler?331</p> <p>Goal: allow users to pass signed url or url containing query parameters (delimited with <code>&amp;</code>)</p> <p>requirements: titiler.core</p>"},{"location":"examples/code/working_with_signed_urls/#what-why-how","title":"What / Why / How","text":"<p>Passing a signed URL or a complex URL for a dataset is not supported by default in TiTiler because the parameters (delimited with <code>&amp;</code>) from the signed url conflict with the query parameters from the application itself. In order to allow signed url in the application there are two solutions:</p>"},{"location":"examples/code/working_with_signed_urls/#1-url-encoding","title":"1. URL Encoding","text":""},{"location":"examples/code/working_with_signed_urls/#11-full-url","title":"1.1 Full URL","text":"<p>The easiest way (from the application's point of view) to allow complex URLs is to allow an encoded url as an input parameter.</p> <pre><code>import base64\nurl = \"http://my.dataset.com/cog.tif?p=aaa&amp;c&amp;1234&amp;t=4321\"\n\n# base64.b64encode(url.encode())\n&gt;&gt;&gt; \"aHR0cDovL215LmRhdGFzZXQuY29tL2NvZy50aWY/cD1hYWEmYyYxMjM0JnQ9NDMyMQ==\"\n</code></pre> <p>When base64 encoded, the url is just a regular string and thus will be valid in the application.</p> <pre><code>\"\"\"Minimal COG tiler with Signed URL support.\"\"\"\n\nimport base64\nfrom titiler.core.factory import TilerFactory\nfrom titiler.core.errors import DEFAULT_STATUS_CODES, add_exception_handlers\n\nfrom fastapi import FastAPI\n\n\n# Custom Path dependency which can `decode` a base64 url\ndef DatasetPathParams(\n    url: str = Query(..., description=\"Dataset URL\"),\n    base64_encoded: bool = Query(None)\n) -&gt; str:\n    \"\"\"Create dataset path from args\"\"\"\n    if base64_encoded:\n        url = base64.b64decode(url).decode()\n    return url\n\napp = FastAPI(title=\"My simple app\")\n\ncog = TilerFactory(path_dependency=DatasetPathParams)\napp.include_router(cog.router, tags=[\"Cloud Optimized GeoTIFF\"])\n\nadd_exception_handlers(app, DEFAULT_STATUS_CODES)\n\n\n@app.get(\"/healthz\", description=\"Health Check\", tags=[\"Health Check\"])\ndef ping():\n    \"\"\"Health check.\"\"\"\n    return {\"ping\": \"pong!\"}\n</code></pre> <pre><code>import base64\nfrom my_provider import signed_url\n\nmy_url = \"https://dataset.com/....\"\n\n# Get signed URL\nmy_signed_url = signed_url(my_url)\n\n# Encode the signed url using base64\nurl = base64.b64encode(my_signed_url.encode())\n\ninfo = request.get(f\"{titiler_endpoint}/info\", params={\"url\": url, signed_url: True})\n</code></pre>"},{"location":"examples/code/working_with_signed_urls/#12-encode-only-the-url-params","title":"1.2 Encode only the url params","text":"<pre><code>\"\"\"Minimal COG tiler with Signed URL support.\"\"\"\n\nimport base64\nfrom titiler.core.factory import TilerFactory\nfrom titiler.core.errors import DEFAULT_STATUS_CODES, add_exception_handlers\n\nfrom fastapi import FastAPI\n\n\n# Another solution is to pass only the query parameters encoded in base64\ndef DatasetPathParams(\n    url: str = Query(..., description=\"Dataset URL\"),\n    url_params: str = Query(\n        None, description=\"Base64 encoded Query parameters to add to the dataset URL.\"\n    ),\n) -&gt; str:\n    \"\"\"DatasetPath Params.\"\"\"\n    if url_params:\n        url += f\"?{b64decode(url_params).decode()}\"\n    return url\n\n\napp = FastAPI(title=\"My simple app\")\n\ncog = TilerFactory(path_dependency=DatasetPathParams)\napp.include_router(cog.router, tags=[\"Cloud Optimized GeoTIFF\"])\n\nadd_exception_handlers(app, DEFAULT_STATUS_CODES)\n\n\n@app.get(\"/healthz\", description=\"Health Check\", tags=[\"Health Check\"])\ndef ping():\n    \"\"\"Health check.\"\"\"\n    return {\"ping\": \"pong!\"}\n</code></pre> <pre><code>import base64\nfrom urllib.parse import urlparse\nfrom my_provider import signed_url\n\nmy_url = \"https://dataset.com/....\"\n\n# Get signed URL\nmy_signed_url = signed_url(my_url)\n\n# Extract the url parameters\nsigned_params = urlparse(my_signed_url).query\n\n# Encode the parameters using base64\nencoded_params = base64.b64encode(signed_params.encode())\n\ninfo = request.get(f\"{titiler_endpoint}/info\", params={\"url\": url, url_params: encoded_params})\n</code></pre>"},{"location":"examples/code/working_with_signed_urls/#2-signing-url-in-the-application","title":"2. Signing URL in the application","text":"<p>Another solution is to sign the URL directly in TiTiler.</p> <pre><code>\"\"\"Minimal COG tiler with Signed URL support.\"\"\"\n\nimport my_provider  # e.g AWS, Google, ...\n\nfrom titiler.core.factory import TilerFactory\nfrom titiler.core.errors import DEFAULT_STATUS_CODES, add_exception_handlers\n\nfrom fastapi import FastAPI\n\n\n# Custom Path dependency which will sign url\n# !!! You may want to add caching here to avoid to many call to the signing provider !!!\ndef DatasetPathParams(\n    url: str = Query(..., description=\"Dataset URL\"),\n) -&gt; str:\n    \"\"\"Create dataset path from args\"\"\"\n    # Use your provider library to sign the URL\n    return my_provider.sign(url)\n\n\napp = FastAPI(title=\"My simple app\")\n\ncog = TilerFactory(path_dependency=DatasetPathParams)\napp.include_router(cog.router, tags=[\"Cloud Optimized GeoTIFF\"])\n\nadd_exception_handlers(app, DEFAULT_STATUS_CODES)\n\n\n@app.get(\"/healthz\", description=\"Health Check\", tags=[\"Health Check\"])\ndef ping():\n    \"\"\"Health check.\"\"\"\n    return {\"ping\": \"pong!\"}\n</code></pre> <pre><code>import base64\nfrom my_provider import signed_url\n\nmy_url = \"https://dataset.com/....\"\n\ninfo = request.get(f\"{titiler_endpoint}/info\", params={\"url\": my_url})\n</code></pre>"},{"location":"examples/notebooks/Working_with_Algorithm/","title":"Working With Algorithms","text":"In\u00a0[\u00a0]: Copied! <pre>import json\nimport httpx\n\nfrom folium import Map, TileLayer\n</pre> import json import httpx  from folium import Map, TileLayer In\u00a0[\u00a0]: Copied! <pre>titiler_endpoint = (\n    \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind.\n)\n</pre> titiler_endpoint = (     \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind. ) In\u00a0[\u00a0]: Copied! <pre>url = \"https://data.geo.admin.ch/ch.swisstopo.swissalti3d/swissalti3d_2019_2573-1085/swissalti3d_2019_2573-1085_0.5_2056_5728.tif\"\n</pre> url = \"https://data.geo.admin.ch/ch.swisstopo.swissalti3d/swissalti3d_2019_2573-1085/swissalti3d_2019_2573-1085_0.5_2056_5728.tif\" In\u00a0[\u00a0]: Copied! <pre># Fetch dataset Metadata\nr = httpx.get(\n    f\"{titiler_endpoint}/cog/info\",\n    params={\n        \"url\": url,\n    },\n).json()\n\nprint(r)\n</pre> # Fetch dataset Metadata r = httpx.get(     f\"{titiler_endpoint}/cog/info\",     params={         \"url\": url,     }, ).json()  print(r) In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",\n    params={\n        \"url\": url,\n    },\n).json()\n\nbounds = r[\"bounds\"]\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),\n    zoom_start=r[\"minzoom\"],\n)\n\nTileLayer(\n    tiles=r[\"tiles\"][0], opacity=1, attr=\"Office f\u00e9d\u00e9ral de topographie swisstopo\"\n).add_to(m)\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",     params={         \"url\": url,     }, ).json()  bounds = r[\"bounds\"] m = Map(     location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),     zoom_start=r[\"minzoom\"], )  TileLayer(     tiles=r[\"tiles\"][0], opacity=1, attr=\"Office f\u00e9d\u00e9ral de topographie swisstopo\" ).add_to(m) m In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",\n    params={\n        \"url\": url,\n        # rio-tiler cannot rescale automatically the data when using a colormap\n        \"rescale\": \"1615.812,2015.09448\",\n        \"colormap_name\": \"terrain\",\n    },\n).json()\n\nbounds = r[\"bounds\"]\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),\n    zoom_start=r[\"minzoom\"],\n)\n\naod_layer = TileLayer(\n    tiles=r[\"tiles\"][0], opacity=1, attr=\"Office f\u00e9d\u00e9ral de topographie swisstopo\"\n)\naod_layer.add_to(m)\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",     params={         \"url\": url,         # rio-tiler cannot rescale automatically the data when using a colormap         \"rescale\": \"1615.812,2015.09448\",         \"colormap_name\": \"terrain\",     }, ).json()  bounds = r[\"bounds\"] m = Map(     location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),     zoom_start=r[\"minzoom\"], )  aod_layer = TileLayer(     tiles=r[\"tiles\"][0], opacity=1, attr=\"Office f\u00e9d\u00e9ral de topographie swisstopo\" ) aod_layer.add_to(m) m In\u00a0[\u00a0]: Copied! <pre># Fetch algorithms\nprint(\"Available algorithm\")\nprint(list(httpx.get(f\"{titiler_endpoint}/algorithms\").json()))\nprint()\nprint(\"Metadata from `Hillshade` algorithm\")\nmeta = httpx.get(f\"{titiler_endpoint}/algorithms/hillshade\").json()\nprint(\"Inputs\")\nprint(meta[\"inputs\"])\nprint(\"Outputs\")\nprint(meta[\"outputs\"])\nprint(\"Parameters\")\nprint(meta[\"parameters\"])\n</pre> # Fetch algorithms print(\"Available algorithm\") print(list(httpx.get(f\"{titiler_endpoint}/algorithms\").json())) print() print(\"Metadata from `Hillshade` algorithm\") meta = httpx.get(f\"{titiler_endpoint}/algorithms/hillshade\").json() print(\"Inputs\") print(meta[\"inputs\"]) print(\"Outputs\") print(meta[\"outputs\"]) print(\"Parameters\") print(meta[\"parameters\"]) In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",\n    params={\n        \"url\": url,\n        \"algorithm\": \"hillshade\",\n        # Hillshade algorithm use a 3pixel buffer so we need\n        # to tell the tiler to apply a 3 pixel buffer around each tile\n        \"buffer\": 3,\n    },\n).json()\n\nbounds = r[\"bounds\"]\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),\n    zoom_start=r[\"minzoom\"],\n)\n\naod_layer = TileLayer(tiles=r[\"tiles\"][0], opacity=1, attr=\"Yo!!\")\naod_layer.add_to(m)\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",     params={         \"url\": url,         \"algorithm\": \"hillshade\",         # Hillshade algorithm use a 3pixel buffer so we need         # to tell the tiler to apply a 3 pixel buffer around each tile         \"buffer\": 3,     }, ).json()  bounds = r[\"bounds\"] m = Map(     location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),     zoom_start=r[\"minzoom\"], )  aod_layer = TileLayer(tiles=r[\"tiles\"][0], opacity=1, attr=\"Yo!!\") aod_layer.add_to(m) m In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",\n    params={\n        \"url\": url,\n        \"algorithm\": \"contours\",\n        \"algorithm_params\": json.dumps(\n            {\n                \"increment\": 20,  # contour line every 20 meters\n                \"thickness\": 2,  # 2m thickness\n                \"minz\": 1600,\n                \"maxz\": 2000,\n            }\n        ),\n    },\n).json()\n\nbounds = r[\"bounds\"]\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),\n    zoom_start=r[\"minzoom\"],\n)\n\nTileLayer(tiles=r[\"tiles\"][0], opacity=1, attr=\"Yo!!\").add_to(m)\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",     params={         \"url\": url,         \"algorithm\": \"contours\",         \"algorithm_params\": json.dumps(             {                 \"increment\": 20,  # contour line every 20 meters                 \"thickness\": 2,  # 2m thickness                 \"minz\": 1600,                 \"maxz\": 2000,             }         ),     }, ).json()  bounds = r[\"bounds\"] m = Map(     location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),     zoom_start=r[\"minzoom\"], )  TileLayer(tiles=r[\"tiles\"][0], opacity=1, attr=\"Yo!!\").add_to(m) m In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",\n    params={\n        \"url\": url,\n        \"algorithm\": \"contours\",\n        \"algorithm_params\": json.dumps(\n            {\n                \"increment\": 5,  # contour line every 5 meters\n                \"thickness\": 1,  # 1m thickness\n                \"minz\": 1600,\n                \"maxz\": 2000,\n            }\n        ),\n    },\n).json()\n\nbounds = r[\"bounds\"]\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),\n    zoom_start=r[\"minzoom\"],\n)\n\nTileLayer(tiles=r[\"tiles\"][0], opacity=1, attr=\"Yo!!\").add_to(m)\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",     params={         \"url\": url,         \"algorithm\": \"contours\",         \"algorithm_params\": json.dumps(             {                 \"increment\": 5,  # contour line every 5 meters                 \"thickness\": 1,  # 1m thickness                 \"minz\": 1600,                 \"maxz\": 2000,             }         ),     }, ).json()  bounds = r[\"bounds\"] m = Map(     location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),     zoom_start=r[\"minzoom\"], )  TileLayer(tiles=r[\"tiles\"][0], opacity=1, attr=\"Yo!!\").add_to(m) m In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/notebooks/Working_with_Algorithm/#working-with-algorithms","title":"Working With Algorithms\u00b6","text":"<p>For this demo we will use some elevation data from https://www.swisstopo.admin.ch/fr/geodata/height/alti3d.html  dataset</p>"},{"location":"examples/notebooks/Working_with_Algorithm/#requirements","title":"Requirements\u00b6","text":"<ul> <li>folium</li> <li>httpx</li> </ul> <p><code>!pip install folium httpx</code></p>"},{"location":"examples/notebooks/Working_with_Algorithm/#get-cog-info","title":"Get COG Info\u00b6","text":""},{"location":"examples/notebooks/Working_with_Algorithm/#display-tiles","title":"Display Tiles\u00b6","text":"<p>By default, the tiles will be rescaled from min/max from dataset statistics (1615.812 / 2015.09448)</p>"},{"location":"examples/notebooks/Working_with_Algorithm/#show-available-algorithms","title":"Show Available Algorithms\u00b6","text":""},{"location":"examples/notebooks/Working_with_Algorithm/#display-hillshade-tiles","title":"Display Hillshade Tiles\u00b6","text":""},{"location":"examples/notebooks/Working_with_Algorithm/#pass-parameters-to-the-algorithm","title":"Pass parameters to the algorithm\u00b6","text":""},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF/","title":"Working With COG - At Scale","text":"In\u00a0[\u00a0]: Copied! <pre># Uncomment this line if you need to install the dependencies\n# !pip install rasterio boto3 folium requests tqdm\n</pre> # Uncomment this line if you need to install the dependencies # !pip install rasterio boto3 folium requests tqdm In\u00a0[\u00a0]: Copied! <pre>import os\nimport datetime\nimport json\nimport urllib.parse\nfrom io import BytesIO\nfrom functools import partial\nfrom concurrent import futures\n\nimport httpx\nimport numpy\nfrom boto3.session import Session as boto3_session\n\nfrom rasterio.plot import reshape_as_image\nfrom rasterio.features import bounds as featureBounds\n\nfrom tqdm.notebook import tqdm\n\nfrom folium import Map, TileLayer, GeoJson\n\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\n</pre> import os import datetime import json import urllib.parse from io import BytesIO from functools import partial from concurrent import futures  import httpx import numpy from boto3.session import Session as boto3_session  from rasterio.plot import reshape_as_image from rasterio.features import bounds as featureBounds  from tqdm.notebook import tqdm  from folium import Map, TileLayer, GeoJson  import matplotlib.pyplot as plt import matplotlib.dates as mdates In\u00a0[\u00a0]: Copied! <pre>titiler_endpoint = (\n    \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind.\n)\n</pre> titiler_endpoint = (     \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind. ) In\u00a0[\u00a0]: Copied! <pre># use geojson.io\ngeojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"properties\": {},\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                    [\n                        [-74.1796875, 45.18978009667531],\n                        [-73.092041015625, 45.18978009667531],\n                        [-73.092041015625, 46.00459325574482],\n                        [-74.1796875, 46.00459325574482],\n                        [-74.1796875, 45.18978009667531],\n                    ]\n                ],\n            },\n        }\n    ],\n}\n\nbounds = featureBounds(geojson)\n</pre> # use geojson.io geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"properties\": {},             \"geometry\": {                 \"type\": \"Polygon\",                 \"coordinates\": [                     [                         [-74.1796875, 45.18978009667531],                         [-73.092041015625, 45.18978009667531],                         [-73.092041015625, 46.00459325574482],                         [-74.1796875, 46.00459325574482],                         [-74.1796875, 45.18978009667531],                     ]                 ],             },         }     ], }  bounds = featureBounds(geojson) In\u00a0[\u00a0]: Copied! <pre>m = Map(\n    tiles=\"OpenStreetMap\",\n    location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),\n    zoom_start=6,\n)\n\nGeoJson(geojson).add_to(m)\nm\n</pre> m = Map(     tiles=\"OpenStreetMap\",     location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),     zoom_start=6, )  GeoJson(geojson).add_to(m) m In\u00a0[\u00a0]: Copied! <pre># To Be able to run this notebook you'll need to have AWS credential available in the environment\n\n# import os\n# os.environ[\"AWS_ACCESS_KEY_ID\"] = \"YOUR AWS ACCESS ID HERE\"\n# os.environ[\"AWS_SECRET_ACCESS_KEY\"] = \"YOUR AWS ACCESS KEY HERE\"\n</pre> # To Be able to run this notebook you'll need to have AWS credential available in the environment  # import os # os.environ[\"AWS_ACCESS_KEY_ID\"] = \"YOUR AWS ACCESS ID HERE\" # os.environ[\"AWS_SECRET_ACCESS_KEY\"] = \"YOUR AWS ACCESS KEY HERE\" In\u00a0[\u00a0]: Copied! <pre>session = boto3_session(region_name=\"us-west-2\")\nclient = session.client(\"s3\")\n\nbucket = \"omi-no2-nasa\"  # https://registry.opendata.aws/omi-no2-nasa/\n\n\ndef list_objects(bucket, prefix):\n    \"\"\"AWS s3 list objects.\"\"\"\n\n    paginator = client.get_paginator(\"list_objects_v2\")\n\n    files = []\n    for subset in paginator.paginate(Bucket=bucket, Prefix=prefix):\n        files.extend(subset.get(\"Contents\", []))\n\n    return files\n\n\nlist_files = list_objects(bucket, \"OMI-Aura_L3\")\n\nprint(\"Archive Size\")\nfiles = [r[\"Key\"] for r in list_files]\nprint(f\"Found {len(files)} OMI-NO2 files\")\n\nsize = sum([r[\"Size\"] / 1000000.0 for r in list_files])\nprint(f\"Size of the archive: {size} Mo ({size / 1000} Go)\")\n</pre> session = boto3_session(region_name=\"us-west-2\") client = session.client(\"s3\")  bucket = \"omi-no2-nasa\"  # https://registry.opendata.aws/omi-no2-nasa/   def list_objects(bucket, prefix):     \"\"\"AWS s3 list objects.\"\"\"      paginator = client.get_paginator(\"list_objects_v2\")      files = []     for subset in paginator.paginate(Bucket=bucket, Prefix=prefix):         files.extend(subset.get(\"Contents\", []))      return files   list_files = list_objects(bucket, \"OMI-Aura_L3\")  print(\"Archive Size\") files = [r[\"Key\"] for r in list_files] print(f\"Found {len(files)} OMI-NO2 files\")  size = sum([r[\"Size\"] / 1000000.0 for r in list_files]) print(f\"Size of the archive: {size} Mo ({size / 1000} Go)\") In\u00a0[\u00a0]: Copied! <pre>print(files[0:10])\n</pre> print(files[0:10]) <p>file name structure is <code>\"OMI-Aura_L3-OMNO2d_{YEAR}m{MONTH:02}{DAY:02}...\"</code></p> <p>We can then easily filter e.g</p> In\u00a0[\u00a0]: Copied! <pre>files_2019 = list(filter(lambda x: x.split(\"_\")[2][0:4] == \"2019\", files))\nprint(len(files_2019))\n</pre> files_2019 = list(filter(lambda x: x.split(\"_\")[2][0:4] == \"2019\", files)) print(len(files_2019)) In\u00a0[\u00a0]: Copied! <pre>files_Oct5 = list(\n    filter(\n        lambda x: (x.split(\"_\")[2][5:7] == \"10\") &amp; (x.split(\"_\")[2][7:9] == \"05\"), files\n    )\n)\nprint(len(files_Oct5))\nprint(files_Oct5)\n</pre> files_Oct5 = list(     filter(         lambda x: (x.split(\"_\")[2][5:7] == \"10\") &amp; (x.split(\"_\")[2][7:9] == \"05\"), files     ) ) print(len(files_Oct5)) print(files_Oct5) In\u00a0[\u00a0]: Copied! <pre>def _url(src_path):\n    return f\"s3://omi-no2-nasa/{src_path}\"\n</pre> def _url(src_path):     return f\"s3://omi-no2-nasa/{src_path}\" In\u00a0[\u00a0]: Copied! <pre># Fetch File Metadata to get min/max rescaling values (because the file is stored as float32)\n\nr = httpx.get(\n    f\"{titiler_endpoint}/cog/statistics\", params={\"url\": _url(files[0])}\n).json()\n\nprint(json.dumps(r, indent=4))\n</pre> # Fetch File Metadata to get min/max rescaling values (because the file is stored as float32)  r = httpx.get(     f\"{titiler_endpoint}/cog/statistics\", params={\"url\": _url(files[0])} ).json()  print(json.dumps(r, indent=4)) In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",\n    params={\n        \"url\": _url(files[2]),\n        \"rescale\": \"0,3000000000000000\",\n        \"colormap_name\": \"viridis\",\n    },\n).json()\n\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2), zoom_start=6\n)\n\nTileLayer(tiles=r[\"tiles\"][0], opacity=1, attr=\"NASA\").add_to(m)\n\nGeoJson(geojson, style_function=lambda feature: {\"fill\": False, \"color\": \"red\"}).add_to(\n    m\n)\n\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",     params={         \"url\": _url(files[2]),         \"rescale\": \"0,3000000000000000\",         \"colormap_name\": \"viridis\",     }, ).json()  m = Map(     location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2), zoom_start=6 )  TileLayer(tiles=r[\"tiles\"][0], opacity=1, attr=\"NASA\").add_to(m)  GeoJson(geojson, style_function=lambda feature: {\"fill\": False, \"color\": \"red\"}).add_to(     m )  m In\u00a0[\u00a0]: Copied! <pre>def _stats(data, mask):\n    arr = numpy.ma.array(data)\n    arr.mask = mask == 0\n    return arr.min().item(), arr.max().item(), arr.mean().item(), arr.std().item()\n\n\nxmin, ymin, xmax, ymax = bounds\n\n\ndef fetch_bbox(file):\n    url = f\"{titiler_endpoint}/cog/bbox/{xmin},{ymin},{xmax},{ymax}.npy\"\n    params = {\n        \"url\": _url(file),\n        \"bidx\": \"1\",\n        \"max_size\": 128,\n    }\n    r = httpx.get(url, params=params)\n    data = numpy.load(BytesIO(r.content))\n    s = _stats(data[0:-1], data[-1])\n    return (\n        _stats(data[0:-1], data[-1]),\n        datetime.datetime.strptime(file.split(\"_\")[2].replace(\"m\", \"\"), \"%Y%m%d\"),\n    )\n\n\n# small tool to filter invalid response from the API\ndef _filter_futures(tasks):\n    for future in tasks:\n        try:\n            yield future.result()\n        except Exception:\n            pass\n</pre> def _stats(data, mask):     arr = numpy.ma.array(data)     arr.mask = mask == 0     return arr.min().item(), arr.max().item(), arr.mean().item(), arr.std().item()   xmin, ymin, xmax, ymax = bounds   def fetch_bbox(file):     url = f\"{titiler_endpoint}/cog/bbox/{xmin},{ymin},{xmax},{ymax}.npy\"     params = {         \"url\": _url(file),         \"bidx\": \"1\",         \"max_size\": 128,     }     r = httpx.get(url, params=params)     data = numpy.load(BytesIO(r.content))     s = _stats(data[0:-1], data[-1])     return (         _stats(data[0:-1], data[-1]),         datetime.datetime.strptime(file.split(\"_\")[2].replace(\"m\", \"\"), \"%Y%m%d\"),     )   # small tool to filter invalid response from the API def _filter_futures(tasks):     for future in tasks:         try:             yield future.result()         except Exception:             pass In\u00a0[\u00a0]: Copied! <pre># Every 15 of each month for all the years\nfiles_15 = list(filter(lambda x: (x.split(\"_\")[2][7:9] == \"15\"), files))\n</pre> # Every 15 of each month for all the years files_15 = list(filter(lambda x: (x.split(\"_\")[2][7:9] == \"15\"), files)) In\u00a0[\u00a0]: Copied! <pre>with futures.ThreadPoolExecutor(max_workers=10) as executor:\n    future_work = [executor.submit(fetch_bbox, file) for file in files_15]\n\n    for f in tqdm(futures.as_completed(future_work), total=len(future_work)):\n        pass\n\nvalues, dates = zip(*list(_filter_futures(future_work)))\n\nmax_values = [v[1] for v in values]\n\nfig, ax1 = plt.subplots(dpi=300)\nfig.autofmt_xdate()\n\nax1.plot(dates, max_values, label=\"No2\")\nax1.xaxis.set_major_locator(mdates.YearLocator(1, 7))\n\nax1.set_xlabel(\"Dates\")\nax1.set_ylabel(\"No2\")\n\nax1.legend()\n</pre> with futures.ThreadPoolExecutor(max_workers=10) as executor:     future_work = [executor.submit(fetch_bbox, file) for file in files_15]      for f in tqdm(futures.as_completed(future_work), total=len(future_work)):         pass  values, dates = zip(*list(_filter_futures(future_work)))  max_values = [v[1] for v in values]  fig, ax1 = plt.subplots(dpi=300) fig.autofmt_xdate()  ax1.plot(dates, max_values, label=\"No2\") ax1.xaxis.set_major_locator(mdates.YearLocator(1, 7))  ax1.set_xlabel(\"Dates\") ax1.set_ylabel(\"No2\")  ax1.legend() In\u00a0[\u00a0]: Copied! <pre>with futures.ThreadPoolExecutor(max_workers=50) as executor:\n    future_work = [executor.submit(fetch_bbox, file) for file in files]\n\n    for f in tqdm(futures.as_completed(future_work), total=len(future_work)):\n        pass\n\nvalues, dates = zip(*list(_filter_futures(future_work)))\n\nmax_values = [v[1] for v in values]\n\nfig, ax1 = plt.subplots(dpi=150)\nfig.autofmt_xdate()\n\nax1.plot(dates, max_values, label=\"No2\")\nax1.xaxis.set_major_locator(mdates.YearLocator())\n\nax1.set_xlabel(\"Dates\")\nax1.set_ylabel(\"No2\")\n\nax1.legend()\n</pre> with futures.ThreadPoolExecutor(max_workers=50) as executor:     future_work = [executor.submit(fetch_bbox, file) for file in files]      for f in tqdm(futures.as_completed(future_work), total=len(future_work)):         pass  values, dates = zip(*list(_filter_futures(future_work)))  max_values = [v[1] for v in values]  fig, ax1 = plt.subplots(dpi=150) fig.autofmt_xdate()  ax1.plot(dates, max_values, label=\"No2\") ax1.xaxis.set_major_locator(mdates.YearLocator())  ax1.set_xlabel(\"Dates\") ax1.set_ylabel(\"No2\")  ax1.legend() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF/#working-with-cog-at-scale","title":"Working With COG - At Scale\u00b6","text":"<p>For this demo we will use the new <code>Ozone Monitoring Instrument (OMI) / Aura NO2 Tropospheric Column Density</code> dataset hosted on AWS PDS: https://registry.opendata.aws/omi-no2-nasa/</p> <p>Requirement: AWS credentials</p>"},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF/#requirements","title":"Requirements\u00b6","text":"<ul> <li>AWS credentials</li> <li>rasterio</li> <li>folium</li> <li>httpx</li> <li>tqdm</li> </ul> <p><code>!pip install rasterio boto3 folium httpx tqdm</code></p>"},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF/#define-your-area-of-interest-aoi","title":"Define your area of interest (AOI)\u00b6","text":""},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF/#list-available-files-on-aws-s3","title":"List available files on AWS S3\u00b6","text":""},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF/#data-endpoint","title":"DATA Endpoint\u00b6","text":"<p><code>{endpoint}/cog/tiles/{tileMatrixSetId}/{z}/{x}/{y}.{format}?url={cog}&amp;{otherquery params}</code></p> <p><code>{endpoint}/cog/bbox/{minx},{miny},{maxx},{maxy}.{format}?url={cog}&amp;{otherquery params}</code></p> <p><code>{endpoint}/cog/point/{minx},{miny}?url={cog}&amp;{otherquery params}</code></p>"},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF/#visualize-one-item","title":"Visualize One Item\u00b6","text":""},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF/#create-time-series-of-no2","title":"Create time series of NO2\u00b6","text":""},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF/#get-no2-max-for-day-15th-of-each-month","title":"Get NO2 Max for day 15th of each month\u00b6","text":""},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF/#same-but-for-all-the-days-for-the-last-16-years","title":"Same but for all the days for the last 16 years\u00b6","text":""},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF_simple/","title":"Working With COG","text":"In\u00a0[\u00a0]: Copied! <pre># Uncomment this line if you need to install the dependencies\n# !pip install folium httpx\n</pre> # Uncomment this line if you need to install the dependencies # !pip install folium httpx In\u00a0[\u00a0]: Copied! <pre>import json\n\nimport httpx\n\nfrom folium import Map, TileLayer\n\n%matplotlib inline\n</pre> import json  import httpx  from folium import Map, TileLayer  %matplotlib inline In\u00a0[\u00a0]: Copied! <pre>titiler_endpoint = (\n    \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind.\n)\nurl = \"https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\"\n</pre> titiler_endpoint = (     \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind. ) url = \"https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\" In\u00a0[\u00a0]: Copied! <pre># Fetch File Metadata to get min/max rescaling values (because the file is stored as float32)\nr = httpx.get(\n    f\"{titiler_endpoint}/cog/info\",\n    params={\n        \"url\": url,\n    },\n).json()\n\nbounds = r[\"bounds\"]\nprint(r)\n</pre> # Fetch File Metadata to get min/max rescaling values (because the file is stored as float32) r = httpx.get(     f\"{titiler_endpoint}/cog/info\",     params={         \"url\": url,     }, ).json()  bounds = r[\"bounds\"] print(r) In\u00a0[\u00a0]: Copied! <pre># Fetch File Metadata to get min/max rescaling values (because the file is stored as float32)\nr = httpx.get(\n    f\"{titiler_endpoint}/cog/statistics\",\n    params={\n        \"url\": url,\n    },\n).json()\n\nprint(json.dumps(r, indent=4))\n</pre> # Fetch File Metadata to get min/max rescaling values (because the file is stored as float32) r = httpx.get(     f\"{titiler_endpoint}/cog/statistics\",     params={         \"url\": url,     }, ).json()  print(json.dumps(r, indent=4)) In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",\n    params={\n        \"url\": url,\n    },\n).json()\n\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2), zoom_start=13\n)\n\nTileLayer(tiles=r[\"tiles\"][0], opacity=1, attr=\"DigitalGlobe OpenData\").add_to(m)\n\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",     params={         \"url\": url,     }, ).json()  m = Map(     location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2), zoom_start=13 )  TileLayer(tiles=r[\"tiles\"][0], opacity=1, attr=\"DigitalGlobe OpenData\").add_to(m)  m In\u00a0[\u00a0]: Copied! <pre>url = \"https://data.geo.admin.ch/ch.swisstopo.swissalti3d/swissalti3d_2019_2573-1085/swissalti3d_2019_2573-1085_0.5_2056_5728.tif\"\n\n# Fetch File Metadata to get min/max rescaling values (because the file is stored as float32)\nr = httpx.get(\n    f\"{titiler_endpoint}/cog/info\",\n    params={\n        \"url\": url,\n    },\n).json()\n\nprint(r)\nprint(\"Data is of type:\", r[\"dtype\"])\n\n# This dataset has statistics metadata\nminv, maxv = (\n    r[\"band_metadata\"][0][1][\"STATISTICS_MINIMUM\"],\n    r[\"band_metadata\"][0][1][\"STATISTICS_MAXIMUM\"],\n)\nprint(\"With values from \", minv, \"to \", maxv)\n</pre> url = \"https://data.geo.admin.ch/ch.swisstopo.swissalti3d/swissalti3d_2019_2573-1085/swissalti3d_2019_2573-1085_0.5_2056_5728.tif\"  # Fetch File Metadata to get min/max rescaling values (because the file is stored as float32) r = httpx.get(     f\"{titiler_endpoint}/cog/info\",     params={         \"url\": url,     }, ).json()  print(r) print(\"Data is of type:\", r[\"dtype\"])  # This dataset has statistics metadata minv, maxv = (     r[\"band_metadata\"][0][1][\"STATISTICS_MINIMUM\"],     r[\"band_metadata\"][0][1][\"STATISTICS_MAXIMUM\"], ) print(\"With values from \", minv, \"to \", maxv) In\u00a0[\u00a0]: Copied! <pre># We could get the min/max values using the statistics endpoint\nr = httpx.get(\n    f\"{titiler_endpoint}/cog/statistics\",\n    params={\n        \"url\": url,\n    },\n).json()\n\nprint(json.dumps(r[\"b1\"], indent=4))\n</pre> # We could get the min/max values using the statistics endpoint r = httpx.get(     f\"{titiler_endpoint}/cog/statistics\",     params={         \"url\": url,     }, ).json()  print(json.dumps(r[\"b1\"], indent=4)) In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",\n    params={\n        \"url\": url,\n    },\n).json()\n\nbounds = r[\"bounds\"]\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),\n    zoom_start=r[\"minzoom\"] + 1,\n)\n\nTileLayer(tiles=r[\"tiles\"][0], opacity=1, attr=\"Swisstopo\").add_to(m)\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",     params={         \"url\": url,     }, ).json()  bounds = r[\"bounds\"] m = Map(     location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),     zoom_start=r[\"minzoom\"] + 1, )  TileLayer(tiles=r[\"tiles\"][0], opacity=1, attr=\"Swisstopo\").add_to(m) m <p>Apply ColorMap</p> <p>Now that the data is rescaled to byte values (0 -&gt; 255) we can apply a colormap</p> In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",\n    params={\"url\": url, \"rescale\": f\"{minv},{maxv}\", \"colormap_name\": \"terrain\"},\n).json()\n\nbounds = r[\"bounds\"]\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),\n    zoom_start=r[\"minzoom\"] + 1,\n)\n\nTileLayer(tiles=r[\"tiles\"][0], opacity=1, attr=\"Swisstopo\").add_to(m)\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",     params={\"url\": url, \"rescale\": f\"{minv},{maxv}\", \"colormap_name\": \"terrain\"}, ).json()  bounds = r[\"bounds\"] m = Map(     location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),     zoom_start=r[\"minzoom\"] + 1, )  TileLayer(tiles=r[\"tiles\"][0], opacity=1, attr=\"Swisstopo\").add_to(m) m <p>Apply non-linear colormap (intervals)</p> <p>see https://cogeotiff.github.io/rio-tiler/colormap/#intervals-colormaps</p> In\u00a0[\u00a0]: Copied! <pre>import json\n\ncmap = json.dumps(\n    [\n        # ([min, max], [r, g, b, a])\n        ([0, 1500], [255, 255, 204, 255]),\n        ([1500, 1700], [161, 218, 180, 255]),\n        ([1700, 1900], [65, 182, 196, 255]),\n        ([1900, 2000], [44, 127, 184, 255]),\n        ([2000, 3000], [37, 52, 148, 255]),\n    ]\n)\n# https://colorbrewer2.org/#type=sequential&amp;scheme=YlGnBu&amp;n=5\n\nr = httpx.get(\n    f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",\n    params={\"url\": url, \"colormap\": cmap},\n).json()\n\nbounds = r[\"bounds\"]\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),\n    zoom_start=r[\"minzoom\"] + 1,\n)\n\naod_layer = TileLayer(tiles=r[\"tiles\"][0], opacity=1, attr=\"Swisstopo\")\naod_layer.add_to(m)\nm\n</pre> import json  cmap = json.dumps(     [         # ([min, max], [r, g, b, a])         ([0, 1500], [255, 255, 204, 255]),         ([1500, 1700], [161, 218, 180, 255]),         ([1700, 1900], [65, 182, 196, 255]),         ([1900, 2000], [44, 127, 184, 255]),         ([2000, 3000], [37, 52, 148, 255]),     ] ) # https://colorbrewer2.org/#type=sequential&amp;scheme=YlGnBu&amp;n=5  r = httpx.get(     f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",     params={\"url\": url, \"colormap\": cmap}, ).json()  bounds = r[\"bounds\"] m = Map(     location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),     zoom_start=r[\"minzoom\"] + 1, )  aod_layer = TileLayer(tiles=r[\"tiles\"][0], opacity=1, attr=\"Swisstopo\") aod_layer.add_to(m) m In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF_simple/#working-with-cog","title":"Working With COG\u00b6","text":"<p>For this demo we will use the new <code>DigitalGlobe OpenData</code> dataset https://www.digitalglobe.com/ecosystem/open-data</p>"},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF_simple/#requirements","title":"Requirements\u00b6","text":"<ul> <li>folium</li> <li>httpx</li> </ul> <p><code>pip install folium httpx</code></p>"},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF_simple/#get-cog-info","title":"Get COG Info\u00b6","text":""},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF_simple/#get-cog-metadata","title":"Get COG Metadata\u00b6","text":""},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF_simple/#display-tiles","title":"Display Tiles\u00b6","text":""},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF_simple/#work-with-non-byte-data","title":"Work with non-byte data\u00b6","text":""},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF_simple/#display-tiles","title":"Display Tiles\u00b6","text":"<p>Note: By default if the metadata has <code>min/max</code> statistics, titiler will use those to rescale the data</p>"},{"location":"examples/notebooks/Working_with_MosaicJSON/","title":"Working With MosaicJSON","text":"In\u00a0[\u00a0]: Copied! <pre># Uncomment this line if you need to install the dependencies\n#!pip install rasterio folium tqdm httpx rio-tiler geojson_pydantic cogeo-mosaic\n</pre> # Uncomment this line if you need to install the dependencies #!pip install rasterio folium tqdm httpx rio-tiler geojson_pydantic cogeo-mosaic In\u00a0[\u00a0]: Copied! <pre>import os\nimport json\nimport rasterio\nimport httpx\nfrom boto3.session import Session as boto3_session\n\nfrom concurrent import futures\nfrom rio_tiler.io import COGReader\nfrom rasterio.features import bounds as featureBounds\n\nfrom folium import Map, TileLayer, GeoJson\n</pre> import os import json import rasterio import httpx from boto3.session import Session as boto3_session  from concurrent import futures from rio_tiler.io import COGReader from rasterio.features import bounds as featureBounds  from folium import Map, TileLayer, GeoJson In\u00a0[\u00a0]: Copied! <pre># To Be able to run this notebook you'll need to have AWS credential available in the environment\n\n# import os\n# os.environ[\"AWS_ACCESS_KEY_ID\"] = \"YOUR AWS ACCESS ID HERE\"\n# os.environ[\"AWS_SECRET_ACCESS_KEY\"] = \"YOUR AWS ACCESS KEY HERE\"\n</pre> # To Be able to run this notebook you'll need to have AWS credential available in the environment  # import os # os.environ[\"AWS_ACCESS_KEY_ID\"] = \"YOUR AWS ACCESS ID HERE\" # os.environ[\"AWS_SECRET_ACCESS_KEY\"] = \"YOUR AWS ACCESS KEY HERE\" In\u00a0[\u00a0]: Copied! <pre>session = boto3_session(region_name=\"us-west-2\")\nclient = session.client(\"s3\")\n\nbucket = \"noaa-eri-pds\"  # https://registry.opendata.aws/omi-no2-nasa/\n\n\ndef list_objects(bucket, prefix):\n    \"\"\"AWS s3 list objects.\"\"\"\n\n    paginator = client.get_paginator(\"list_objects_v2\")\n\n    files = []\n    for subset in paginator.paginate(Bucket=bucket, Prefix=prefix):\n        files.extend(subset.get(\"Contents\", []))\n\n    return [r[\"Key\"] for r in files]\n\n\nfiles = list_objects(bucket, \"2020_Nashville_Tornado/20200307a_RGB\")\nfiles = [f\"s3://{bucket}/{f}\" for f in files if f.endswith(\".tif\")]\n\nprint(f\"Number of GeoTIFF: {len(files)}\")\n</pre> session = boto3_session(region_name=\"us-west-2\") client = session.client(\"s3\")  bucket = \"noaa-eri-pds\"  # https://registry.opendata.aws/omi-no2-nasa/   def list_objects(bucket, prefix):     \"\"\"AWS s3 list objects.\"\"\"      paginator = client.get_paginator(\"list_objects_v2\")      files = []     for subset in paginator.paginate(Bucket=bucket, Prefix=prefix):         files.extend(subset.get(\"Contents\", []))      return [r[\"Key\"] for r in files]   files = list_objects(bucket, \"2020_Nashville_Tornado/20200307a_RGB\") files = [f\"s3://{bucket}/{f}\" for f in files if f.endswith(\".tif\")]  print(f\"Number of GeoTIFF: {len(files)}\") In\u00a0[\u00a0]: Copied! <pre>print(files)\n</pre> print(files) In\u00a0[\u00a0]: Copied! <pre># We can derive the `bbox` from the filename\n# s3://noaa-eri-pds/2020_Nashville_Tornado/20200307a_RGB/20200307aC0870130w361200n.tif\n# -&gt; 20200307aC0870130w361200n.tif\n# -&gt; 20200307aC \"0870130w\" \"361200n\" .tif\n# -&gt; 0870130w -&gt; 87.025 (West)\n# -&gt; 361200n -&gt; 36.2 (Top)\n# We also know each files cover ~0.025x~0.025 degrees\n\nimport re\nfrom geojson_pydantic.features import Feature\nfrom geojson_pydantic.geometries import Polygon\n\n\ndef dms_to_degree(v: str) -&gt; float:\n    \"\"\"convert degree minute second to decimal degrees.\n\n    '0870130w' -&gt; 87.025\n    \"\"\"\n    deg = int(v[0:3])\n    minutes = int(v[3:5])\n    seconds = int(v[5:7])\n    direction = v[-1].upper()\n    return (float(deg) + float(minutes) / 60 + float(seconds) / (60 * 60)) * (\n        -1 if direction in [\"W\", \"S\"] else 1\n    )\n\n\ndef fname_to_feature(src_path: str) -&gt; Feature:\n    bname = os.path.basename(src_path)\n    lon_dms = bname[10:18]\n    lat_dms = bname[18:25]\n\n    lon = dms_to_degree(lon_dms)\n    lat = dms_to_degree(\"0\" + lat_dms)\n\n    return Feature(\n        geometry=Polygon.from_bounds(lon, lat - 0.025, lon + 0.025, lat),\n        properties={\n            \"path\": src_path,\n        },\n    )\n\n\nfeatures = [fname_to_feature(f).dict(exclude_none=True) for f in files]\n\n# OR We could use Rasterio/rio-tiler\n\n# def worker(src_path: str) -&gt; Feature:\n#     try:\n#         with COGReader(src_path) as cog:\n#             wgs_bounds = cog.geographic_bounds\n#     except:\n#         return {}\n#\n#     return Feature(\n#         geometry=Polygon.from_bounds(*wgs_bounds),\n#         properties={\n#             \"path\": src_path,\n#         }\n#     )\n#\n# with futures.ThreadPoolExecutor(max_workers=20) as executor:\n#     features = [r.dict(exclude_none=True) for r in executor.map(worker, files) if r]\n</pre> # We can derive the `bbox` from the filename # s3://noaa-eri-pds/2020_Nashville_Tornado/20200307a_RGB/20200307aC0870130w361200n.tif # -&gt; 20200307aC0870130w361200n.tif # -&gt; 20200307aC \"0870130w\" \"361200n\" .tif # -&gt; 0870130w -&gt; 87.025 (West) # -&gt; 361200n -&gt; 36.2 (Top) # We also know each files cover ~0.025x~0.025 degrees  import re from geojson_pydantic.features import Feature from geojson_pydantic.geometries import Polygon   def dms_to_degree(v: str) -&gt; float:     \"\"\"convert degree minute second to decimal degrees.      '0870130w' -&gt; 87.025     \"\"\"     deg = int(v[0:3])     minutes = int(v[3:5])     seconds = int(v[5:7])     direction = v[-1].upper()     return (float(deg) + float(minutes) / 60 + float(seconds) / (60 * 60)) * (         -1 if direction in [\"W\", \"S\"] else 1     )   def fname_to_feature(src_path: str) -&gt; Feature:     bname = os.path.basename(src_path)     lon_dms = bname[10:18]     lat_dms = bname[18:25]      lon = dms_to_degree(lon_dms)     lat = dms_to_degree(\"0\" + lat_dms)      return Feature(         geometry=Polygon.from_bounds(lon, lat - 0.025, lon + 0.025, lat),         properties={             \"path\": src_path,         },     )   features = [fname_to_feature(f).dict(exclude_none=True) for f in files]  # OR We could use Rasterio/rio-tiler  # def worker(src_path: str) -&gt; Feature: #     try: #         with COGReader(src_path) as cog: #             wgs_bounds = cog.geographic_bounds #     except: #         return {} # #     return Feature( #         geometry=Polygon.from_bounds(*wgs_bounds), #         properties={ #             \"path\": src_path, #         } #     ) # # with futures.ThreadPoolExecutor(max_workers=20) as executor: #     features = [r.dict(exclude_none=True) for r in executor.map(worker, files) if r] In\u00a0[\u00a0]: Copied! <pre>geojson = {\"type\": \"FeatureCollection\", \"features\": features}\n\nbounds = featureBounds(geojson)\n\nm = Map(\n    tiles=\"OpenStreetMap\",\n    location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),\n    zoom_start=6,\n)\n\ngeo_json = GeoJson(\n    data=geojson,\n    style_function=lambda x: {\n        \"opacity\": 1,\n        \"dashArray\": \"1\",\n        \"fillOpacity\": 0,\n        \"weight\": 1,\n    },\n)\ngeo_json.add_to(m)\nm\n</pre> geojson = {\"type\": \"FeatureCollection\", \"features\": features}  bounds = featureBounds(geojson)  m = Map(     tiles=\"OpenStreetMap\",     location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),     zoom_start=6, )  geo_json = GeoJson(     data=geojson,     style_function=lambda x: {         \"opacity\": 1,         \"dashArray\": \"1\",         \"fillOpacity\": 0,         \"weight\": 1,     }, ) geo_json.add_to(m) m In\u00a0[\u00a0]: Copied! <pre>from rio_tiler.io import COGReader\nfrom cogeo_mosaic.mosaic import MosaicJSON\nfrom cogeo_mosaic.backends import MosaicBackend\n\nwith COGReader(files[0]) as cog:\n    info = cog.info()\n    print(info.minzoom)\n    print(info.maxzoom)\n</pre> from rio_tiler.io import COGReader from cogeo_mosaic.mosaic import MosaicJSON from cogeo_mosaic.backends import MosaicBackend  with COGReader(files[0]) as cog:     info = cog.info()     print(info.minzoom)     print(info.maxzoom) In\u00a0[\u00a0]: Copied! <pre># We are creating the mosaicJSON using the features we created earlier\n# by default MosaicJSON.from_feature will look in feature.properties.path to get the path of the dataset\nmosaicdata = MosaicJSON.from_features(\n    features, minzoom=info.minzoom, maxzoom=info.maxzoom\n)\nwith MosaicBackend(\"NOAA_Nashville_Tornado.json.gz\", mosaic_def=mosaicdata) as mosaic:\n    mosaic.write(overwrite=True)\n    print(mosaic.info())\n</pre> # We are creating the mosaicJSON using the features we created earlier # by default MosaicJSON.from_feature will look in feature.properties.path to get the path of the dataset mosaicdata = MosaicJSON.from_features(     features, minzoom=info.minzoom, maxzoom=info.maxzoom ) with MosaicBackend(\"NOAA_Nashville_Tornado.json.gz\", mosaic_def=mosaicdata) as mosaic:     mosaic.write(overwrite=True)     print(mosaic.info()) In\u00a0[\u00a0]: Copied! <pre>titiler_endpoint = (\n    \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind.\n)\n\nr = httpx.get(\n    f\"{titiler_endpoint}/mosaicjson/WebMercatorQuad/tilejson.json\",\n    params={\n        # For this demo we are use the same mosaic but stored on the web\n        \"url\": \"https://gist.githubusercontent.com/vincentsarago/c6ace3ccd29a82a4a5531693bbcd61fc/raw/e0d0174a64a9acd2fb820f2c65b1830aab80f52b/NOAA_Nashville_Tornado.json\"\n    },\n).json()\nprint(r)\n\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2), zoom_start=13\n)\n\ntiles = TileLayer(\n    tiles=r[\"tiles\"][0],\n    min_zoom=r[\"minzoom\"],\n    max_zoom=r[\"maxzoom\"],\n    opacity=1,\n    attr=\"NOAA\",\n)\n\ngeo_json = GeoJson(\n    data=geojson,\n    style_function=lambda x: {\n        \"opacity\": 1,\n        \"dashArray\": \"1\",\n        \"fillOpacity\": 0,\n        \"weight\": 1,\n    },\n)\ntiles.add_to(m)\ngeo_json.add_to(m)\nm\n</pre> titiler_endpoint = (     \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind. )  r = httpx.get(     f\"{titiler_endpoint}/mosaicjson/WebMercatorQuad/tilejson.json\",     params={         # For this demo we are use the same mosaic but stored on the web         \"url\": \"https://gist.githubusercontent.com/vincentsarago/c6ace3ccd29a82a4a5531693bbcd61fc/raw/e0d0174a64a9acd2fb820f2c65b1830aab80f52b/NOAA_Nashville_Tornado.json\"     }, ).json() print(r)  m = Map(     location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2), zoom_start=13 )  tiles = TileLayer(     tiles=r[\"tiles\"][0],     min_zoom=r[\"minzoom\"],     max_zoom=r[\"maxzoom\"],     opacity=1,     attr=\"NOAA\", )  geo_json = GeoJson(     data=geojson,     style_function=lambda x: {         \"opacity\": 1,         \"dashArray\": \"1\",         \"fillOpacity\": 0,         \"weight\": 1,     }, ) tiles.add_to(m) geo_json.add_to(m) m In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/notebooks/Working_with_MosaicJSON/#working-with-mosaicjson","title":"Working With MosaicJSON\u00b6","text":""},{"location":"examples/notebooks/Working_with_MosaicJSON/#mosaicjson","title":"MosaicJSON\u00b6","text":"<p>MosaicJSON is a specification created by DevelopmentSeed which aims to be an open standard for representing metadata about a mosaic of Cloud-Optimized GeoTIFF (COG) files.</p> <p>MosaicJSON can be seen as a Virtual raster (see GDAL's VRT) enabling spatial and temporal processing for a list of Cloud-Optimized GeoTIFF.</p> <p>Ref:https://github.com/developmentseed/mosaicjson-spec</p>"},{"location":"examples/notebooks/Working_with_MosaicJSON/#data","title":"Data\u00b6","text":"<p>For this demo, we are going to use CloudOptimized GeoTIFF from NOAA/Emergency Response Imagery: https://registry.opendata.aws/noaa-eri/</p> <p>Requirement: AWS credentials</p>"},{"location":"examples/notebooks/Working_with_MosaicJSON/#endpoint","title":"Endpoint\u00b6","text":"<p>By default, TiTiler has <code>mosaicjson</code> endpoints.</p> <p>Docs: https://titiler.xyz/api.html#/MosaicJSON</p>"},{"location":"examples/notebooks/Working_with_MosaicJSON/#requirements","title":"Requirements\u00b6","text":"<p>To be able to run this notebook you'll need the following requirements:</p> <ul> <li>rasterio</li> <li>folium</li> <li>httpx</li> <li>tqdm</li> <li>rio-tiler</li> <li>cogeo-mosaic</li> <li>boto3</li> <li>geojson_pydantic</li> </ul> <p><code>pip install rasterio folium tqdm httpx rio-tiler geojson_pydantic cogeo-mosaic</code></p>"},{"location":"examples/notebooks/Working_with_MosaicJSON/#get-the-data","title":"Get the Data\u00b6","text":""},{"location":"examples/notebooks/Working_with_MosaicJSON/#1-fetch-and-parse-page","title":"1. Fetch and parse page\u00b6","text":""},{"location":"examples/notebooks/Working_with_MosaicJSON/#2-create-features-and-viz-optional","title":"2. Create Features and Viz (Optional)\u00b6","text":"<p>Read each file geo metadata</p>"},{"location":"examples/notebooks/Working_with_MosaicJSON/#5-create-mosaic","title":"5. Create Mosaic\u00b6","text":""},{"location":"examples/notebooks/Working_with_NumpyTile/","title":"NumpyTile","text":"In\u00a0[\u00a0]: Copied! <pre># Uncomment this line if you need to install the dependencies\n# !pip install numpy mercantile\n</pre> # Uncomment this line if you need to install the dependencies # !pip install numpy mercantile In\u00a0[\u00a0]: Copied! <pre>import httpx\nimport mercantile\nfrom io import BytesIO\nimport numpy\n\n%pylab inline\n</pre> import httpx import mercantile from io import BytesIO import numpy  %pylab inline In\u00a0[\u00a0]: Copied! <pre>titiler_endpoint = (\n    \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind.\n)\nurl = \"https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\"\n</pre> titiler_endpoint = (     \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind. ) url = \"https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\" In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json?url={url}\").json()\nprint(r)\n</pre> r = httpx.get(f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json?url={url}\").json() print(r) In\u00a0[\u00a0]: Copied! <pre># Get a list of tiles for minzoom + 2\n\ntiles = list(mercantile.tiles(*r[\"bounds\"], r[\"minzoom\"] + 2))\n</pre> # Get a list of tiles for minzoom + 2  tiles = list(mercantile.tiles(*r[\"bounds\"], r[\"minzoom\"] + 2)) In\u00a0[\u00a0]: Copied! <pre># Call TiTiler endpoint using the first tile\n\ntile = tiles[0]\nr = httpx.get(\n    f\"{titiler_endpoint}/cog/tiles/WebMercatorQuad/{tile.z}/{tile.x}/{tile.y}.npy?url={url}\"\n)\n</pre> # Call TiTiler endpoint using the first tile  tile = tiles[0] r = httpx.get(     f\"{titiler_endpoint}/cog/tiles/WebMercatorQuad/{tile.z}/{tile.x}/{tile.y}.npy?url={url}\" ) In\u00a0[\u00a0]: Copied! <pre># Load result using numpy.load\n\narr = numpy.load(BytesIO(r.content))\nprint(type(arr))\nprint(arr.shape)\n</pre> # Load result using numpy.load  arr = numpy.load(BytesIO(r.content)) print(type(arr)) print(arr.shape) In\u00a0[\u00a0]: Copied! <pre># By default we put the data and the mask in the same array\ntile, mask = arr[0:-1], arr[-1]\n</pre> # By default we put the data and the mask in the same array tile, mask = arr[0:-1], arr[-1] In\u00a0[\u00a0]: Copied! <pre>print(tile.shape)\n</pre> print(tile.shape) In\u00a0[\u00a0]: Copied! <pre>print(mask.shape)\n</pre> print(mask.shape) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/notebooks/Working_with_NumpyTile/#numpytile","title":"NumpyTile\u00b6","text":"<p>Specification: https://github.com/planetlabs/numpytiles-spec</p>"},{"location":"examples/notebooks/Working_with_NumpyTile/#requirements","title":"Requirements\u00b6","text":"<ul> <li>mercantile</li> <li>numpy</li> </ul> <p><code>!pip install numpy mercantile</code></p>"},{"location":"examples/notebooks/Working_with_STAC/","title":"Working With STAC - At Scale","text":"In\u00a0[\u00a0]: Copied! <pre># Uncomment this line if you need to install the dependencies\n# !pip rasterio folium httpx tqdm\n</pre> # Uncomment this line if you need to install the dependencies # !pip rasterio folium httpx tqdm In\u00a0[\u00a0]: Copied! <pre>import os\nimport json\nimport base64\nimport httpx\nimport datetime\nimport itertools\nimport urllib.parse\n\nfrom io import BytesIO\nfrom functools import partial\nfrom concurrent import futures\n\nfrom tqdm.notebook import tqdm\n\nfrom rasterio.plot import reshape_as_image\nfrom rasterio.features import bounds as featureBounds\n\nfrom folium import Map, TileLayer, GeoJson\n\n%pylab inline\n</pre> import os import json import base64 import httpx import datetime import itertools import urllib.parse  from io import BytesIO from functools import partial from concurrent import futures  from tqdm.notebook import tqdm  from rasterio.plot import reshape_as_image from rasterio.features import bounds as featureBounds  from folium import Map, TileLayer, GeoJson  %pylab inline In\u00a0[\u00a0]: Copied! <pre># Endpoint variables\ntitiler_endpoint = (\n    \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind.\n)\nstac_endpoint = \"https://earth-search.aws.element84.com/v0/search\"\n</pre> # Endpoint variables titiler_endpoint = (     \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind. ) stac_endpoint = \"https://earth-search.aws.element84.com/v0/search\" In\u00a0[\u00a0]: Copied! <pre>geojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"properties\": {},\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                    [\n                        [30.810813903808594, 29.454247067148533],\n                        [30.88600158691406, 29.454247067148533],\n                        [30.88600158691406, 29.51879923863822],\n                        [30.810813903808594, 29.51879923863822],\n                        [30.810813903808594, 29.454247067148533],\n                    ]\n                ],\n            },\n        }\n    ],\n}\n\nbounds = featureBounds(geojson)\n\nm = Map(\n    tiles=\"OpenStreetMap\",\n    location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),\n    zoom_start=11,\n)\n\ngeo_json = GeoJson(data=geojson)\ngeo_json.add_to(m)\nm\n</pre> geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"properties\": {},             \"geometry\": {                 \"type\": \"Polygon\",                 \"coordinates\": [                     [                         [30.810813903808594, 29.454247067148533],                         [30.88600158691406, 29.454247067148533],                         [30.88600158691406, 29.51879923863822],                         [30.810813903808594, 29.51879923863822],                         [30.810813903808594, 29.454247067148533],                     ]                 ],             },         }     ], }  bounds = featureBounds(geojson)  m = Map(     tiles=\"OpenStreetMap\",     location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),     zoom_start=11, )  geo_json = GeoJson(data=geojson) geo_json.add_to(m) m <ol> <li>Define dates and other filters</li> </ol> In\u00a0[\u00a0]: Copied! <pre>start = datetime.datetime.strptime(\"2019-01-01\", \"%Y-%m-%d\").strftime(\n    \"%Y-%m-%dT00:00:00Z\"\n)\nend = datetime.datetime.strptime(\"2019-12-11\", \"%Y-%m-%d\").strftime(\n    \"%Y-%m-%dT23:59:59Z\"\n)\n\n# POST body\nquery = {\n    \"collections\": [\"sentinel-s2-l2a-cogs\"],\n    \"datetime\": f\"{start}/{end}\",\n    \"query\": {\n        \"eo:cloud_cover\": {\"lt\": 5},\n    },\n    \"intersects\": geojson[\"features\"][0][\"geometry\"],\n    \"limit\": 100,\n    \"fields\": {\n        \"include\": [\n            \"id\",\n            \"properties.datetime\",\n            \"properties.eo:cloud_cover\",\n        ],  # This will limit the size of returned body\n        \"exclude\": [\"assets\", \"links\"],  # This will limit the size of returned body\n    },\n}\n\n# POST Headers\nheaders = {\n    \"Content-Type\": \"application/json\",\n    \"Accept-Encoding\": \"gzip\",\n    \"Accept\": \"application/geo+json\",\n}\n\ndata = httpx.post(stac_endpoint, headers=headers, json=query).json()\nprint(\"Results context:\")\nprint(data[\"context\"])\nprint()\nprint(\"Example of item:\")\nprint(json.dumps(data[\"features\"][0], indent=4))\n\nsceneid = [f[\"id\"] for f in data[\"features\"]]\ncloudcover = [f[\"properties\"][\"eo:cloud_cover\"] for f in data[\"features\"]]\ndates = [f[\"properties\"][\"datetime\"][0:10] for f in data[\"features\"]]\n</pre> start = datetime.datetime.strptime(\"2019-01-01\", \"%Y-%m-%d\").strftime(     \"%Y-%m-%dT00:00:00Z\" ) end = datetime.datetime.strptime(\"2019-12-11\", \"%Y-%m-%d\").strftime(     \"%Y-%m-%dT23:59:59Z\" )  # POST body query = {     \"collections\": [\"sentinel-s2-l2a-cogs\"],     \"datetime\": f\"{start}/{end}\",     \"query\": {         \"eo:cloud_cover\": {\"lt\": 5},     },     \"intersects\": geojson[\"features\"][0][\"geometry\"],     \"limit\": 100,     \"fields\": {         \"include\": [             \"id\",             \"properties.datetime\",             \"properties.eo:cloud_cover\",         ],  # This will limit the size of returned body         \"exclude\": [\"assets\", \"links\"],  # This will limit the size of returned body     }, }  # POST Headers headers = {     \"Content-Type\": \"application/json\",     \"Accept-Encoding\": \"gzip\",     \"Accept\": \"application/geo+json\", }  data = httpx.post(stac_endpoint, headers=headers, json=query).json() print(\"Results context:\") print(data[\"context\"]) print() print(\"Example of item:\") print(json.dumps(data[\"features\"][0], indent=4))  sceneid = [f[\"id\"] for f in data[\"features\"]] cloudcover = [f[\"properties\"][\"eo:cloud_cover\"] for f in data[\"features\"]] dates = [f[\"properties\"][\"datetime\"][0:10] for f in data[\"features\"]] In\u00a0[\u00a0]: Copied! <pre>m = Map(\n    tiles=\"OpenStreetMap\",\n    location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),\n    zoom_start=8,\n)\n\ngeo_json = GeoJson(\n    data=data,\n    style_function=lambda x: {\n        \"opacity\": 1,\n        \"dashArray\": \"1\",\n        \"fillOpacity\": 0,\n        \"weight\": 1,\n    },\n)\ngeo_json.add_to(m)\nm\n</pre> m = Map(     tiles=\"OpenStreetMap\",     location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),     zoom_start=8, )  geo_json = GeoJson(     data=data,     style_function=lambda x: {         \"opacity\": 1,         \"dashArray\": \"1\",         \"fillOpacity\": 0,         \"weight\": 1,     }, ) geo_json.add_to(m) m <p>Plot Date / Cloud Cover</p> In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(dpi=100)\nfig.autofmt_xdate()\nax = fig.add_subplot(1, 1, 1)\nax.plot(\n    dates,\n    cloudcover,\n    label=\"Cloud Cover\",\n    color=\"tab:red\",\n    linewidth=0.4,\n    linestyle=\"-.\",\n)\n\nax.legend()\n</pre> fig = plt.figure(dpi=100) fig.autofmt_xdate() ax = fig.add_subplot(1, 1, 1) ax.plot(     dates,     cloudcover,     label=\"Cloud Cover\",     color=\"tab:red\",     linewidth=0.4,     linestyle=\"-.\", )  ax.legend() In\u00a0[\u00a0]: Copied! <pre>url_template = \"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/{id}\"\n</pre> url_template = \"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/{id}\" In\u00a0[\u00a0]: Copied! <pre># Get Tile URL\nitem = url_template.format(id=sceneid[-1])\nprint(item)\nr = httpx.get(\n    f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",\n    params=(\n        (\"url\", item),\n        # Simple RGB combination (True Color)\n        (\n            \"assets\",\n            \"B04\",\n        ),  # red, in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)\n        (\n            \"assets\",\n            \"B03\",\n        ),  # green, in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)\n        (\n            \"assets\",\n            \"B02\",\n        ),  # blue, in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)\n        (\n            \"color_formula\",\n            \"Gamma RGB 3.5 Saturation 1.7 Sigmoidal RGB 15 0.35\",\n        ),  # We use a rio-color formula to make the tiles look nice\n        (\"minzoom\", 8),  # By default titiler will use 0\n        (\"maxzoom\", 14),  # By default titiler will use 24\n    ),\n).json()\nprint(r)\n\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2), zoom_start=10\n)\n\ntiles = TileLayer(\n    tiles=r[\"tiles\"][0],\n    min_zoom=r[\"minzoom\"],\n    max_zoom=r[\"maxzoom\"],\n    opacity=1,\n    attr=\"Digital Earth Africa\",\n)\ntiles.add_to(m)\nm\n</pre> # Get Tile URL item = url_template.format(id=sceneid[-1]) print(item) r = httpx.get(     f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",     params=(         (\"url\", item),         # Simple RGB combination (True Color)         (             \"assets\",             \"B04\",         ),  # red, in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)         (             \"assets\",             \"B03\",         ),  # green, in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)         (             \"assets\",             \"B02\",         ),  # blue, in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)         (             \"color_formula\",             \"Gamma RGB 3.5 Saturation 1.7 Sigmoidal RGB 15 0.35\",         ),  # We use a rio-color formula to make the tiles look nice         (\"minzoom\", 8),  # By default titiler will use 0         (\"maxzoom\", 14),  # By default titiler will use 24     ), ).json() print(r)  m = Map(     location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2), zoom_start=10 )  tiles = TileLayer(     tiles=r[\"tiles\"][0],     min_zoom=r[\"minzoom\"],     max_zoom=r[\"maxzoom\"],     opacity=1,     attr=\"Digital Earth Africa\", ) tiles.add_to(m) m In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",\n    params=(\n        (\"url\", url_template.format(id=sceneid[0])),\n        # False Color Infrared\n        (\n            \"assets\",\n            \"B08\",\n        ),  # nir, in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)\n        (\n            \"assets\",\n            \"B04\",\n        ),  # red, in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)\n        (\n            \"assets\",\n            \"B03\",\n        ),  # green, in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)\n        (\n            \"color_formula\",\n            \"Gamma RGB 3.5 Saturation 1.7 Sigmoidal RGB 15 0.35\",\n        ),  # We use a rio-color formula to make the tiles look nice\n        (\"minzoom\", 8),  # By default titiler will use 0\n        (\"maxzoom\", 14),  # By default titiler will use 24\n    ),\n).json()\nprint(r)\n\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2), zoom_start=10\n)\n\ntiles = TileLayer(\n    tiles=r[\"tiles\"][0],\n    min_zoom=r[\"minzoom\"],\n    max_zoom=r[\"maxzoom\"],\n    opacity=1,\n    attr=\"Digital Earth Africa\",\n)\ntiles.add_to(m)\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",     params=(         (\"url\", url_template.format(id=sceneid[0])),         # False Color Infrared         (             \"assets\",             \"B08\",         ),  # nir, in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)         (             \"assets\",             \"B04\",         ),  # red, in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)         (             \"assets\",             \"B03\",         ),  # green, in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)         (             \"color_formula\",             \"Gamma RGB 3.5 Saturation 1.7 Sigmoidal RGB 15 0.35\",         ),  # We use a rio-color formula to make the tiles look nice         (\"minzoom\", 8),  # By default titiler will use 0         (\"maxzoom\", 14),  # By default titiler will use 24     ), ).json() print(r)  m = Map(     location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2), zoom_start=10 )  tiles = TileLayer(     tiles=r[\"tiles\"][0],     min_zoom=r[\"minzoom\"],     max_zoom=r[\"maxzoom\"],     opacity=1,     attr=\"Digital Earth Africa\", ) tiles.add_to(m) m In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",\n    params={\n        \"url\": url_template.format(id=sceneid[0]),\n        \"expression\": \"(B08-B04)/(B08+B04)\",  # NDVI (nir-red)/(nir+red), in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)\n        # We need to tell rio-tiler that each asset is a Band\n        # (so it will select the first band within each asset automatically)\n        \"asset_as_band\": True,\n        \"rescale\": \"-1,1\",\n        \"minzoom\": 8,  # By default titiler will use 0\n        \"maxzoom\": 14,  # By default titiler will use 24\n        \"colormap_name\": \"viridis\",\n    },\n).json()\nprint(r)\n\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2), zoom_start=10\n)\n\ntiles = TileLayer(\n    tiles=r[\"tiles\"][0],\n    min_zoom=r[\"minzoom\"],\n    max_zoom=r[\"maxzoom\"],\n    opacity=1,\n    attr=\"Digital Earth Africa\",\n)\ntiles.add_to(m)\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",     params={         \"url\": url_template.format(id=sceneid[0]),         \"expression\": \"(B08-B04)/(B08+B04)\",  # NDVI (nir-red)/(nir+red), in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)         # We need to tell rio-tiler that each asset is a Band         # (so it will select the first band within each asset automatically)         \"asset_as_band\": True,         \"rescale\": \"-1,1\",         \"minzoom\": 8,  # By default titiler will use 0         \"maxzoom\": 14,  # By default titiler will use 24         \"colormap_name\": \"viridis\",     }, ).json() print(r)  m = Map(     location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2), zoom_start=10 )  tiles = TileLayer(     tiles=r[\"tiles\"][0],     min_zoom=r[\"minzoom\"],     max_zoom=r[\"maxzoom\"],     opacity=1,     attr=\"Digital Earth Africa\", ) tiles.add_to(m) m In\u00a0[\u00a0]: Copied! <pre>def fetch_bbox_array(sceneid, bbox, assets=None, expression=None, **kwargs):\n    \"\"\"Helper function to fetch and decode Numpy array using Titiler endpoint.\"\"\"\n    # STAC ITEM URL\n    stac_item = f\"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/{sceneid}\"\n\n    xmin, ymin, xmax, ymax = bbox\n\n    # TiTiler required URL + asset or expression parameters\n    params = ((\"url\", stac_item), (\"max_size\", 1024))\n    if assets:\n        for asset in assets:\n            params += ((\"assets\", asset),)\n    elif expression:\n        params += (\n            (\"expression\", expression),\n            (\"asset_as_band\", True),\n        )\n    else:\n        raise Exception(\"Missing band or expression input\")\n\n    params += tuple(kwargs.items())\n\n    # TITILER ENDPOINT\n    url = f\"{titiler_endpoint}/stac/bbox/{xmin},{ymin},{xmax},{ymax}.npy\"\n    r = httpx.get(url, params=params)\n    data = numpy.load(BytesIO(r.content))\n\n    return sceneid, data[0:-1], data[-1]\n\n\ndef _filter_futures(tasks):\n    for future in tasks:\n        try:\n            yield future.result()\n        except Exception:\n            pass\n\n\ndef _stats(data, mask):\n    arr = numpy.ma.array(data)\n    arr.mask = mask == 0\n    return arr.min().item(), arr.max().item(), arr.mean().item(), arr.std().item()\n</pre> def fetch_bbox_array(sceneid, bbox, assets=None, expression=None, **kwargs):     \"\"\"Helper function to fetch and decode Numpy array using Titiler endpoint.\"\"\"     # STAC ITEM URL     stac_item = f\"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/{sceneid}\"      xmin, ymin, xmax, ymax = bbox      # TiTiler required URL + asset or expression parameters     params = ((\"url\", stac_item), (\"max_size\", 1024))     if assets:         for asset in assets:             params += ((\"assets\", asset),)     elif expression:         params += (             (\"expression\", expression),             (\"asset_as_band\", True),         )     else:         raise Exception(\"Missing band or expression input\")      params += tuple(kwargs.items())      # TITILER ENDPOINT     url = f\"{titiler_endpoint}/stac/bbox/{xmin},{ymin},{xmax},{ymax}.npy\"     r = httpx.get(url, params=params)     data = numpy.load(BytesIO(r.content))      return sceneid, data[0:-1], data[-1]   def _filter_futures(tasks):     for future in tasks:         try:             yield future.result()         except Exception:             pass   def _stats(data, mask):     arr = numpy.ma.array(data)     arr.mask = mask == 0     return arr.min().item(), arr.max().item(), arr.mean().item(), arr.std().item() In\u00a0[\u00a0]: Copied! <pre># Fetch one data\n_, data, mask = fetch_bbox_array(\n    sceneid[0], bounds, assets=[\"B02\"], width=128, height=128\n)\n\nprint(data.shape)\nprint(mask.shape)\n\nimshow(data[0])\n</pre> # Fetch one data _, data, mask = fetch_bbox_array(     sceneid[0], bounds, assets=[\"B02\"], width=128, height=128 )  print(data.shape) print(mask.shape)  imshow(data[0]) In\u00a0[\u00a0]: Copied! <pre># Let's fetch the data over our AOI for all our Items\n# Here we use `futures.ThreadPoolExecutor` to run the requests in parallel\n# Note: it takes more time for the notebook to display the results than to fetch the data\n\nbbox_worker = partial(\n    fetch_bbox_array,\n    bbox=bounds,\n    assets=(\n        \"B04\",\n        \"B03\",\n        \"B02\",\n    ),  # (\"red\", \"green\", \"blue\"), in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)\n    color_formula=\"gamma RGB 3.5, saturation 1.7, sigmoidal RGB 15 0.35\",\n    width=64,\n    height=64,\n)\n\nwith futures.ThreadPoolExecutor(max_workers=10) as executor:\n    future_work = [executor.submit(bbox_worker, scene) for scene in sceneid]\n\n    for f in tqdm(futures.as_completed(future_work), total=len(future_work)):\n        pass\n\nresults_rgb = list(_filter_futures(future_work))\n\nprint(\"diplay all results\")\n\nfig = plt.figure(figsize=(10, 20))\ncol = 5\nrow = math.ceil(len(dates) / col)\nfor i in range(1, len(results_rgb) + 1):\n    fig.add_subplot(row, col, i)\n    plt.imshow(reshape_as_image(results_rgb[i - 1][1]))\n</pre> # Let's fetch the data over our AOI for all our Items # Here we use `futures.ThreadPoolExecutor` to run the requests in parallel # Note: it takes more time for the notebook to display the results than to fetch the data  bbox_worker = partial(     fetch_bbox_array,     bbox=bounds,     assets=(         \"B04\",         \"B03\",         \"B02\",     ),  # (\"red\", \"green\", \"blue\"), in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)     color_formula=\"gamma RGB 3.5, saturation 1.7, sigmoidal RGB 15 0.35\",     width=64,     height=64, )  with futures.ThreadPoolExecutor(max_workers=10) as executor:     future_work = [executor.submit(bbox_worker, scene) for scene in sceneid]      for f in tqdm(futures.as_completed(future_work), total=len(future_work)):         pass  results_rgb = list(_filter_futures(future_work))  print(\"diplay all results\")  fig = plt.figure(figsize=(10, 20)) col = 5 row = math.ceil(len(dates) / col) for i in range(1, len(results_rgb) + 1):     fig.add_subplot(row, col, i)     plt.imshow(reshape_as_image(results_rgb[i - 1][1])) In\u00a0[\u00a0]: Copied! <pre>## Fetch NDVI\n\nbbox_worker = partial(\n    fetch_bbox_array,\n    bbox=bounds,\n    expression=\"(B08-B04)/(B08+B04)\",  # (nir-red)/(nir+red), in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)\n    width=64,\n    height=64,\n)\n\nwith futures.ThreadPoolExecutor(max_workers=10) as executor:\n    future_work = [executor.submit(bbox_worker, scene) for scene in sceneid]\n\n    for f in tqdm(futures.as_completed(future_work), total=len(future_work)):\n        pass\n\nresults_ndvi = list(_filter_futures(future_work))\n\nfig = plt.figure(figsize=(10, 20))\ncol = 5\nrow = math.ceil(len(dates) / col)\nfor i in range(1, len(results_ndvi) + 1):\n    fig.add_subplot(row, col, i)\n    plt.imshow(results_ndvi[i - 1][1][0])\n</pre> ## Fetch NDVI  bbox_worker = partial(     fetch_bbox_array,     bbox=bounds,     expression=\"(B08-B04)/(B08+B04)\",  # (nir-red)/(nir+red), in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)     width=64,     height=64, )  with futures.ThreadPoolExecutor(max_workers=10) as executor:     future_work = [executor.submit(bbox_worker, scene) for scene in sceneid]      for f in tqdm(futures.as_completed(future_work), total=len(future_work)):         pass  results_ndvi = list(_filter_futures(future_work))  fig = plt.figure(figsize=(10, 20)) col = 5 row = math.ceil(len(dates) / col) for i in range(1, len(results_ndvi) + 1):     fig.add_subplot(row, col, i)     plt.imshow(results_ndvi[i - 1][1][0]) In\u00a0[\u00a0]: Copied! <pre>stats = [_stats(data, mask) for _, data, mask in results_ndvi]\n\nfig, ax1 = plt.subplots(dpi=150)\nfig.autofmt_xdate()\n\nax1.plot(dates, [s[0] for s in stats], label=\"Min\")\nax1.plot(dates, [s[1] for s in stats], label=\"Max\")\nax1.plot(dates, [s[2] for s in stats], label=\"Mean\")\nax1.set_xlabel(\"Dates\")\nax1.set_ylabel(\"Normalized Difference Vegetation Index\")\n\nax1.legend()\n</pre> stats = [_stats(data, mask) for _, data, mask in results_ndvi]  fig, ax1 = plt.subplots(dpi=150) fig.autofmt_xdate()  ax1.plot(dates, [s[0] for s in stats], label=\"Min\") ax1.plot(dates, [s[1] for s in stats], label=\"Max\") ax1.plot(dates, [s[2] for s in stats], label=\"Mean\") ax1.set_xlabel(\"Dates\") ax1.set_ylabel(\"Normalized Difference Vegetation Index\")  ax1.legend() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/notebooks/Working_with_STAC/#working-with-stac-at-scale","title":"Working With STAC - At Scale\u00b6","text":""},{"location":"examples/notebooks/Working_with_STAC/#stac-spatiotemporal-asset-catalog","title":"STAC: SpatioTemporal Asset Catalog\u00b6","text":"<p>The SpatioTemporal Asset Catalog (STAC) specification aims to standardize the way geospatial assets are exposed online and queried. A 'spatiotemporal asset' is any file that represents information about the earth captured in a certain space and time. The initial focus is primarily remotely-sensed imagery (from satellites, but also planes, drones, balloons, etc), but the core is designed to be extensible to SAR, full motion video, point clouds, hyperspectral, LiDAR and derived data like NDVI, Digital Elevation Models, mosaics, etc.</p> <p>Ref: https://github.com/radiantearth/stac-spechttps://github.com/radiantearth/stac-spec</p> <p>Using STAC makes data indexation and discovery really easy. In addition to the Collection/Item/Asset (data) specifications, data providers are also encouraged to follow a STAC API specification:  https://github.com/radiantearth/stac-api-spec</p> <p>The API is compliant with the OGC API - Features standard (formerly known as OGC Web Feature Service 3), in that it defines many of the endpoints that STAC uses. A STAC API should be compatible and usable with any OGC API - Features clients. The STAC API can be thought of as a specialized Features API to search STAC Catalogs, where the features returned are STAC Items, that have common properties, links to their assets and geometries that represent the footprints of the geospatial assets.</p>"},{"location":"examples/notebooks/Working_with_STAC/#sentinel-2","title":"Sentinel 2\u00b6","text":"<p>Thanks to Digital Earth Africa and in collaboration with Sinergise, Element 84, Amazon Web Services (AWS) and the Committee on Earth Observation Satellites (CEOS), Sentinel 2 (Level 2) data over Africa, usually stored as JPEG2000, has been translated to COG more important a STAC database and API has been setup.</p> <p>https://www.digitalearthafrica.org/news/operational-and-ready-use-satellite-data-now-available-across-africa</p> <p>The API is provided by @element84 and follows the latest specification: https://earth-search.aws.element84.com/v0</p>"},{"location":"examples/notebooks/Working_with_STAC/#titiler-stac-cog","title":"TiTiler: STAC + COG\u00b6","text":"<p>Docs: https://github.com/developmentseed/titiler/blob/main/docs/src/endpoints/stac.md</p> <p>TiTiler was first designed to work with single COG by passing the file URL to the tiler. e.g : <code>https://myendpoint/cog/tiles/1/2/3?url=https://somewhere.com/mycog.tif</code></p> <p>With STAC is a bit different because we first have to read the STAC items and then know which assets to read.</p> <p>Example of STAC Item</p> <pre><code>{\n    \"type\": \"Feature\",\n    \"id\": \"S2A_34SGA_20200318_0_L2A\",\n\n    \"geometry\": {...},\n    \"properties\": {\n        \"datetime\": \"2020-03-18T09:11:33Z\",\n        ...\n    },\n    \"collection\": \"sentinel-s2-l2a-cogs\",\n    \"assets\": {\n        \"thumbnail\": {\n            \"title\": \"Thumbnail\",\n            \"type\": \"image/png\",\n            \"href\": \"https://myurl.com/preview.jpg\"\n        },\n        ...\n        \"B03\": {\n            \"title\": \"Band 3 (green)\",\n            \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\",\n            \"href\": \"https://myurl.com/B03.tif\",\n            \"proj:shape\": [\n                10980,\n                10980\n            ],\n            \"proj:transform\": [\n                10,\n                0,\n                699960,\n                0,\n                -10,\n                3600000,\n                0,-*\n                0,\n                1\n            ]\n        },\n        ...\n    },\n    \"links\": [...]\n}\n</code></pre> <p>To be able to create Web Map tile from the <code>B03</code> asset you'll need to pass the STAC Item url and the asset name:</p> <p><code>https://myendpoint/stac/tiles/1/2/3?url=https://somewhere.com/item.json&amp;assets=B03</code></p>"},{"location":"examples/notebooks/Working_with_STAC/#requirements","title":"Requirements\u00b6","text":"<p>To be able to run this notebook you'll need the following requirements:</p> <ul> <li>rasterio</li> <li>folium</li> <li>httpx</li> <li>tqdm</li> </ul> <p><code>!pip install rasterio folium httpx tqdm</code></p>"},{"location":"examples/notebooks/Working_with_STAC/#search-for-stac-items","title":"Search for STAC Items\u00b6","text":"<p>See https://github.com/radiantearth/stac-api-spec for more documentation about the stac API</p> <ol> <li>AOI</li> </ol> <p>You can use geojson.io to define your search AOI</p>"},{"location":"examples/notebooks/Working_with_STAC/#use-titiler-endpoint","title":"Use Titiler endpoint\u00b6","text":"<p>https://titiler.xyz/api.html#/SpatioTemporal%20Asset%20Catalog</p> <p><code>{endpoint}/stac/tiles/{tileMatrixSetId}/{z}/{x}/{y}.{format}?url={stac_item}&amp;{otherquery params}</code></p> <p><code>{endpoint}/stac/bbox/{minx},{miny},{maxx},{maxy}.{format}?url={stac_item}&amp;{otherquery params}</code></p> <p><code>{endpoint}/stac/point/{minx},{miny}?url={stac_item}&amp;{otherquery params}</code></p>"},{"location":"examples/notebooks/Working_with_STAC/#visualize-one-item","title":"Visualize One Item\u00b6","text":""},{"location":"examples/notebooks/Working_with_STAC/#more","title":"More\u00b6","text":"<p>titiler doesn't return only png or jpeg but can also return Numpy array directly</p>"},{"location":"examples/notebooks/Working_with_STAC_simple/","title":"Working With STAC","text":"In\u00a0[\u00a0]: Copied! <pre># Uncomment this line if you need to install the dependencies\n# !pip install folium requests rasterio\n</pre> # Uncomment this line if you need to install the dependencies # !pip install folium requests rasterio In\u00a0[\u00a0]: Copied! <pre>import httpx\n\nfrom rasterio.features import bounds as featureBounds\n\nfrom folium import Map, TileLayer, GeoJson\n\n%pylab inline\n</pre> import httpx  from rasterio.features import bounds as featureBounds  from folium import Map, TileLayer, GeoJson  %pylab inline In\u00a0[\u00a0]: Copied! <pre>titiler_endpoint = (\n    \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind.\n)\nstac_item = \"https://earth-search.aws.element84.com/v1/collections/sentinel-2-l2a/items/S2A_30TVT_20221112_0_L2A\"\n</pre> titiler_endpoint = (     \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind. ) stac_item = \"https://earth-search.aws.element84.com/v1/collections/sentinel-2-l2a/items/S2A_30TVT_20221112_0_L2A\" In\u00a0[\u00a0]: Copied! <pre>item = httpx.get(stac_item).json()\nprint(item)\n</pre> item = httpx.get(stac_item).json() print(item) In\u00a0[\u00a0]: Copied! <pre>for it, asset in item[\"assets\"].items():\n    print(\"Name:\", it, \"| Format:\", asset[\"type\"])\n</pre> for it, asset in item[\"assets\"].items():     print(\"Name:\", it, \"| Format:\", asset[\"type\"]) In\u00a0[\u00a0]: Copied! <pre>bounds = featureBounds(item)\n\nm = Map(\n    tiles=\"OpenStreetMap\",\n    location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),\n    zoom_start=8,\n)\n\ngeo_json = GeoJson(data=item)\ngeo_json.add_to(m)\nm\n</pre> bounds = featureBounds(item)  m = Map(     tiles=\"OpenStreetMap\",     location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2),     zoom_start=8, )  geo_json = GeoJson(data=item) geo_json.add_to(m) m In\u00a0[\u00a0]: Copied! <pre># Get Tile URL\nr = httpx.get(\n    f\"{titiler_endpoint}/stac/info\",\n    params=(\n        (\"url\", stac_item),\n        # Get info for multiple assets\n        (\"assets\", \"visual\"),\n        (\"assets\", \"red\"),\n        (\"assets\", \"blue\"),\n        (\"assets\", \"green\"),\n    ),\n).json()\nprint(r)\n</pre> # Get Tile URL r = httpx.get(     f\"{titiler_endpoint}/stac/info\",     params=(         (\"url\", stac_item),         # Get info for multiple assets         (\"assets\", \"visual\"),         (\"assets\", \"red\"),         (\"assets\", \"blue\"),         (\"assets\", \"green\"),     ), ).json() print(r) In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",\n    params={\n        \"url\": stac_item,\n        \"assets\": \"visual\",\n        \"minzoom\": 8,  # By default titiler will use 0\n        \"maxzoom\": 14,  # By default titiler will use 24\n    },\n).json()\n\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2), zoom_start=10\n)\n\ntiles = TileLayer(\n    tiles=r[\"tiles\"][0],\n    min_zoom=r[\"minzoom\"],\n    max_zoom=r[\"maxzoom\"],\n    opacity=1,\n    attr=\"ESA\",\n)\ntiles.add_to(m)\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",     params={         \"url\": stac_item,         \"assets\": \"visual\",         \"minzoom\": 8,  # By default titiler will use 0         \"maxzoom\": 14,  # By default titiler will use 24     }, ).json()  m = Map(     location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2), zoom_start=10 )  tiles = TileLayer(     tiles=r[\"tiles\"][0],     min_zoom=r[\"minzoom\"],     max_zoom=r[\"maxzoom\"],     opacity=1,     attr=\"ESA\", ) tiles.add_to(m) m In\u00a0[\u00a0]: Copied! <pre># Get Tile URL\nr = httpx.get(\n    f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",\n    params={\n        \"url\": stac_item,\n        \"assets\": \"visual\",\n        \"asset_bidx\": \"visual|3,1,2\",\n        \"minzoom\": 8,  # By default titiler will use 0\n        \"maxzoom\": 14,  # By default titiler will use 24\n    },\n).json()\n\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2), zoom_start=12\n)\n\ntiles = TileLayer(\n    tiles=r[\"tiles\"][0],\n    min_zoom=r[\"minzoom\"],\n    max_zoom=r[\"maxzoom\"],\n    opacity=1,\n    attr=\"ESA\",\n)\ntiles.add_to(m)\nm\n</pre> # Get Tile URL r = httpx.get(     f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",     params={         \"url\": stac_item,         \"assets\": \"visual\",         \"asset_bidx\": \"visual|3,1,2\",         \"minzoom\": 8,  # By default titiler will use 0         \"maxzoom\": 14,  # By default titiler will use 24     }, ).json()  m = Map(     location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2), zoom_start=12 )  tiles = TileLayer(     tiles=r[\"tiles\"][0],     min_zoom=r[\"minzoom\"],     max_zoom=r[\"maxzoom\"],     opacity=1,     attr=\"ESA\", ) tiles.add_to(m) m In\u00a0[\u00a0]: Copied! <pre># Get Tile URL\nr = httpx.get(\n    f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",\n    params=(\n        (\"url\", stac_item),\n        (\"assets\", \"red\"),\n        (\"assets\", \"green\"),\n        (\"assets\", \"blue\"),\n        # Most of the Sentinel L2A Assets have only one band\n        # So we don't have to pass the bidx\n        # (\"assets_bidx\", \"red|1\"),\n        # (\"assets_bidx\", \"green|1\"),\n        # (\"assets_bidx\", \"blue|\"),\n        (\"minzoom\", 8),\n        (\"maxzoom\", 14),\n        (\"rescale\", \"0,2000\"),\n    ),\n).json()\n\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2), zoom_start=11\n)\n\ntiles = TileLayer(\n    tiles=r[\"tiles\"][0],\n    min_zoom=r[\"minzoom\"],\n    max_zoom=r[\"maxzoom\"],\n    opacity=1,\n    attr=\"ESA\",\n)\ntiles.add_to(m)\nm\n</pre> # Get Tile URL r = httpx.get(     f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",     params=(         (\"url\", stac_item),         (\"assets\", \"red\"),         (\"assets\", \"green\"),         (\"assets\", \"blue\"),         # Most of the Sentinel L2A Assets have only one band         # So we don't have to pass the bidx         # (\"assets_bidx\", \"red|1\"),         # (\"assets_bidx\", \"green|1\"),         # (\"assets_bidx\", \"blue|\"),         (\"minzoom\", 8),         (\"maxzoom\", 14),         (\"rescale\", \"0,2000\"),     ), ).json()  m = Map(     location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2), zoom_start=11 )  tiles = TileLayer(     tiles=r[\"tiles\"][0],     min_zoom=r[\"minzoom\"],     max_zoom=r[\"maxzoom\"],     opacity=1,     attr=\"ESA\", ) tiles.add_to(m) m <p>Use an expression to calculate a band index (NDVI) based on information contained in multiple assets.</p> In\u00a0[\u00a0]: Copied! <pre># Get Tile URL\nr = httpx.get(\n    f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",\n    params=(\n        (\"url\", stac_item),\n        (\"expression\", \"(nir-red)/(nir+red)\"),  # NDVI\n        # We need to tell rio-tiler that each asset is a Band\n        # (so it will select the first band within each asset automatically)\n        (\"asset_as_band\", True),\n        (\"rescale\", \"-1,1\"),\n        (\"minzoom\", 8),\n        (\"maxzoom\", 14),\n        (\"colormap_name\", \"viridis\"),\n    ),\n).json()\n\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2), zoom_start=10\n)\n\ntiles = TileLayer(\n    tiles=r[\"tiles\"][0],\n    min_zoom=r[\"minzoom\"],\n    max_zoom=r[\"maxzoom\"],\n    opacity=1,\n    attr=\"ESA\",\n)\ntiles.add_to(m)\nm\n</pre> # Get Tile URL r = httpx.get(     f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",     params=(         (\"url\", stac_item),         (\"expression\", \"(nir-red)/(nir+red)\"),  # NDVI         # We need to tell rio-tiler that each asset is a Band         # (so it will select the first band within each asset automatically)         (\"asset_as_band\", True),         (\"rescale\", \"-1,1\"),         (\"minzoom\", 8),         (\"maxzoom\", 14),         (\"colormap_name\", \"viridis\"),     ), ).json()  m = Map(     location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2), zoom_start=10 )  tiles = TileLayer(     tiles=r[\"tiles\"][0],     min_zoom=r[\"minzoom\"],     max_zoom=r[\"maxzoom\"],     opacity=1,     attr=\"ESA\", ) tiles.add_to(m) m <p>If you don't use the  <code>asset_as_band=True</code> option, you need to append the band to the asset name within the expression. For example, <code>nir</code> becomes <code>nir_b1</code>.</p> In\u00a0[\u00a0]: Copied! <pre># Get Tile URL\nr = httpx.get(\n    f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",\n    params=(\n        (\"url\", stac_item),\n        (\"expression\", \"(nir_b1-red_b1)/(nir_b1+red_b1)\"),  # NDVI\n        (\"rescale\", \"-1,1\"),\n        (\"minzoom\", 8),\n        (\"maxzoom\", 14),\n        (\"colormap_name\", \"viridis\"),\n    ),\n).json()\n\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2), zoom_start=10\n)\n\ntiles = TileLayer(\n    tiles=r[\"tiles\"][0],\n    min_zoom=r[\"minzoom\"],\n    max_zoom=r[\"maxzoom\"],\n    opacity=1,\n    attr=\"ESA\",\n)\ntiles.add_to(m)\nm\n</pre> # Get Tile URL r = httpx.get(     f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",     params=(         (\"url\", stac_item),         (\"expression\", \"(nir_b1-red_b1)/(nir_b1+red_b1)\"),  # NDVI         (\"rescale\", \"-1,1\"),         (\"minzoom\", 8),         (\"maxzoom\", 14),         (\"colormap_name\", \"viridis\"),     ), ).json()  m = Map(     location=((bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2), zoom_start=10 )  tiles = TileLayer(     tiles=r[\"tiles\"][0],     min_zoom=r[\"minzoom\"],     max_zoom=r[\"maxzoom\"],     opacity=1,     attr=\"ESA\", ) tiles.add_to(m) m In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/notebooks/Working_with_STAC_simple/#working-with-stac","title":"Working With STAC\u00b6","text":""},{"location":"examples/notebooks/Working_with_STAC_simple/#stac-spatiotemporal-asset-catalog","title":"STAC: SpatioTemporal Asset Catalog\u00b6","text":"<p>The SpatioTemporal Asset Catalog (STAC) specification aims to standardize the way geospatial assets are exposed online and queried. A 'spatiotemporal asset' is any file that represents information about the earth captured in a certain space and time. The initial focus is primarily remotely-sensed imagery (from satellites, but also planes, drones, balloons, etc), but the core is designed to be extensible to SAR, full motion video, point clouds, hyperspectral, LiDAR and derived data like NDVI, Digital Elevation Models, mosaics, etc.</p> <p>Ref: https://github.com/radiantearth/stac-spechttps://github.com/radiantearth/stac-spec</p> <p>Using STAC makes data indexation and discovery really easy. In addition to the Collection/Item/Asset (data) specifications, data providers are also encouraged to follow a STAC API specification:  https://github.com/radiantearth/stac-api-spec</p> <p>The API is compliant with the OGC API - Features standard (formerly known as OGC Web Feature Service 3), in that it defines many of the endpoints that STAC uses. A STAC API should be compatible and usable with any OGC API - Features clients. The STAC API can be thought of as a specialized Features API to search STAC Catalogs, where the features returned are STAC Items, that have common properties, links to their assets and geometries that represent the footprints of the geospatial assets.</p>"},{"location":"examples/notebooks/Working_with_STAC_simple/#requirements","title":"Requirements\u00b6","text":"<p>To be able to run this notebook you'll need the following requirements:</p> <ul> <li>folium</li> <li>httpx</li> <li>rasterio</li> </ul> <p><code>!pip install folium httpx rasterio</code></p>"},{"location":"examples/notebooks/Working_with_STAC_simple/#display-one-asset","title":"Display one asset\u00b6","text":""},{"location":"examples/notebooks/Working_with_STAC_simple/#select-indexes-for-assets","title":"Select Indexes for assets\u00b6","text":""},{"location":"examples/notebooks/Working_with_Statistics/","title":"Working with Statistics","text":"In\u00a0[16]: Copied! <pre># setup\nimport httpx\nimport json\n\ntitiler_endpoint = (\n    \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind.\n)\ncog_url = \"https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\"\n</pre> # setup import httpx import json  titiler_endpoint = (     \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind. ) cog_url = \"https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\" In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/info\",\n    params={\n        \"url\": cog_url,\n    },\n).json()\n\nprint(json.dumps(r))\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/info\",     params={         \"url\": cog_url,     }, ).json()  print(json.dumps(r)) In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/statistics\",\n    params={\n        \"url\": cog_url,\n    },\n).json()\n\nprint(json.dumps(r))\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/statistics\",     params={         \"url\": cog_url,     }, ).json()  print(json.dumps(r)) <p>This endpoint is far more configurable than <code>/info</code>. You can specify which bands to analyse, how to generate the histogram, and pre-process the image.</p> <p>For example, if you wanted to get the statistics of the VARI of the image you can use the <code>expression</code> parameter to conduct simple band math:</p> In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/statistics\",\n    params={\n        \"url\": cog_url,\n        \"expression\": \"(b2-b1)/(b1+b2-b3)\",  # expression for the VARI\n        \"histogram_range\": \"-1,1\",\n    },\n).json()\n\nprint(json.dumps(r))\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/statistics\",     params={         \"url\": cog_url,         \"expression\": \"(b2-b1)/(b1+b2-b3)\",  # expression for the VARI         \"histogram_range\": \"-1,1\",     }, ).json()  print(json.dumps(r)) <p>Alternatively, if you would like to get statistics for only a certain area, you can specify an area via a feature or a feature collection.</p> <p>(Note: this endpoint is not available in the mosaicjson endpoint, only <code>/cog</code> and <code>/stac</code>)</p> In\u00a0[5]: Copied! <pre>mahebourg = \"\"\"\n{\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"properties\": {},\n      \"geometry\": {\n        \"coordinates\": [\n          [\n            [\n              57.70358910197049,\n              -20.384114558699935\n            ],\n            [\n              57.68564920588395,\n              -20.384114558699935\n            ],\n            [\n              57.68209507552771,\n              -20.39855066753664\n            ],\n            [\n              57.68666467170024,\n              -20.421074640746554\n            ],\n            [\n              57.70341985766697,\n              -20.434397129770545\n            ],\n            [\n              57.72999121319131,\n              -20.42392955694521\n            ],\n            [\n              57.70358910197049,\n              -20.384114558699935\n            ]\n          ]\n        ],\n        \"type\": \"Polygon\"\n      }\n    }\n  ]\n}\n\"\"\"\n</pre> mahebourg = \"\"\" {   \"type\": \"FeatureCollection\",   \"features\": [     {       \"type\": \"Feature\",       \"properties\": {},       \"geometry\": {         \"coordinates\": [           [             [               57.70358910197049,               -20.384114558699935             ],             [               57.68564920588395,               -20.384114558699935             ],             [               57.68209507552771,               -20.39855066753664             ],             [               57.68666467170024,               -20.421074640746554             ],             [               57.70341985766697,               -20.434397129770545             ],             [               57.72999121319131,               -20.42392955694521             ],             [               57.70358910197049,               -20.384114558699935             ]           ]         ],         \"type\": \"Polygon\"       }     }   ] } \"\"\" In\u00a0[\u00a0]: Copied! <pre># NOTE: This is a POST request, unlike all other requests in this example\nr = httpx.post(\n    f\"{titiler_endpoint}/cog/statistics\",\n    data=mahebourg,\n    params={\n        \"url\": cog_url,\n        \"max_size\": 1024,\n    },\n    timeout=20,\n).json()\n\nprint(json.dumps(r))\n</pre> # NOTE: This is a POST request, unlike all other requests in this example r = httpx.post(     f\"{titiler_endpoint}/cog/statistics\",     data=mahebourg,     params={         \"url\": cog_url,         \"max_size\": 1024,     },     timeout=20, ).json()  print(json.dumps(r)) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/notebooks/Working_with_Statistics/#working-with-statistics","title":"Working with Statistics\u00b6","text":""},{"location":"examples/notebooks/Working_with_Statistics/#intro","title":"Intro\u00b6","text":"<p>Titiler allows you to get statistics and summaries of your data without having to load the entire dataset yourself. These statistics can be summaries of entire COG files, STAC items, or individual parts of the file, specified using GeoJSON.</p> <p>Below, we will go over some of the statistical endpoints in Titiler - <code>/info</code> and <code>/statistics</code>.</p> <p>(Note: these examples will be using the <code>/cog</code> endpoint, but everything is also available for <code>/stac</code> and <code>/mosaicjson</code> unless otherwise noted)</p>"},{"location":"examples/notebooks/Working_with_Statistics/#info","title":"Info\u00b6","text":"<p>The <code>/info</code> endpoint returns general metadata about the image/asset.</p> <ul> <li>Bounds</li> <li>CRS</li> <li>Band metadata, such as names of the bands and their descriptions</li> <li>Number of bands in the image</li> <li>Overview levels</li> <li>Image width and height</li> </ul>"},{"location":"examples/notebooks/Working_with_Statistics/#statistics","title":"Statistics\u00b6","text":"<p>For even more statistics of the image, you can use the <code>/statistics</code> endpoint. This includes even more info, including:</p> <ul> <li>Summary statistics about overall pixel values, such min, max, mean, and count</li> <li>Histogram of the pixel values</li> <li>Percentiles</li> </ul> <p>Statistics are generated both for the image as a whole and for each band individually.</p>"},{"location":"examples/notebooks/Working_with_nonWebMercatorTMS/","title":"Working With TileMatrixSets (other than WebMercator)","text":"<p>This Notebook shows how to use and display tiles with non-webmercator TileMatrixSet</p> In\u00a0[\u00a0]: Copied! <pre># Uncomment if you need to install those module within the notebook\n# !pip install ipyleaflet httpx\n</pre> # Uncomment if you need to install those module within the notebook # !pip install ipyleaflet httpx In\u00a0[\u00a0]: Copied! <pre>import json\n\nimport httpx\n\nfrom ipyleaflet import (\n    Map,\n    basemaps,\n    basemap_to_tiles,\n    TileLayer,\n    WMSLayer,\n    GeoJSON,\n    projections,\n)\n</pre> import json  import httpx  from ipyleaflet import (     Map,     basemaps,     basemap_to_tiles,     TileLayer,     WMSLayer,     GeoJSON,     projections, ) In\u00a0[\u00a0]: Copied! <pre>titiler_endpoint = (\n    \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind.\n)\nurl = \"https://s3.amazonaws.com/opendata.remotepixel.ca/cogs/natural_earth/world.tif\"  # Natural Earth WORLD tif\n</pre> titiler_endpoint = (     \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind. ) url = \"https://s3.amazonaws.com/opendata.remotepixel.ca/cogs/natural_earth/world.tif\"  # Natural Earth WORLD tif In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(f\"{titiler_endpoint}/tileMatrixSets\").json()\n\nprint(\"Supported TMS:\")\nfor tms in r[\"tileMatrixSets\"]:\n    print(\"-\", tms[\"id\"])\n</pre> r = httpx.get(f\"{titiler_endpoint}/tileMatrixSets\").json()  print(\"Supported TMS:\") for tms in r[\"tileMatrixSets\"]:     print(\"-\", tms[\"id\"]) In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\", params={\"url\": url}\n).json()\n\nm = Map(center=(0, 0), zoom=2, basemap={}, crs=projections.EPSG3857)\n\nlayer = TileLayer(url=r[\"tiles\"][0], opacity=1)\nm.add_layer(layer)\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\", params={\"url\": url} ).json()  m = Map(center=(0, 0), zoom=2, basemap={}, crs=projections.EPSG3857)  layer = TileLayer(url=r[\"tiles\"][0], opacity=1) m.add_layer(layer) m In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/WorldCRS84Quad/tilejson.json\", params={\"url\": url}\n).json()\n\nm = Map(center=(0, 0), zoom=1, basemap={}, crs=projections.EPSG4326)\n\nlayer = TileLayer(url=r[\"tiles\"][0], opacity=1)\nm.add_layer(layer)\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/WorldCRS84Quad/tilejson.json\", params={\"url\": url} ).json()  m = Map(center=(0, 0), zoom=1, basemap={}, crs=projections.EPSG4326)  layer = TileLayer(url=r[\"tiles\"][0], opacity=1) m.add_layer(layer) m In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/EuropeanETRS89_LAEAQuad/tilejson.json\", params={\"url\": url}\n).json()\n\nmy_projection = {\n    \"name\": \"EPSG:3035\",\n    \"custom\": True,  # This is important, it tells ipyleaflet that this projection is not on the predefined ones.\n    \"proj4def\": \"+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\",\n    \"origin\": [6500000.0, 5500000.0],\n    \"resolutions\": [8192.0, 4096.0, 2048.0, 1024.0, 512.0, 256.0],\n}\n\nm = Map(center=(50, 65), zoom=0, basemap={}, crs=my_projection)\n\nlayer = TileLayer(url=r[\"tiles\"][0], opacity=1)\nm.add_layer(layer)\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/EuropeanETRS89_LAEAQuad/tilejson.json\", params={\"url\": url} ).json()  my_projection = {     \"name\": \"EPSG:3035\",     \"custom\": True,  # This is important, it tells ipyleaflet that this projection is not on the predefined ones.     \"proj4def\": \"+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\",     \"origin\": [6500000.0, 5500000.0],     \"resolutions\": [8192.0, 4096.0, 2048.0, 1024.0, 512.0, 256.0], }  m = Map(center=(50, 65), zoom=0, basemap={}, crs=my_projection)  layer = TileLayer(url=r[\"tiles\"][0], opacity=1) m.add_layer(layer) m In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/notebooks/Working_with_nonWebMercatorTMS/#working-with-tilematrixsets-other-than-webmercator","title":"Working With TileMatrixSets (other than WebMercator)\u00b6","text":"<p>TiTiler has builtin support for serving tiles in multiple Projections by using rio-tiler and morecantile.</p>"},{"location":"examples/notebooks/Working_with_nonWebMercatorTMS/#requirements","title":"Requirements\u00b6","text":"<ul> <li>ipyleaflet</li> <li>httpx</li> </ul>"},{"location":"examples/notebooks/Working_with_nonWebMercatorTMS/#list-supported-tilematrixsets","title":"List Supported TileMatrixSets\u00b6","text":""},{"location":"examples/notebooks/Working_with_nonWebMercatorTMS/#webmercator-epsg3857","title":"WebMercator - EPSG:3857\u00b6","text":"<p>https://epsg.io/3857</p>"},{"location":"examples/notebooks/Working_with_nonWebMercatorTMS/#wgs-84-wgs84-world-geodetic-system-1984-epsg4326","title":"WGS 84 -- WGS84 - World Geodetic System 1984 - EPSG:4326\u00b6","text":"<p>https://epsg.io/4326</p>"},{"location":"examples/notebooks/Working_with_nonWebMercatorTMS/#etrs89-extended-laea-europe-epsg3035","title":"ETRS89-extended / LAEA Europe - EPSG:3035\u00b6","text":"<p>https://epsg.io/3035</p>"},{"location":"packages/application/","title":"titiler.application","text":""},{"location":"packages/application/#titilerapplication","title":"titiler.application","text":"<p>Titiler's demo application.</p>"},{"location":"packages/application/#installation","title":"Installation","text":"<pre><code>python -m pip install -U pip\n\n# From Pypi\npython -m pip install titiler.application\n\n# Or from sources\ngit clone https://github.com/developmentseed/titiler.git\ncd titiler &amp;&amp; python -m pip install -e src/titiler/core -e src/titiler/extensions -e src/titiler/mosaic -e src/titiler/application\n</code></pre> <p>Launch Application <pre><code>$ python -m pip install uvicorn\n$ uvicorn titiler.application.main:app --reload\n</code></pre></p>"},{"location":"packages/application/#package-structure","title":"Package structure","text":"<pre><code>titiler/\n \u2514\u2500\u2500 application/\n    \u251c\u2500\u2500 tests/                   - Tests suite\n    \u2514\u2500\u2500 titiler/application/     - `application` namespace package\n        \u251c\u2500\u2500 templates/\n        |   \u2514\u2500\u2500 index.html       - Landing page\n        \u251c\u2500\u2500 main.py              - Main FastAPI application\n        \u2514\u2500\u2500 settings.py          - demo settings (cache, cors...)\n</code></pre>"},{"location":"packages/core/","title":"titiler.core","text":""},{"location":"packages/core/#titilercore","title":"titiler.core","text":"<p>Core of Titiler's application. Contains blocks to create dynamic tile servers.</p>"},{"location":"packages/core/#installation","title":"Installation","text":"<pre><code>python -m pip install -U pip\n\n# From Pypi\npython -m pip install titiler.core\n\n# Or from sources\ngit clone https://github.com/developmentseed/titiler.git\ncd titiler &amp;&amp; python -m pip install -e src/titiler/core\n</code></pre>"},{"location":"packages/core/#how-to","title":"How To","text":"<pre><code>from fastapi import FastAPI\nfrom titiler.core.factory import TilerFactory\n\n# Create a FastAPI application\napp = FastAPI(\n    description=\"A lightweight Cloud Optimized GeoTIFF tile server\",\n)\n\n# Create a set of COG endpoints\ncog = TilerFactory()\n\n# Register the COG endpoints to the application\napp.include_router(cog.router, tags=[\"Cloud Optimized GeoTIFF\"])\n</code></pre>"},{"location":"packages/core/#package-structure","title":"Package structure","text":"<pre><code>titiler/\n \u2514\u2500\u2500 core/\n    \u251c\u2500\u2500 tests/                   - Tests suite\n    \u2514\u2500\u2500 titiler/core/            - `core` namespace package\n        \u251c\u2500\u2500 algorithm/\n        |   \u251c\u2500\u2500 base.py          - ABC Base Class for custom algorithms\n        |   \u251c\u2500\u2500 dem.py           - Elevation data related algorithms\n        |   \u2514\u2500\u2500 index.py         - Simple band index algorithms\n        \u251c\u2500\u2500 models/\n        |   \u251c\u2500\u2500 response.py      - Titiler's response models\n        |   \u251c\u2500\u2500 mapbox.py        - Mapbox TileJSON pydantic model\n        |   \u2514\u2500\u2500 OGC.py           - Open GeoSpatial Consortium pydantic models (TileMatrixSets...)\n        \u251c\u2500\u2500 resources/\n        |   \u251c\u2500\u2500 enums.py         - Titiler's enumerations (e.g MediaType)\n        |   \u2514\u2500\u2500 responses.py     - Custom Starlette's responses\n        \u251c\u2500\u2500 templates/\n        |   \u251c\u2500\u2500 map.html         - Simple Map viewer (built with leaflet)\n        |   \u2514\u2500\u2500 wmts.xml         - OGC WMTS document template\n        \u251c\u2500\u2500 dependencies.py      - Titiler FastAPI's dependencies\n        \u251c\u2500\u2500 errors.py            - Errors handler factory\n        \u251c\u2500\u2500 middleware.py        - Starlette middlewares\n        \u251c\u2500\u2500 factory.py           - Dynamic tiler endpoints factories\n        \u251c\u2500\u2500 routing.py           - Custom APIRoute class\n        \u251c\u2500\u2500 telemetry.py         - OpenTelemetry tracing functions\n        \u2514\u2500\u2500 utils.py             - Titiler utility functions\n</code></pre>"},{"location":"packages/extensions/","title":"titiler.extensions","text":""},{"location":"packages/extensions/#titilerextensions","title":"titiler.extensions","text":"<p>Extent TiTiler Tiler Factories</p>"},{"location":"packages/extensions/#installation","title":"Installation","text":"<pre><code>python -m pip install -U pip\n\n# From Pypi\npython -m pip install titiler.extensions\n\n# Or from sources\ngit clone https://github.com/developmentseed/titiler.git\ncd titiler &amp;&amp; python -m pip install -e src/titiler/core -e src/titiler/extensions\n</code></pre>"},{"location":"packages/extensions/#available-extensions","title":"Available extensions","text":""},{"location":"packages/extensions/#cogvalidateextension","title":"cogValidateExtension","text":"<ul> <li>Goal: adds a <code>/validate</code> endpoint which return the content of rio-cogeo <code>info</code> method</li> <li>Additional requirements: <code>titiler.extensions[\"cogeo\"]</code></li> </ul>"},{"location":"packages/extensions/#cogviewerextension","title":"cogViewerExtension","text":"<ul> <li>Goal: adds a <code>/viewer</code> endpoint which return an HTML viewer for simple COGs</li> </ul>"},{"location":"packages/extensions/#stacviewerextension","title":"stacViewerExtension","text":"<ul> <li>Goal: adds a <code>/viewer</code> endpoint which return an HTML viewer for STAC item</li> </ul>"},{"location":"packages/extensions/#wmsextension","title":"wmsExtension","text":"<ul> <li>Goal: adds a <code>/wms</code> endpoint to support OGC Web Map Service (<code>GetTile</code> and <code>GetCapabilities</code>) specification</li> </ul>"},{"location":"packages/extensions/#use-extensions","title":"Use extensions","text":"<p>Extensions must be set at TilerFactory's creation using the <code>extensions=</code> options.</p> <pre><code>from fastapi import FastAPI\nfrom titiler.core.factory import TilerFactory\nfrom titiler.extensions import cogValidateExtension\n\n# Create a FastAPI application\napp = FastAPI(description=\"A lightweight Cloud Optimized GeoTIFF tile server\")\n\n# Create a set of endpoints using TiTiler TilerFactory\ntiler = TilerFactory(\n    router_prefix=\"/cog\",\n    extensions=[\n        cogValidateExtension()  # the cogeoExtension will add a rio-cogeo /validate endpoint\n    ]\n)\n\n# Register endpoints to the application\napp.include_router(tiler.router, prefix=\"/cog\")\n</code></pre>"},{"location":"packages/extensions/#create-your-own","title":"Create your own","text":"<pre><code>from dataclasses import dataclass, field\nfrom typing import Tuple, List, Optional\nimport rasterio\nfrom starlette.responses import Response\nfrom fastapi import Depends, FastAPI, Query\nfrom titiler.core.factory import TilerFactory, FactoryExtension\nfrom titiler.core.dependencies import ImageRenderingParams\nfrom titiler.core.factory import TilerFactory\nfrom titiler.core.resources.enums import ImageType\n\n\n@dataclass\nclass thumbnailExtension(FactoryExtension):\n    \"\"\"Add endpoint to a TilerFactory.\"\"\"\n\n    # Set some options\n    max_size: int = field(default=128)\n\n    # Register method is mandatory and must take a TilerFactory object as input\n    def register(self, factory: TilerFactory):\n        \"\"\"Register endpoint to the tiler factory.\"\"\"\n\n        # register an endpoint to the factory's router\n        @factory.router.get(\n            \"/thumbnail\",\n            responses={\n                200: {\n                    \"content\": {\n                        \"image/png\": {},\n                        \"image/jpeg\": {},\n                    },\n                    \"description\": \"Return an image.\",\n                }\n            },\n            response_class=Response,\n        )\n        def thumbnail(\n            # we can reuse the factory dependency\n            src_path: str = Depends(factory.path_dependency),\n            reader_params=Depends(factory.reader_dependency),\n            layer_params=Depends(factory.layer_dependency),\n            dataset_params=Depends(factory.dataset_dependency),\n            post_process=Depends(factory.process_dependency),\n            colormap=Depends(factory.colormap_dependency),\n            render_params=Depends(factory.render_dependency),\n            env=Depends(factory.environment_dependency),\n        ):\n            with rasterio.Env(**env):\n                with factory.reader(src_path, **reader_params.as_dict()) as src:\n                    image = src.preview(\n                        max_size=self.max_size,\n                        **layer_params.as_dict(),\n                        **dataset_params.as_dict(),\n                    )\n\n            if post_process:\n                image = post_process(image)\n\n            format = ImageType.jpeg if image.mask.all() else ImageType.png\n\n            if post_process:\n                image = post_process(image)\n\n            content, media_type = factory.render_func(\n                image,\n                colormap=colormap,\n                **render_params.as_dict(),\n            )\n\n            return Response(content, media_type=media_type)\n\n# Use it\napp = FastAPI()\ntiler = TilerFactory(\n    extensions=[\n        thumbnailExtension(max_size=64)\n    ]\n)\napp.include_router(tiler.router)\n</code></pre>"},{"location":"packages/mosaic/","title":"titiler.mosaic","text":""},{"location":"packages/mosaic/#titilermosaic","title":"titiler.mosaic","text":"<p>Adds support for MosaicJSON in Titiler.</p> <p>MosaicJSON is an open standard for representing metadata about a mosaic of Cloud-Optimized GeoTIFF (COG) files.</p> <p>Ref: developmentseed/mosaicjson-spec</p>"},{"location":"packages/mosaic/#installation","title":"Installation","text":"<pre><code>python -m pip install -U pip\n\n# From Pypi\npython -m pip install titiler.mosaic\n\n# Or from sources\ngit clone https://github.com/developmentseed/titiler.git\ncd titiler &amp;&amp; python -m pip install -e src/titiler/core -e src/titiler/mosaic\n</code></pre>"},{"location":"packages/mosaic/#how-to","title":"How To","text":"<pre><code>from fastapi import FastAPI\nfrom titiler.mosaic.factory import MosaicTilerFactory\n\n# Create a FastAPI application\napp = FastAPI(\n    description=\"A Mosaic tile server\",\n)\n\n# Create a set of MosaicJSON endpoints\nmosaic = MosaicTilerFactory()\n\n# Register the Mosaic endpoints to the application\napp.include_router(mosaic.router, tags=[\"MosaicJSON\"])\n</code></pre>"},{"location":"packages/mosaic/#package-structure","title":"Package structure","text":"<pre><code>titiler/\n \u2514\u2500\u2500 mosaic/\n    \u251c\u2500\u2500 tests/                   - Tests suite\n    \u2514\u2500\u2500 titiler/mosaic/          - `mosaic` namespace package\n        \u251c\u2500\u2500 models/\n        |   \u2514\u2500\u2500 responses.py     - mosaic response models\n        \u251c\u2500\u2500 errors.py            - cogeo-mosaic known errors\n        \u2514\u2500\u2500 factory.py           - Mosaic endpoints factory\n</code></pre>"},{"location":"packages/xarray/","title":"titiler.xarray","text":""},{"location":"packages/xarray/#titilerxarray","title":"titiler.xarray","text":"<p>Adds support for Xarray Dataset (NetCDF/Zarr) in Titiler.</p>"},{"location":"packages/xarray/#installation","title":"Installation","text":"<pre><code>python -m pip install -U pip\n\n# From Pypi\npython -m pip install \"titiler.xarray[full]\"\n\n# Or from sources\ngit clone https://github.com/developmentseed/titiler.git\ncd titiler &amp;&amp; python -m pip install -e src/titiler/core -e \"src/titiler/xarray[full]\"\n</code></pre>"},{"location":"packages/xarray/#installation-options","title":"Installation options","text":"<p>Default installation for <code>titiler.xarray</code> DOES NOT include <code>fsspec</code> or any storage's specific dependencies (e.g <code>s3fs</code>) nor <code>engine</code> dependencies (<code>zarr</code>, <code>h5netcdf</code>). This is to ease the customization and deployment of user's applications. If you want to use the default's dataset reader you will need to at least use the <code>[minimal]</code> dependencies (e.g <code>python -m pip install \"titiler.xarray[minimal]\"</code>).</p> <p>Here is the list of available options:</p> <ul> <li>full: <code>zarr</code>, <code>h5netcdf</code>,  <code>fsspec</code>, <code>s3fs</code>, <code>aiohttp</code>, <code>gcsfs</code></li> <li>minimal: <code>zarr</code>, <code>h5netcdf</code>,  <code>fsspec</code></li> <li>gcs: <code>gcsfs</code></li> <li>s3: <code>s3fs</code></li> <li>http: <code>aiohttp</code></li> </ul>"},{"location":"packages/xarray/#how-to","title":"How To","text":"<pre><code>from fastapi import FastAPI\n\nfrom titiler.xarray.extensions import VariablesExtension\nfrom titiler.xarray.factory import TilerFactory\n\napp = FastAPI(\n    openapi_url=\"/api\",\n    docs_url=\"/api.html\",\n    description=\"\"\"Xarray based tiles server for MultiDimensional dataset (Zarr/NetCDF).\n\n---\n\n**Documentation**: &lt;a href=\"https://developmentseed.org/titiler/\" target=\"_blank\"&gt;https://developmentseed.org/titiler/&lt;/a&gt;\n\n**Source Code**: &lt;a href=\"https://github.com/developmentseed/titiler\" target=\"_blank\"&gt;https://github.com/developmentseed/titiler&lt;/a&gt;\n\n---\n    \"\"\",\n)\n\nmd = TilerFactory(\n    router_prefix=\"/md\",\n    extensions=[\n        VariablesExtension(),\n    ],\n)\napp.include_router(md.router, prefix=\"/md\", tags=[\"Multi Dimensional\"])\n</code></pre>"},{"location":"packages/xarray/#package-structure","title":"Package structure","text":"<pre><code>titiler/\n \u2514\u2500\u2500 xarray/\n    \u251c\u2500\u2500 tests/                   - Tests suite\n    \u2514\u2500\u2500 titiler/xarray/          - `xarray` namespace package\n        \u251c\u2500\u2500 dependencies.py      - titiler-xarray dependencies\n        \u251c\u2500\u2500 extensions.py        - titiler-xarray extensions\n        \u251c\u2500\u2500 io.py                - titiler-xarray Readers\n        \u2514\u2500\u2500 factory.py           - endpoints factory\n</code></pre>"},{"location":"packages/xarray/#custom-dataset-opener","title":"Custom Dataset Opener","text":"<p>A default Dataset IO is provided within <code>titiler.xarray.Reader</code> class but will require optional dependencies (<code>fsspec</code>, <code>zarr</code>, <code>h5netcdf</code>, ...) to be installed with <code>python -m pip install \"titiler.xarray[full]\"</code>. Dependencies are optional so the entire package size can be optimized to only include dependencies required by a given application.</p> <p>Example:</p> <p>requirements: - <code>titiler.xarray</code> (base) - <code>h5netcdf</code></p> <pre><code>from typing import Callable\nimport attr\nfrom fastapi import FastAPI\nfrom titiler.xarray.io import Reader\nfrom titiler.xarray.extensions import VariablesExtension\nfrom titiler.xarray.factory import TilerFactory\n\nimport xarray\nimport h5netcdf  # noqa\n\n# Create a simple Custom reader, using `xarray.open_dataset` opener\n@attr.s\nclass CustomReader(Reader):\n    \"\"\"Custom io.Reader using xarray.open_dataset opener.\"\"\"\n    # xarray.Dataset options\n    opener: Callable[..., xarray.Dataset] = attr.ib(default=xarray.open_dataset)\n\n\n# Create FastAPI application\napp = FastAPI(openapi_url=\"/api\", docs_url=\"/api.html\")\n\n# Create custom endpoints with the CustomReader\nmd = TilerFactory(\n    reader=CustomReader,\n    router_prefix=\"/md\",\n    extensions=[\n        # we also want to use the simple opener for the Extension\n        VariablesExtension(dataset_opener=xarray.open_dataset),\n    ],\n)\n\napp.include_router(md.router, prefix=\"/md\", tags=[\"Multi Dimensional\"])\n</code></pre>"},{"location":"user_guide/algorithms/","title":"Algorithm","text":"<p>Starting with <code>titiler&gt;=0.8</code>, we added the possibility to apply custom algorithms on Image outputs from <code>tile</code>, <code>crop</code> or <code>preview</code> endpoints.</p> <p>The algorithms are meant to overcome the limitation of <code>expression</code> (using numexpr) by allowing more complex operations.</p> <p>We added a set of custom algorithms:</p> <ul> <li><code>hillshade</code>: Create hillshade from elevation dataset (parameters: azimuth (45), angle_altitude(45))</li> <li><code>contours</code>: Create contours lines (raster) from elevation dataset (parameters: increment (35), thickness (1))</li> <li><code>slope</code>: Create degrees of slope from elevation dataset</li> <li><code>terrarium</code>: Mapzen's format to encode elevation value in RGB values  <code>elevation = (red * 256 + green + blue / 256) - 32768</code></li> <li><code>terrainrgb</code>: Mapbox/Maptiler's format to encode elevation value in RGB values <code>elevation = -10000 + ((red * 256 * 256 + green * 256 + blue) * 0.1)</code></li> <li><code>normalizedIndex</code>: Normalized Difference Index (e.g NDVI)</li> <li><code>cast</code>: Cast data to integer</li> <li><code>floor</code>: Round data to the smallest integer</li> <li> <p><code>ceil</code>: Round data to the largest integer</p> </li> <li> <p><code>min</code>: Return Min values along the <code>bands</code> axis.</p> </li> <li><code>max</code>: Return Max values along the <code>bands</code> axis.</li> <li><code>median</code>: Return Median values along the <code>bands</code> axis.</li> <li><code>mean</code>: Return Mean values along the <code>bands</code> axis.</li> <li><code>std</code>: Return the Standard Deviation along the <code>bands</code> axis.</li> <li><code>var</code>: Return Variance along the <code>bands</code> axis.</li> <li><code>sum</code>: Return Sum along the <code>bands</code> axis.</li> <li><code>grayscale</code>: Return a grayscale version of an image using ITU-R 601-2 luma transformation.</li> <li><code>bitonal</code>: All values larger than 127 are set to 255 (white), all other values to 0 (black).</li> </ul>"},{"location":"user_guide/algorithms/#usage","title":"Usage","text":"<p><pre><code># return a\nhttpx.get(\n    \"http://127.0.0.1:8081/cog/tiles/16/34059/23335\",\n    params={\n        \"url\": \"https://data.geo.admin.ch/ch.swisstopo.swissalti3d/swissalti3d_2019_2573-1085/swissalti3d_2019_2573-1085_0.5_2056_5728.tif\",\n        \"buffer\": 3,  # By default hillshade will crop the output with a 3pixel buffer, so we need to apply a buffer on the tile\n        \"algorithm\": \"hillshade\",\n    },\n)\n</code></pre> </p> <p><pre><code># Pass algorithm parameter as a json string\nhttpx.get(\n    \"http://127.0.0.1:8081/cog/preview\",\n    params={\n        \"url\": \"https://data.geo.admin.ch/ch.swisstopo.swissalti3d/swissalti3d_2019_2573-1085/swissalti3d_2019_2573-1085_0.5_2056_5728.tif\",\n        \"algorithm\": \"contour\",\n        \"algorithm_params\": json.dumps({\"minz\": 1600, \"maxz\": 2100}) # algorithm params HAVE TO be provided as a JSON string\n    },\n)\n</code></pre> </p>"},{"location":"user_guide/algorithms/#create-your-own-algorithm","title":"Create your own Algorithm","text":"<p>A titiler'w <code>Algorithm</code> must be defined using <code>titiler.core.algorithm.BaseAlgorithm</code> base class.</p> <pre><code>class BaseAlgorithm(BaseModel, metaclass=abc.ABCMeta):\n    \"\"\"Algorithm baseclass.\n\n    Note: attribute starting with `input_` or `output_` are considered as metadata\n\n    \"\"\"\n\n    # metadata\n    input_nbands: int\n    output_nbands: int\n    output_dtype: str\n    output_min: Optional[Sequence]\n    output_max: Optional[Sequence]\n\n    @abc.abstractmethod\n    def __call__(self, img: ImageData) -&gt; ImageData:\n        \"\"\"Apply algorithm\"\"\"\n        ...\n\n    class Config:\n        \"\"\"Config for model.\"\"\"\n\n        extra = \"allow\"\n</code></pre> <p>This base class defines that algorithm:</p> <ul> <li> <p>HAVE TO implement an <code>__call__</code> method which takes an ImageData as input and return an ImageData. Using <code>__call__</code> let us use the object as a callable (e.g <code>Algorithm(**kwargs)(image)</code>).</p> </li> <li> <p>can have input/output metadata (informative)</p> </li> <li> <p>can have<code>parameters</code> (enabled by <code>extra = \"allow\"</code> pydantic config)</p> </li> </ul> <p>Here is a simple example of a custom algorithm:</p> <pre><code>from titiler.core.algorithm import BaseAlgorithm\nfrom rio_tiler.models import ImageData\n\nclass Multiply(BaseAlgorithm):\n\n    # Parameters\n    factor: int # There is no default, which means calls to this algorithm without any parameter will fail\n\n    # We don't set any metadata for this Algorithm\n\n    def __call__(self, img: ImageData) -&gt; ImageData:\n        # Multiply image data bcy factor\n        data = img.data * self.factor\n\n        # Create output ImageData\n        return ImageData(\n            data,\n            img.mask,\n            assets=img.assets,\n            crs=img.crs,\n            bounds=img.bounds,\n        )\n</code></pre>"},{"location":"user_guide/algorithms/#class-vs-script","title":"Class Vs script","text":"<p>Using a Pydantic's <code>BaseModel</code> class to construct the custom algorithm enables two things parametrization and type casting/validation.</p> <p>If we look at the <code>Multiply</code> algorithm, we can see it needs a <code>factor</code> parameter. In TiTiler (in the post_process dependency) we will pass this parameter via query string (e.g <code>/preview.png?algo=multiply&amp;algo_parameter={\"factor\":3}</code>) and pydantic will make sure we use the right types/values.</p> <pre><code># Available algorithm\nalgo = {\"multiply\": Multiply}\n\ndef post_process_dependency(\n    algorithm: Literal[tuple(algo.keys())] = Query(None, description=\"Algorithm name\"),\n    algorithm_params: str = Query(None, description=\"Algorithm parameter\"),\n) -&gt; Optional[BaseAlgorithm]:\n    \"\"\"Data Post-Processing dependency.\"\"\"\n    # Parse `algorithm_params` JSON parameters\n    kwargs = json.loads(algorithm_params) if algorithm_params else {}\n    if algorithm:\n        # Here we construct the Algorithm Object with the kwargs from the `algo_params` query-parameter\n        return algo[algorithm](**kwargs)\n\n    return None\n</code></pre>"},{"location":"user_guide/algorithms/#dependency","title":"Dependency","text":"<p>To be able to use your own algorithm in TiTiler's endpoint, you need to create a <code>Dependency</code> to tell the application which algorithms are available.</p> <p>To ease the dependency creation, we added a <code>dependency</code> property in the <code>titiler.core.algorithm.Algorithms</code> class, which will return a FastAPI dependency to be added to the endpoints.</p> <p>Note: The <code>Algorithms</code> class is a store for the algorithm that can be extented using the <code>.register()</code> method.</p> <pre><code>from typing import Callable\nfrom titiler.core.algorithm import algorithms as default_algorithms\nfrom titiler.core.algorithm import Algorithms\nfrom titiler.core.factory import TilerFactory\n\n# Add the `Multiply` algorithm to the default ones\nalgorithms: Algorithms = default_algorithms.register({\"multiply\": Multiply})\n\n# Create a PostProcessParams dependency\nPostProcessParams: Callable = algorithms.dependency\n\nendpoints = TilerFactory(process_dependency=PostProcessParams)\n</code></pre>"},{"location":"user_guide/algorithms/#order-of-operation","title":"Order of operation","text":"<p>When creating a map tile (or other images), we will first apply the <code>algorithm</code>, then the <code>rescaling</code>, and finally the <code>color_formula</code>.</p> <pre><code>with reader(url as src_dst:\n    image = src_dst.tile(\n        x,\n        y,\n        z,\n    )\n    dst_colormap = getattr(src_dst, \"colormap\", None)\n\n# Apply algorithm\nif post_process:\n    image = post_process(image)\n\n# Apply data rescaling\nif rescale:\n    image.rescale(rescale)\n\n# Apply color-formula\nif color_formula:\n    image.apply_color_formula(color_formula)\n\n# Determine the format\nif not format:\n    format = ImageType.jpeg if image.mask.all() else ImageType.png\n\n# Image Rendering\nreturn image.render(\n    img_format=format.driver,\n    colormap=colormap or dst_colormap,\n    **format.profile,\n)\n</code></pre>"},{"location":"user_guide/dynamic_tiling/","title":"Dynamic Tiling","text":"<p>TiTiler's first goal is to create a lightweight but performant dynamic tile server... but what do we mean by this?</p> <p>When you zoom/pan on a web map, you are visualizing either vector or raster data that is loaded by your web client (e.g Chrome). Vector Tiles are rendered On the Fly, meaning the map library (e.g Mapbox GL-JS) will apply the styling on the vector it receives to create a visual representation on the map. This is possible because vector data can be encoded and compressed very efficiently and result in each tile being only a couple of kilo octets.</p> <p>On the other side, raster data is a really dense format, a <code>256 x 256 x 3</code> tile (True color image) needs to encode <code>196 608</code> values, and depending on the data type (Integer, Float, Complex), a raster tile can be really heavy. Depending on the dataset data type, some operations might be needed in order to obtain a visual representation (e.g. rescaling, colormap, ... ). The map library will almost only accept Uint8 RGB(A) tile encoded as PNG, JPEG or Webp.</p>"},{"location":"user_guide/dynamic_tiling/#static-tiling","title":"Static tiling","text":"<p><code>Static</code> tiling is referring to <code>static</code> tiles (file on storage) that are pre-rendered from input dataset. Here are the steps needed to create those tiles:</p> <ul> <li>rescale the data to integer (0 -&gt; 255), if datatype in not Uint8</li> <li>reproject the data to Web Mercator (or the projection of the web map application)</li> <li>split the data in tiles (256x256 or 512x512) and create different zoom levels (ref: gdal.org/programs/gdal2tiles.html)</li> </ul> <p>When the tiles are available on a storage, you can either put a web server (e.g. tilecache, mapserver) or maybe directly put a CDN, which will allow map client to <code>fetch</code> the tiles.</p>"},{"location":"user_guide/dynamic_tiling/#pro","title":"Pro","text":"<ul> <li>Fast</li> <li>Relatively simple to create the tiles (<code>gdal2tiles.py</code>)</li> </ul>"},{"location":"user_guide/dynamic_tiling/#cons","title":"Cons","text":"<ul> <li>You have to manage a lot of tiny files</li> <li>Choices are made for the user (projection, rescaling, ...)</li> <li>Some tiles might never been loaded</li> </ul>"},{"location":"user_guide/dynamic_tiling/#dynamic-tiling","title":"Dynamic tiling","text":"<p>The goal of the <code>Dynamic Tiling</code> process is to get rid of all the pre-processing steps, by creating a tile server which can access the raw data (COG) and apply operations (rescaling, reprojection, image encoding) to create the visual tiles on the fly.</p> <ul> <li>Open the file and get internal metadata (stored in the header of the file)</li> <li>Read internal parts needed to construct the output tile</li> <li>Apply data rescaling (if needed)</li> <li>Apply colormap (if needed)</li> <li>Encode the data into a visual image format (JPEG, PNG, WEBP)</li> </ul>"},{"location":"user_guide/dynamic_tiling/#pro_1","title":"Pro","text":"<ul> <li>Access the raw data</li> <li>Multiple projection support</li> <li>User defined rescaling (when working with non-byte data)</li> <li>User defined Colormap</li> <li>Selection of bands/bands combination/bands math</li> <li>Apply custom processing on the tile data</li> <li>Dynamic mosaic with multiple datasets (user defined image order and pixel selection methods)</li> </ul>"},{"location":"user_guide/dynamic_tiling/#cons_1","title":"Cons","text":"<ul> <li>Latency. Creating a tile from a COG means at least 2 GET requests (if web optimized).</li> <li>Dynamic tile server are more complex than Static tile server (which just serve files from a storage)</li> <li>No easy update (you need to re-write the whole COG)</li> <li>Tile server like TiTiler might present too many options (this is because titiler aim to support all COG types)</li> </ul>"},{"location":"user_guide/dynamic_tiling/#summary","title":"Summary","text":"<p>With <code>Static</code> tile generation, you are often limited because you are visualizing data that is fixed and stored somewhere on a disk. With <code>Dynamic tiling</code>, users have the possibility to apply their own choice of processing (e.g rescaling, masking) before creating the <code>image</code>.</p> <p>Static tiling will always be faster to load than dynamic tiling, but a cache layer can be set up in front of the dynamic tiler. Using a dynamic tiler often means that the same tile won't be served twice (because users can set multiple options).</p>"},{"location":"user_guide/dynamic_tiling/#links","title":"Links","text":"<p>https://medium.com/devseed/cog-talk-part-1-whats-new-941facbcd3d1</p> <p>https://kylebarron.dev/blog/cog-mosaic/overview</p> <p>https://mapdataservices.wordpress.com/2014/05/05/digital-mappings-dynamic-makeover/</p> <p>https://medium.com/indigoag-eng/more-and-better-satellite-imagery-through-dynamic-tiling-60dcd7ce66ce</p> <p>https://sparkgeo.com/blog/terradactile-generate-cogs-from-aws-terrain-tiles/</p> <p>https://www.azavea.com/blog/2019/04/23/using-cloud-optimized-geotiffs-cogs/</p> <p>https://hi.stamen.com/stamen-aws-lambda-tiler-blog-post-76fc1138a145</p>"},{"location":"user_guide/getting_started/","title":"Getting Started","text":"<p>TiTiler is a modern map tile server that helps developers quickly serve geospatial data on the web. Think of it as a specialized tool that takes large geographic files (like satellite imagery) and slices them into small, web-friendly map tiles that load efficiently in browser-based maps.</p> <p>Built on FastAPI, TiTiler makes working with Cloud-Optimized GeoTIFFs, Spatio Temporal Asset Catalog and other spatial data formats straightforward, even if you're not a GIS expert. It handles all the complex work of processing geographic data and serving it through simple API endpoints that any web developer can use.</p> <p>In the past, putting maps on websites was a real pain. Developers had to use bulky tools like GeoServer that were hard to set up, or spend hours making thousands of static tiny map images with tools like gdal2tiles that couldn't be changed later. TiTiler makes this so much easier. It creates dynamic map pieces right when you need them, instead of making them all beforehand. It works great with modern cloud data and doesn't need complicated setup. This means less headache and more time to focus on building cool map features that users will love.</p>"},{"location":"user_guide/getting_started/#dynamic-vs-static-tiles-whats-the-difference","title":"Dynamic vs. Static Tiles: What's the Difference?","text":"<p>Static tiles are like pre-printed map pieces stored in folders. Once created, they're locked\u2014changing anything means starting over. They use lots of storage, but load quickly.</p> <p>TiTiler's dynamic tiles work like a chef cooking to order. When someone views your map, TiTiler grabs just the data needed and creates tiles on the spot. This lets you instantly change colors, adjust contrast, or highlight different features. Your map becomes flexible and responsive, adapting to what users need right now, rather than being stuck with choices made earlier.</p> <p>More on Dynamic Tiling</p>"},{"location":"user_guide/getting_started/#lets-get-titiler-up-and-running","title":"Let's Get TiTiler Up and Running!","text":"<p>Now that we understand the advantage of TiTiler's dynamic approach, let's get it running on your local machine. Follow these steps:</p>"},{"location":"user_guide/getting_started/#1-create-your-project-workspace","title":"1. Create Your Project Workspace","text":"<p>First, let's create a dedicated space for our TiTiler project. Open your terminal (Command Prompt or PowerShell on Windows, Terminal on macOS/Linux) and run:</p> <pre><code># Works on all operating systems\nmkdir Titiler\ncd Titiler\n</code></pre> <p>\ud83d\udca1 Pro Tip: Keeping your TiTiler project in its own folder makes it easier to manage and prevents conflicts with other Python projects.</p>"},{"location":"user_guide/getting_started/#2-set-up-a-python-virtual-environment","title":"2. Set Up a Python Virtual Environment","text":"<p>a. Create the virtual environment:    <pre><code>python -m venv titiler\n</code></pre> b. Activate the virtual environment:    - For Linux/macOS: <pre><code>source titiler/bin/activate\n</code></pre>    - For Windows: <pre><code>titiler\\Scripts\\activate\n</code></pre></p>"},{"location":"user_guide/getting_started/#3-install-titiler-and-its-dependencies","title":"3. Install TiTiler and Its Dependencies","text":"<p>With your environment activated, install TiTiler and the web server it needs:</p> <pre><code>pip install titiler.core uvicorn\n</code></pre> <p>This command installs the core TiTiler package and Uvicorn, a lightning-fast ASGI server.</p> <p>\ud83d\udca1 What's happening: TiTiler.core contains the essential functionality for serving map tiles. Uvicorn is the engine that will run our FastAPI application.</p>"},{"location":"user_guide/getting_started/#4-create-your-titiler-application","title":"4. Create Your TiTiler Application","text":"<p>Now for the fun part! Create a file named <code>main.py</code> with the following code:</p> <pre><code>from fastapi import FastAPI\nfrom titiler.core.factory import TilerFactory\n\nfrom starlette.middleware.cors import CORSMiddleware\n\napp = FastAPI()\n\n# Add CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],  # Allows all origins (for development - be more specific in production)\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Create a TilerFactory for Cloud-Optimized GeoTIFFs\ncog = TilerFactory()\n\n# Register all the COG endpoints automatically\napp.include_router(cog.router, tags=[\"Cloud Optimized GeoTIFF\"])\n\n\n# Optional: Add a welcome message for the root endpoint\n@app.get(\"/\")\ndef read_index():\n    return {\"message\": \"Welcome to TiTiler\"}\n</code></pre> <p>\ud83d\udca1 Code Breakdown:</p> <ul> <li>We create a FastAPI app and add CORS middleware to allow web maps to access our images</li> <li>The <code>TilerFactory()</code> creates all the endpoints needed for serving COG tiles</li> <li>We include those endpoints in our app with <code>app.include_router()</code></li> <li>A simple home endpoint provides a welcome message</li> </ul>"},{"location":"user_guide/getting_started/#5-launch-your-titiler-server","title":"5. Launch Your TiTiler Server","text":"<p>Run the following command to start the server: <pre><code>uvicorn main:app --reload\n</code></pre> You should see an output similar to this:</p> <p></p> <p>\ud83d\udca1 The <code>--reload</code> flag automatically restarts the server whenever you change your code - perfect for development!</p>"},{"location":"user_guide/getting_started/#6-explore-your-titiler-api","title":"6. Explore Your TiTiler API","text":"<p>Open your browser and go to:</p> <p><code>http://127.0.0.1:8000/</code> - See your welcome message</p> <p></p> <p><code>http://127.0.0.1:8000/docs</code> - Explore the interactive API documentation. The <code>/docs</code> page is your mission control center. It shows all the endpoints TiTiler created for you and lets you test them directly in your browser:</p> <p></p>"},{"location":"user_guide/getting_started/#visualizing-your-geospatial-data","title":"Visualizing Your Geospatial Data","text":"<p>Now that your server is running, let's see what it can do with real data!</p>"},{"location":"user_guide/getting_started/#quick-preview-of-your-raster","title":"Quick Preview of Your Raster","text":"<p>To get a quick preview of any Cloud-Optimized GeoTIFF, use:</p> <pre><code>http://127.0.0.1:8000/preview?url=file:///path_to_your_raster.tif\n</code></pre> <p>\u26a0\ufe0f Note: Replace the path with the actual path to your COG file. Remember to use the full path for local files.</p>"},{"location":"user_guide/getting_started/#visualizing-a-specific-tile-z-x-y","title":"Visualizing a Specific Tile (Z, X, Y)","text":"<p>When working with web maps, understanding tile coordinates is essential. Let's break down what Z, X, Y values mean:</p> <ul> <li>Z (zoom level): How far in/out you're zoomed. Lower numbers (0-5) show the whole world with less detail; higher numbers (15-22) show smaller areas with more detail.</li> <li>X (column): Horizontal position, increasing eastward.</li> <li>Y (row): Vertical position, increasing southward.</li> </ul> <p>At zoom level 0, there's just 1 tile for the whole world. Each zoom level increase splits each tile into 4 more detailed tiles.</p>"},{"location":"user_guide/getting_started/#why-visualize-specific-tiles","title":"Why Visualize Specific Tiles?","text":"<ul> <li>Performance: Load only what users can see</li> <li>Debugging: Inspect problematic tiles</li> <li>Specific Analysis: Extract data from exact locations</li> </ul>"},{"location":"user_guide/getting_started/#finding-z-x-y-for-your-image","title":"Finding Z, X, Y for Your Image","text":"<p>The <code>rio_tiler</code> and <code>morecantile</code> library makes this straightforward:</p> <pre><code>from rio_tiler.io import Reader\nimport morecantile\n\n# Web Mercator is the default tiling scheme for most web map clients\nWEB_MERCATOR_TMS = morecantile.tms.get(\"WebMercatorQuad\")\n\nwith Reader('/path/to/your/raster.tif', tms=WEB_MERCATOR_TMS) as src:\n    bbox = src.get_geographic_bounds(\"epsg:4326\")\n    zoom = 15\n    # Find all tiles covering the bounding box\n    tiles = list(src.tms.tiles(bbox[0], bbox[1], bbox[2], bbox[3], zoom))\n    for t in tiles:\n        print(\"Tile coordinate (x, y, z):\", t.x, t.y, t.z)\n</code></pre>"},{"location":"user_guide/getting_started/#viewing-a-specific-tile-in-titiler","title":"Viewing a Specific Tile in TiTiler","text":"<p>For example, if your tile has coordinates <code>x=5412, y=12463, z=15</code>, you would access the specific tile with:</p> <pre><code>http://127.0.0.1:8000/tiles/WebMercatorQuad/15/5412/12463.png?url=raster.tif\n</code></pre> <p>URL components explained:</p> <ul> <li><code>WebMercatorQuad/</code>: The tiling scheme (this should match your raster's CRS - TiTiler will reproject on-the-fly if needed, but using the correct scheme improves performance and accuracy)</li> <li><code>{z}/{x}/{y}</code>: Your tile coordinates</li> <li><code>.png</code>: Output format (alternatives: <code>.jpg</code>, <code>.webp</code>, <code>.tif</code>)</li> <li><code>?url=raster.tif</code>: Source raster file</li> </ul> <p>More on Tiling Schemes</p>"},{"location":"user_guide/getting_started/#creating-a-web-map-with-leaflet","title":"Creating a Web Map with Leaflet","text":"<p>Leaflet is a lightweight, open-source JavaScript library for interactive maps. It lets you combine base maps (like OpenStreetMap) with overlays from custom tile servers such as TiTiler.</p> <p>The following code (in map.html) loads a base map, adds your TiTiler raster overlay, and automatically sets the map's view to the raster's bounds:</p> map.html Code <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;Leaflet Basemap + TiTiler Raster Overlay&lt;/title&gt;\n  &lt;meta charset=\"utf-8\"&gt;\n  &lt;meta name=\"viewport\" content=\"initial-scale=1.0\"&gt;\n  &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" /&gt;\n  &lt;script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=\"map\" style=\"width: 100%; height: 600px;\"&gt;&lt;/div&gt;\n  &lt;script&gt;\n    // Initialize the map with OpenStreetMap as the basemap\n    var map = L.map('map').setView([0, 0], 2);\n    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n      maxZoom: 19,\n      attribution: '&amp;copy; OpenStreetMap contributors'\n    }).addTo(map);\n\n    /// Define the local raster path and TiTiler endpoint\n    // Replace with your own full GeoTIFF path - use the appropriate format for your OS.\n    var rasterPath = 'file:///path_to_your_raster.tif';\n    var titilerUrl = 'http://127.0.0.1:8000/tiles/WebMercatorQuad/{z}/{x}/{y}.png?url=' + encodeURIComponent(rasterPath);\n\n    // Add the TiTiler raster overlay with some transparency\n    L.tileLayer(titilerUrl, {\n      tileSize: 256,\n      opacity: 0.7,\n      maxZoom: 22\n    }).addTo(map);\n\n    // Fetch the raster's bounding box from TiTiler and adjust the map view accordingly\n    var boundsUrl = 'http://127.0.0.1:8000/bounds?url=' + encodeURIComponent(rasterPath);\n    console.log(boundsUrl)\n    fetch(boundsUrl)\n      .then(response =&gt; response.json())\n      .then(data =&gt; {\n        console.log(\"Bounds data:\", data);\n        if (data &amp;&amp; data.bounds) {\n          // data.bounds is [minX, minY, maxX, maxY]\n          var b = data.bounds;\n          // Convert to Leaflet bounds: [[southWest_lat, southWest_lng], [northEast_lat, northEast_lng]]\n          var leafletBounds = [[b[1], b[0]], [b[3], b[2]]];\n          map.fitBounds(leafletBounds);\n        } else {\n          console.error(\"No bounds returned from TiTiler.\");\n        }\n      })\n      .catch(error =&gt; console.error(\"Error fetching bounds:\", error));\n\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"user_guide/getting_started/#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":""},{"location":"user_guide/getting_started/#cors-issues","title":"CORS Issues","text":"<p>If you encounter \"Access to fetch at X has been blocked by CORS policy\" errors in your browser console, make sure you:</p> <ul> <li>Have included the CORS middleware in <code>main.py</code> as shown above</li> <li>Restart your TiTiler server after making changes</li> </ul>"},{"location":"user_guide/getting_started/#file-not-found-errors","title":"File Not Found Errors","text":"<p>When using <code>file:///</code> URLs: - Make sure to use the absolute path to your file with the correct format for your operating system:</p> <ul> <li>Windows: <code>file:///C:/Users/username/data/image.tif</code></li> <li>macOS: <code>file:///Users/username/data/image.tif</code></li> <li>Linux: <code>file:///home/username/data/image.tif</code></li> </ul>"},{"location":"user_guide/getting_started/#no-tiles-showing","title":"No Tiles Showing","text":"<p>If your map loads but your tiles don't appear:</p> <ul> <li>Check the browser console for errors</li> <li>Verify that your GeoTIFF is Cloud-Optimized (use <code>rio cogeo validate</code> from the rio-cogeo package)</li> <li>Try different zoom levels - your data might not be visible at all scales</li> </ul> <p>Created by Dimple Jain</p>"},{"location":"user_guide/getting_started/#default-application","title":"Default Application","text":"<p><code>TiTiler</code> comes with a default (complete) application with support for COG, STAC, and MosaicJSON. You can install and start the application locally by doing:</p> <pre><code># Update pip\npython -m pip install -U pip\n\n# Install titiler packages\npython -m pip install uvicorn titiler.application\n\n# Start application using uvicorn\nuvicorn titiler.application.main:app\n\n&gt; INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n</code></pre> <p>See the default endpoints documentation pages:</p> <ul> <li><code>/cog</code> - Cloud Optimized GeoTIFF</li> <li><code>/mosaicjson</code> - MosaicJSON</li> <li><code>/stac</code> - Spatio Temporal Asset Catalog</li> <li><code>/tileMatrixSets</code> - Tiling Schemes</li> <li><code>/algorithms</code> - Algorithms</li> <li><code>/colorMaps</code> - ColorMaps</li> </ul>"},{"location":"user_guide/getting_started/#settings","title":"Settings","text":"<p>The default application can be customized using environment variables defined in <code>titiler.application.settings.ApiSettings</code> class. Each variable needs to be prefixed with <code>TITILER_API_</code>.</p> <ul> <li><code>NAME</code> (str): name of the application. Defaults to <code>titiler</code>.</li> <li><code>CORS_ORIGINS</code> (str, <code>,</code> delimited origins): allowed CORS origin. Defaults to <code>*</code>.</li> <li><code>CORS_ALLOW_METHODS</code> (str, <code>,</code> delimited methods): allowed CORS methods. Defaults to <code>GET</code>.</li> <li><code>CACHECONTROL</code> (str): Cache control header to add to responses. Defaults to <code>\"public, max-age=3600\"</code>.</li> <li><code>ROOT_PATH</code> (str): path behind proxy.</li> <li><code>DEBUG</code> (str): adds <code>LoggerMiddleware</code> and <code>TotalTimeMiddleware</code> in the middleware stack.</li> <li><code>DISABLE_COG</code> (bool): disable <code>/cog</code> endpoints.</li> <li><code>DISABLE_STAC</code> (bool): disable <code>/stac</code> endpoints.</li> <li><code>DISABLE_MOSAIC</code> (bool): disable <code>/mosaic</code> endpoints.</li> <li><code>LOWER_CASE_QUERY_PARAMETERS</code> (bool): transform all query-parameters to lower case (see developmentseed/titiler!321).</li> <li><code>GLOBAL_ACCESS_TOKEN</code> (str | None): a string which is required in the <code>?access_token=</code> query param with every request.</li> </ul>"},{"location":"user_guide/getting_started/#extending-titilers-app","title":"Extending TiTiler's app","text":"<p>If you want to include all of Titiler's built-in endpoints, but also include customized endpoints, you can import and extend the app directly.</p> <pre><code>python -m pip install titiler.application uvicorn # also installs titiler.core and titiler.mosaic\n</code></pre> <p>These can then be used like:</p> <pre><code># Add private COG endpoints requiring token validation\nfrom fastapi import APIRouter, Depends, HTTPException, Security\nfrom fastapi.security.api_key import APIKeyQuery\n\nfrom titiler.application.main import app\nfrom titiler.core.factory import TilerFactory\n\nimport uvicorn\n\napi_key_query = APIKeyQuery(name=\"access_token\", auto_error=False)\n\n\ndef token_validation(access_token: str = Security(api_key_query)):\n    \"\"\"stupid token validation.\"\"\"\n    if not access_token:\n        raise HTTPException(status_code=401, detail=\"Missing `access_token`\")\n\n    # if access_token == `token` then OK\n    if not access_token == \"token\":\n        raise HTTPException(status_code=401, detail=\"Invalid `access_token`\")\n\n    return True\n\n\n# Custom router with token dependency\nrouter = APIRouter(dependencies=[Depends(token_validation)])\ntiler = TilerFactory(router_prefix=\"private/cog\", router=router)\n\napp.include_router(tiler.router, prefix=\"/private/cog\", tags=[\"Private\"])\n\n\nif __name__ == '__main__':\n    uvicorn.run(app=app, host=\"127.0.0.1\", port=8080, log_level=\"info\")\n</code></pre> <p>More on customization</p>"},{"location":"user_guide/output_format/","title":"Output data format","text":"<p><code>TiTiler</code> supports the common output format for map tiles: JPEG, PNG and WEBP.</p> <p>While some formats (e.g PNG) are able to encode Uint16 or Float datatypes, most web browsers only supports 8 bit data (meaning that it has to be between 0 and 255). It's on the user to know what datatype is the input source (COG), and what kind of <code>post processing</code> is required to create a valid web map tile.</p> <p><code>TiTiler</code> also has support for more complex output data formats, such as JPEG2000 or GeoTIFF. While it might not be useful for FrontEnd display (most browsers can't decode GeoTIFF natively), some users could want to transmit the data as <code>raw</code> values to some applications (non-web display).</p> <p>Default output types/extensions are:</p> <ul> <li><code>.tif</code>: image/tiff; application=geotiff</li> <li><code>.jp2</code>: image/jp2</li> <li><code>.png</code>: image/png</li> <li><code>.pngraw</code>: image/png</li> <li><code>.jpeg</code>: image/jpeg</li> <li><code>.jpg</code>: image/jpg</li> <li><code>.webp</code>: image/webp</li> <li><code>.npy</code>: application/x-binary</li> </ul>"},{"location":"user_guide/output_format/#numpytile","title":"NumpyTile","text":"<p>While <code>.tif</code> could be interesting, decoding the <code>GeoTIFF</code> format requires non-native/default libraries. Recently, in collaboration with Planet, we started exploring the use of a <code>Numpy-native format</code> to encode the data array.</p> <p>planetlabs/numpytiles-spec</p> <p>This specification attempts to create a standard for representing uncompressed, full bit-depth, raster imagery that can be easily communicated between a server and a client.</p> <p>Example:</p> <pre><code>import numpy\nimport requests\nfrom io import BytesIO\n\nurl = \"https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\"\n\nr = requests.get(\"http://127.0.0.1:8000/cog/tiles/14/10818/9146.npy\",\n    params = {\n        \"url\": url,\n    }\n)\ndata = numpy.load(BytesIO(r.content))\nprint(data.shape)\n&gt;&gt;&gt; (4, 256, 256)\n\n# By default titiler will return a concatenated data,mask array.\ndata, mask = data[0:-1], data[-1]\n</code></pre> <p>Notebook: Working_with_NumpyTile</p>"},{"location":"user_guide/output_format/#jsonresponse","title":"JSONResponse","text":"<p>Sometimes rio-tiler's responses can contain <code>NaN</code>, <code>Infinity</code> or <code>-Infinity</code> values (e.g for Nodata). Sadly there is no proper ways to encode those values in JSON or at least not all web client supports it.</p> <p>In  order to allow TiTiler to return valid responses we added a custom <code>JSONResponse</code> in <code>v0.3.10</code> which will automatically translate <code>float('nan')</code>, <code>float('inf')</code> and <code>float('-inf')</code> to <code>null</code> and thus avoid in valid JSON response.</p> <pre><code>from fastapi import FastAPI\nfrom titiler.core.resources.responses import JSONResponse\n\napp = FastAPI(default_response_class=JSONResponse,)\n\n@app.get(\"/something\")\ndef return_something():\n    return float('nan')\n</code></pre> <p>This <code>JSONResponse</code> is used by default in <code>titiler</code> Tiler Factories where <code>NaN</code> are expected (<code>info</code>, <code>statistics</code> and <code>point</code> endpoints).</p>"},{"location":"user_guide/rendering/","title":"Rendering Options","text":"<p>When using Titiler to visualize imagery, there are some helper options that change how the data appears on the screen. You can:</p> <ol> <li>Adjust the band values using basic color-oriented image operations</li> <li>Apply color maps to create heat maps, colorful terrain based on band value</li> <li>Rescale images on a per-band basis</li> </ol>"},{"location":"user_guide/rendering/#color-map","title":"Color Map","text":"<p>Color maps are arrays of colors, used to map pixel values to specific colors. For example, it is possible to map a single band DEM, where the pixel values denote height, to a color map which shows higher values as white:</p> <p></p> <p>TiTiler supports both default colormaps (each with a name) and custom color maps.</p>"},{"location":"user_guide/rendering/#default-colormaps","title":"Default Colormaps","text":"<p>Default colormaps pre-made, each with a given name. These maps come from the <code>rio-tiler</code> library, which has taken colormaps packaged with Matplotlib and has added others that are commonly used with raster data.</p> <p>A list of available color maps can be found in Titiler's Swagger docs, or in the rio-tiler documentation.</p> <p>To use a default colormap, simply use the parameter <code>colormap_name</code>:</p> <pre><code>import httpx\n\nresp = httpx.get(\n    \"https://titiler.xyz/cog/preview\",\n    params={\n        \"url\": \"&lt;YOUR DATASET URL HERE&gt;\",\n        \"colormap_name\": \"&lt;YOUR COLORMAP NAME HERE&gt;\" # e.g. autumn_r\n    }\n)\n</code></pre> <p>You can take any of the colormaps listed on <code>rio-tiler</code>, and add <code>_r</code> to reverse it.</p>"},{"location":"user_guide/rendering/#custom-colormaps","title":"Custom Colormaps","text":"<p>If you'd like to specify your own colormap, you can specify your own using an encoded JSON:</p> <pre><code>import httpx\n\nresponse = httpx.get(\n    \"https://titiler.xyz/cog/preview\",\n    params={\n        \"url\": \"&lt;YOUR DATASET URL HERE&gt;\",\n        \"bidx\": \"1\",\n        \"colormap\": json.dumps({\n            \"0\": \"#e5f5f9\",\n            \"10\": \"#99d8c9\",\n            \"255\": \"#2ca25f\",\n        })\n    }\n)\n</code></pre> <p>TiTiler supports colormaps that are both discrete (where pixels will be one of the colors that you specify) and linear (where pixel colors will blend between the given colors).</p> <p>For more information, please check out rio-tiler's docs.</p> <p>It is also possible to add a colormap dependency to automatically apply a default colormap.</p>"},{"location":"user_guide/rendering/#color-formula","title":"Color Formula","text":"<p>Color formulae are simple commands that apply color corrections to images. This is useful for reducing artefacts like atmospheric haze, dark shadows, or muted colors.</p> <p>Titiler supports color formulae as defined in Mapbox's <code>rio-color</code> plugin. These include the operations (taken from the <code>rio-color</code> docs):</p> <ul> <li> <p>Gamma adjustment: adjusts RGB values according to a power law, effectively brightening or darkening the midtones. It can be very effective in satellite imagery for reducing atmospheric haze in the blue and green bands.</p> </li> <li> <p>Sigmoidal contrast adjustment: can alter the contrast and brightness of an image in a way that matches human's non-linear visual perception. It works well to increase contrast without blowing out the very dark shadows or already-bright parts of the image.</p> </li> <li> <p>Saturation: can be thought of as the \"colorfulness\" of a pixel. Highly saturated colors are intense and almost cartoon-like, low saturation is more muted, closer to black and white. You can adjust saturation independently of brightness and hue, but the data must be transformed into a different color space.</p> </li> </ul> <p>In TiTiler, color_formulae are applied through the <code>color_formula</code> parameter as a string. An example of this option in action:</p> <pre><code>import httpx\n\nresponse = httpx.get(\n    \"https://titiler.xyz/cog/preview\",\n    params={\n        \"url\": \"&lt;YOUR DATASET URL HERE&gt;\",\n        \"color_formula\": \"gamma rg 1.3, sigmoidal rgb 22 0.1, saturation 1.5\"\n    }\n)\n</code></pre>"},{"location":"user_guide/rendering/#rescaling","title":"Rescaling","text":"<p>Rescaling is the act of adjusting the minimum and maximum values when rendering an image. In an image with a single band, the rescaled minimum value will be set to black, and the rescaled maximum value will be set to white. This is useful if you want to accentuate features that only appear at a certain pixel value (e.g. you have a DEM, but you want to highlight how the terrain changes between sea level and 100m).</p> <p>All TiTiler endpoinds returning image support <code>rescale</code> parameter. The parameter should be in form of <code>\"rescale={min},{max}\"</code>.</p> <pre><code>import httpx\n\nresponse = httpx.get(\n    \"https;//titiler.xyz/cog/preview\",\n    params={\n        \"url\": \"&lt;YOUR DATASET URL HERE&gt;\",\n        \"rescale\": \"0,100\",\n    },\n)\n</code></pre> <p>TiTiler supports rescaling on a per-band basis, using multiple <code>rescale</code> parameters.</p> <pre><code>import httpx\n\nresponse = httpx.get(\n    \"https;//titiler.xyz/cog/preview\",\n    params=(\n        (\"url\", \"&lt;YOUR DATASET URL HERE&gt;\"),\n        (\"rescale\", \"0,100\"),\n        (\"rescale\", \"0,1000\"),\n        (\"rescale\", \"0,10000\"),\n    ),\n)\n</code></pre> <p>By default, TiTiler will rescale the bands using the min/max values of the input datatype. For example, PNG images 8 or 16-bit unsigned pixels, giving a possible range of 0 to 255 or 0 to 65,536, so Titiler will use these ranges to rescale to the output format.</p> <p>For certain datasets (e.g. DEMs), this default behaviour can make the image seem washed out (or even entirely one color), so if you see this happen look into rescaling your images to something that makes sense for your data.</p> <p>It is also possible to add a rescaling dependency to automatically apply a default rescale.</p>"},{"location":"user_guide/tile_matrix_sets/","title":"TileMatrixSets","text":"<p>Slippy map tiles are square or rectangular images that follow a coordinate system defined by a grid called <code>Tile Matrix</code>: docs.opengeospatial.org/is/17-083r2/17-083r2.html. The <code>Web Mercator grid</code> is the de facto standard for Web maps. Made popular by google since 2005, it has pros and cons and:</p> <p>With any such projection, some distortion is unavoidable. In the Mercator projection, geographical features further from the equator are exaggerated in size. For example, Greenland appears to be of a similar size to Africa. However, Africa is actually more than 14 times as large (by area).</p> <p>ref: developer.tomtom.com/blog/decoded/understanding-map-tile-grids-and-zoom-levels</p> <p>As one of the first requirements, we built <code>TiTiler</code> with support for serving tiles in multiple Projections by using <code>rio-tiler</code> and <code>morecantile</code> which provide the low level TileMatrixSets support.</p> <pre><code>$ curl http://127.0.0.1:8000/tileMatrixSets | jq '.tileMatrixSets[] | .id'\n\"LINZAntarticaMapTilegrid\"\n\"EuropeanETRS89_LAEAQuad\"\n\"CanadianNAD83_LCC\"\n\"UPSArcticWGS84Quad\"\n\"NZTM2000\"\n\"NZTM2000Quad\"\n\"UTM31WGS84Quad\"\n\"UPSAntarcticWGS84Quad\"\n\"WorldMercatorWGS84Quad\"\n\"WGS1984Quad\"\n\"WorldCRS84Quad\"\n\"WebMercatorQuad\"\n</code></pre> <p>You can easily add more TileMatrixSet support, see custom tms.</p> <p>Notebook: Working_with_nonWebMercatorTMS</p>"}]}